<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Tensor Dynamics | Navier-Stokes Simulation</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600&family=IBM+Plex+Sans:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0e17;
            --bg-secondary: #141923;
            --bg-tertiary: #1a2332;
            --accent-primary: #00d9ff;
            --accent-secondary: #ff006e;
            --accent-tertiary: #8b5cf6;
            --accent-yellow: #fbbf24;
            --text-primary: #e0e6ed;
            --text-secondary: #8b95a5;
            --border: rgba(0, 217, 255, 0.2);
        }

        body {
            font-family: 'IBM Plex Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            position: relative;
        }

        /* Atmospheric background grid */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 217, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 217, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
            z-index: 0;
        }

        .container {
            position: relative;
            z-index: 1;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            padding: 2rem 3rem;
            border-bottom: 1px solid var(--border);
            background: rgba(10, 14, 23, 0.8);
            backdrop-filter: blur(10px);
        }

        h1 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 300;
            font-family: 'JetBrains Mono', monospace;
        }

        .main-content {
            flex: 1;
            display: flex;
            gap: 2rem;
            padding: 2rem 3rem;
            overflow: hidden;
        }

        .simulation-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .canvas-container {
            position: relative;
            flex: 1;
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-secondary);
            box-shadow: 0 8px 32px rgba(0, 217, 255, 0.1);
        }

        .canvas-border {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .canvas-border rect {
            fill: none;
            stroke: var(--accent-primary);
            stroke-width: 2;
            opacity: 0.4;
        }

        canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
            image-rendering: pixelated;
        }

        .interaction-hint {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(10, 14, 23, 0.9);
            border: 1px solid var(--accent-primary);
            border-radius: 6px;
            padding: 0.75rem 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-secondary);
            pointer-events: none;
            z-index: 10;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 12px rgba(0, 217, 255, 0.2);
            max-width: 280px;
            line-height: 1.5;
        }

        .interaction-hint strong {
            color: var(--accent-primary);
            font-weight: 600;
        }

        .interaction-hint .yellow {
            color: var(--accent-yellow);
        }

        .visualization-modes {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .mode-btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            padding: 0.5rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-weight: 400;
        }

        .mode-btn:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
            transform: translateY(-2px);
        }

        .mode-btn.active {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
            font-weight: 600;
        }

        .mode-btn[title] {
            position: relative;
        }

        .mode-btn[title]:hover::after {
            content: attr(title);
            position: absolute;
            top: 50%;
            left: calc(100% + 15px);
            transform: translateY(-50%);
            background: rgba(10, 14, 23, 0.95);
            color: var(--text-primary);
            padding: 0.75rem 1rem;
            border-radius: 6px;
            border: 1px solid var(--accent-primary);
            font-size: 0.7rem;
            font-weight: 400;
            max-width: 280px;
            white-space: normal;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 217, 255, 0.3);
            line-height: 1.4;
        }

        .mode-btn[title]:hover::before {
            content: '';
            position: absolute;
            top: 50%;
            left: calc(100% + 9px);
            transform: translateY(-50%);
            border: 6px solid transparent;
            border-right-color: var(--accent-primary);
            z-index: 1000;
            pointer-events: none;
        }

        .controls-panel {
            width: 320px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 217, 255, 0.1);
        }

        .control-section {
            margin-bottom: 1.5rem;
        }

        .control-section h3 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--accent-primary);
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .control-group {
            margin-bottom: 1rem;
        }

        .control-group label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(0, 217, 255, 0.5);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px rgba(0, 217, 255, 0.5);
        }

        .value-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--accent-primary);
            float: right;
        }

        .btn {
            font-family: 'JetBrains Mono', monospace;
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
            margin-bottom: 0.5rem;
        }

        .btn:hover {
            border-color: var(--accent-primary);
            background: rgba(0, 217, 255, 0.1);
            transform: translateY(-2px);
        }

        .btn-primary {
            background: var(--accent-yellow);
            border-color: var(--accent-yellow);
            color: var(--bg-primary);
            font-weight: 600;
            box-shadow: 0 0 12px rgba(251, 191, 36, 0.3);
        }

        .btn-primary:hover {
            background: #fcd34d;
            border-color: #fcd34d;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.5);
        }

        .stats {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-secondary);
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            line-height: 1.6;
        }

        .stats-value {
            color: var(--accent-primary);
            font-weight: 600;
        }

        .tensor-info {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-secondary);
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            line-height: 1.6;
            margin-top: 1rem;
            border-left: 3px solid var(--accent-tertiary);
        }

        .tensor-info h4 {
            color: var(--accent-tertiary);
            font-size: 0.7rem;
            margin-bottom: 0.5rem;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .container > * {
            animation: fadeIn 0.6s ease-out backwards;
        }

        header {
            animation-delay: 0.1s;
        }

        .simulation-panel {
            animation-delay: 0.2s;
        }

        .controls-panel {
            animation-delay: 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Fluid Tensor Dynamics</h1>
            <div class="subtitle">Real-time Navier-Stokes Solution • Velocity Gradient Tensor Decomposition</div>
        </header>

        <div class="main-content">
            <div class="simulation-panel">
                <div class="visualization-modes">
                    <button class="mode-btn active" data-mode="velocity" title="Shows velocity magnitude and direction using color. Hue indicates flow direction, brightness shows speed.">Velocity Field</button>
                    <button class="mode-btn" data-mode="pressure" title="Pressure field from solving ∇²p = -∇·(u·∇u). Enforces incompressibility via Helmholtz-Hodge decomposition.">Pressure</button>
                    <button class="mode-btn" data-mode="vorticity" title="Vorticity ω = ∇×u measures local fluid rotation. Cyan = counterclockwise (positive), Magenta = clockwise (negative).">Vorticity (∇×u)</button>
                    <button class="mode-btn" data-mode="divergence" title="Divergence ∇·u measures expansion/compression. Should be ~0 for incompressible flow (mass conservation).">Divergence (∇·u)</button>
                    <button class="mode-btn" data-mode="strain" title="Strain rate tensor S_ij = ½(∂u_i/∂x_j + ∂u_j/∂x_i) shows pure deformation without rotation. Color indicates principal strain direction.">Strain Rate Tensor</button>
                    <button class="mode-btn" data-mode="rotation" title="Rotation rate tensor Ω_ij = ½(∂u_i/∂x_j - ∂u_j/∂x_i) isolates pure rotation without deformation.">Rotation Rate Tensor</button>
                    <button class="mode-btn" data-mode="decomposition" title="RGB decomposition: R = clockwise rotation, G = strain magnitude, B = counterclockwise rotation. Shows how velocity gradient tensor ∇u splits into symmetric (strain) + antisymmetric (rotation) parts.">Tensor Decomposition</button>
                    <button class="mode-btn" data-mode="particles" title="Lagrangian particle tracers advected by the velocity field. Visualizes flow pathlines and mixing.">Particle Tracers</button>
                </div>
                <div class="canvas-container">
                    <canvas id="fluidCanvas"></canvas>
                    <svg class="canvas-border" viewBox="0 0 100 100" preserveAspectRatio="none">
                        <rect x="1" y="1" width="98" height="98" />
                    </svg>
                    <div class="interaction-hint">
                        <strong>Click</strong> to inject a counter-rotating vortex pair<br>
                        <strong>Click &amp; drag</strong> to apply force in drag direction<br>
                        <span class="yellow">★ Use "Add Vortex Pair" button for symmetric injection</span>
                    </div>
                </div>
            </div>

            <div class="controls-panel">
                <div class="control-section">
                    <h3>Physical Parameters</h3>
                    <div class="control-group">
                        <label>
                            Viscosity (ν)
                            <span class="value-display" id="viscosity-value">0.0001</span>
                        </label>
                        <input type="range" id="viscosity" min="0" max="0.001" step="0.00001" value="0.0001">
                    </div>
                    <div class="control-group">
                        <label>
                            Time Step (Δt)
                            <span class="value-display" id="dt-value">0.1</span>
                        </label>
                        <input type="range" id="timestep" min="0.01" max="0.5" step="0.01" value="0.1">
                    </div>
                    <div class="control-group">
                        <label>
                            Force Magnitude
                            <span class="value-display" id="force-value">50</span>
                        </label>
                        <input type="range" id="force" min="1" max="200" step="1" value="50">
                    </div>
                </div>

                <div class="control-section">
                    <h3>Solver Settings</h3>
                    <div class="control-group">
                        <label>
                            Pressure Iterations
                            <span class="value-display" id="iterations-value">20</span>
                        </label>
                        <input type="range" id="iterations" min="5" max="50" step="1" value="20">
                    </div>
                    <div class="control-group">
                        <label>
                            Diffusion Iterations
                            <span class="value-display" id="diffusion-value">20</span>
                        </label>
                        <input type="range" id="diffusion-iter" min="5" max="50" step="1" value="20">
                    </div>
                </div>

                <div class="control-section">
                    <h3>Actions</h3>
                    <button class="btn btn-primary" id="add-vortex-btn">★ Add Vortex Pair</button>
                    <button class="btn" id="reset-btn">Reset Simulation</button>
                    <button class="btn" id="pause-btn">Pause</button>
                </div>

                <div class="control-section">
                    <h3>Statistics</h3>
                    <div class="stats">
                        <div>Grid: <span class="stats-value" id="grid-size">256×256</span></div>
                        <div>FPS: <span class="stats-value" id="fps">60</span></div>
                        <div>Max |u|: <span class="stats-value" id="max-velocity">0.0</span></div>
                        <div>Max |ω|: <span class="stats-value" id="max-vorticity">0.0</span></div>
                        <div>Max |S|: <span class="stats-value" id="max-strain">0.0</span></div>
                        <div>Max |Ω|: <span class="stats-value" id="max-rotation">0.0</span></div>
                    </div>
                </div>

                <div class="tensor-info">
                    <h4>Tensor Decomposition</h4>
                    The velocity gradient tensor ∇u decomposes into:<br><br>
                    <strong>∇u = S + Ω</strong><br><br>
                    S = ½(∇u + ∇uᵀ) — Symmetric strain rate<br>
                    Ω = ½(∇u − ∇uᵀ) — Antisymmetric rotation<br><br>
                    Strain deforms fluid elements without rotation. Rotation spins them without deformation.
                </div>
            </div>
        </div>
    </div>

    <script>
        // Navier-Stokes Fluid Simulation
        // Using Jos Stam's "Stable Fluids" method
        
        class FluidSimulation {
            constructor(N) {
                this.N = N;
                this.size = (N + 2) * (N + 2);
                
                // Velocity fields
                this.u = new Float32Array(this.size);
                this.v = new Float32Array(this.size);
                this.u_prev = new Float32Array(this.size);
                this.v_prev = new Float32Array(this.size);
                
                // Scalar fields
                this.density = new Float32Array(this.size);
                this.density_prev = new Float32Array(this.size);
                
                // Derived fields
                this.pressure = new Float32Array(this.size);
                this.vorticity = new Float32Array(this.size);
                this.divergence = new Float32Array(this.size);
                
                // Velocity gradient tensor components
                this.du_dx = new Float32Array(this.size);
                this.du_dy = new Float32Array(this.size);
                this.dv_dx = new Float32Array(this.size);
                this.dv_dy = new Float32Array(this.size);
                
                // Strain rate tensor (symmetric part): S_ij = 1/2 * (∂u_i/∂x_j + ∂u_j/∂x_i)
                this.S_xx = new Float32Array(this.size);
                this.S_xy = new Float32Array(this.size);
                this.S_yy = new Float32Array(this.size);
                
                // Rotation rate tensor (antisymmetric part): Ω_ij = 1/2 * (∂u_i/∂x_j - ∂u_j/∂x_i)
                this.Omega_xy = new Float32Array(this.size);
                
                // Strain rate magnitude and principal values
                this.strainMagnitude = new Float32Array(this.size);
                this.rotationMagnitude = new Float32Array(this.size);
                
                // Parameters
                this.visc = 0.0001;
                this.dt = 0.1;
                this.pressureIterations = 20;
                this.diffusionIterations = 20;
                
                // Particles for Lagrangian visualization
                this.particles = [];
                this.initParticles();
            }
            
            initParticles() {
                this.particles = [];
                const N = this.N;
                for (let i = 0; i < 2000; i++) {
                    this.particles.push({
                        x: Math.random() * N,
                        y: Math.random() * N,
                        life: 1
                    });
                }
            }
            
            IX(i, j) {
                return i + (this.N + 2) * j;
            }
            
            addForce(x, y, fx, fy, canvasWidth, canvasHeight) {
                const N = this.N;
                const i = Math.floor(x / canvasWidth * N) + 1;
                const j = Math.floor(y / canvasHeight * N) + 1;
                
                if (i > 0 && i <= N && j > 0 && j <= N) {
                    const radius = 3;
                    for (let di = -radius; di <= radius; di++) {
                        for (let dj = -radius; dj <= radius; dj++) {
                            const ni = i + di;
                            const nj = j + dj;
                            if (ni > 0 && ni <= N && nj > 0 && nj <= N) {
                                const dist = Math.sqrt(di * di + dj * dj);
                                const falloff = Math.exp(-dist * dist / (radius * radius));
                                this.u[this.IX(ni, nj)] += fx * falloff;
                                this.v[this.IX(ni, nj)] += fy * falloff;
                            }
                        }
                    }
                }
            }
            
            addVortexPair() {
                const N = this.N;
                const cx = N / 2;
                const cy = N / 2;
                const separation = N / 6;
                const strength = 15;
                const radius = N / 10;
                
                // Add two counter-rotating vortices
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        // Vortex 1 (positive rotation)
                        const dx1 = i - (cx - separation);
                        const dy1 = j - cy;
                        const r1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                        const theta1 = strength * Math.exp(-r1 * r1 / (radius * radius));
                        
                        // Vortex 2 (negative rotation)
                        const dx2 = i - (cx + separation);
                        const dy2 = j - cy;
                        const r2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                        const theta2 = -strength * Math.exp(-r2 * r2 / (radius * radius));
                        
                        // Tangential velocity components
                        this.u[this.IX(i, j)] += -dy1 * theta1 / (r1 + 1) - dy2 * theta2 / (r2 + 1);
                        this.v[this.IX(i, j)] += dx1 * theta1 / (r1 + 1) + dx2 * theta2 / (r2 + 1);
                    }
                }
            }
            
            addVortexAt(x, y, canvasWidth, canvasHeight) {
                const N = this.N;
                const cx = Math.floor(x / canvasWidth * N) + 1;
                const cy = Math.floor(y / canvasHeight * N) + 1;
                
                if (cx < 1 || cx > N || cy < 1 || cy > N) return;
                
                const separation = N / 12;
                const strength = 12;
                const radius = N / 12;
                
                // Add two counter-rotating vortices centered at click location
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        // Vortex 1 (positive rotation) - left of click
                        const dx1 = i - (cx - separation / 2);
                        const dy1 = j - cy;
                        const r1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                        const theta1 = strength * Math.exp(-r1 * r1 / (radius * radius));
                        
                        // Vortex 2 (negative rotation) - right of click
                        const dx2 = i - (cx + separation / 2);
                        const dy2 = j - cy;
                        const r2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                        const theta2 = -strength * Math.exp(-r2 * r2 / (radius * radius));
                        
                        // Tangential velocity components
                        this.u[this.IX(i, j)] += -dy1 * theta1 / (r1 + 1) - dy2 * theta2 / (r2 + 1);
                        this.v[this.IX(i, j)] += dx1 * theta1 / (r1 + 1) + dx2 * theta2 / (r2 + 1);
                    }
                }
            }
            
            reset() {
                this.u.fill(0);
                this.v.fill(0);
                this.u_prev.fill(0);
                this.v_prev.fill(0);
                this.density.fill(0);
                this.density_prev.fill(0);
                this.pressure.fill(0);
                this.vorticity.fill(0);
                this.divergence.fill(0);
                this.initParticles();
            }
            
            setBoundary(b, x) {
                const N = this.N;
                
                for (let i = 1; i <= N; i++) {
                    x[this.IX(0, i)] = b === 1 ? -x[this.IX(1, i)] : x[this.IX(1, i)];
                    x[this.IX(N + 1, i)] = b === 1 ? -x[this.IX(N, i)] : x[this.IX(N, i)];
                    x[this.IX(i, 0)] = b === 2 ? -x[this.IX(i, 1)] : x[this.IX(i, 1)];
                    x[this.IX(i, N + 1)] = b === 2 ? -x[this.IX(i, N)] : x[this.IX(i, N)];
                }
                
                x[this.IX(0, 0)] = 0.5 * (x[this.IX(1, 0)] + x[this.IX(0, 1)]);
                x[this.IX(0, N + 1)] = 0.5 * (x[this.IX(1, N + 1)] + x[this.IX(0, N)]);
                x[this.IX(N + 1, 0)] = 0.5 * (x[this.IX(N, 0)] + x[this.IX(N + 1, 1)]);
                x[this.IX(N + 1, N + 1)] = 0.5 * (x[this.IX(N, N + 1)] + x[this.IX(N + 1, N)]);
            }
            
            linearSolve(b, x, x0, a, c, iterations) {
                const N = this.N;
                const cRecip = 1.0 / c;
                
                for (let k = 0; k < iterations; k++) {
                    for (let j = 1; j <= N; j++) {
                        for (let i = 1; i <= N; i++) {
                            x[this.IX(i, j)] = (x0[this.IX(i, j)] + a * (
                                x[this.IX(i + 1, j)] +
                                x[this.IX(i - 1, j)] +
                                x[this.IX(i, j + 1)] +
                                x[this.IX(i, j - 1)]
                            )) * cRecip;
                        }
                    }
                    this.setBoundary(b, x);
                }
            }
            
            diffuse(b, x, x0, diff, iterations) {
                const N = this.N;
                const a = this.dt * diff * N * N;
                this.linearSolve(b, x, x0, a, 1 + 4 * a, iterations);
            }
            
            advect(b, d, d0, u, v) {
                const N = this.N;
                const dt0 = this.dt * N;
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        let x = i - dt0 * u[this.IX(i, j)];
                        let y = j - dt0 * v[this.IX(i, j)];
                        
                        if (x < 0.5) x = 0.5;
                        if (x > N + 0.5) x = N + 0.5;
                        const i0 = Math.floor(x);
                        const i1 = i0 + 1;
                        
                        if (y < 0.5) y = 0.5;
                        if (y > N + 0.5) y = N + 0.5;
                        const j0 = Math.floor(y);
                        const j1 = j0 + 1;
                        
                        const s1 = x - i0;
                        const s0 = 1 - s1;
                        const t1 = y - j0;
                        const t0 = 1 - t1;
                        
                        d[this.IX(i, j)] =
                            s0 * (t0 * d0[this.IX(i0, j0)] + t1 * d0[this.IX(i0, j1)]) +
                            s1 * (t0 * d0[this.IX(i1, j0)] + t1 * d0[this.IX(i1, j1)]);
                    }
                }
                
                this.setBoundary(b, d);
            }
            
            project() {
                const N = this.N;
                const h = 1.0 / N;
                
                // Compute divergence
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        this.divergence[this.IX(i, j)] = -0.5 * h * (
                            this.u[this.IX(i + 1, j)] - this.u[this.IX(i - 1, j)] +
                            this.v[this.IX(i, j + 1)] - this.v[this.IX(i, j - 1)]
                        );
                        this.pressure[this.IX(i, j)] = 0;
                    }
                }
                
                this.setBoundary(0, this.divergence);
                this.setBoundary(0, this.pressure);
                
                // Solve pressure Poisson equation
                this.linearSolve(0, this.pressure, this.divergence, 1, 4, this.pressureIterations);
                
                // Subtract pressure gradient (Helmholtz-Hodge)
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        this.u[this.IX(i, j)] -= 0.5 * (this.pressure[this.IX(i + 1, j)] - this.pressure[this.IX(i - 1, j)]) * N;
                        this.v[this.IX(i, j)] -= 0.5 * (this.pressure[this.IX(i, j + 1)] - this.pressure[this.IX(i, j - 1)]) * N;
                    }
                }
                
                this.setBoundary(1, this.u);
                this.setBoundary(2, this.v);
            }
            
            computeVelocityGradientTensor() {
                const N = this.N;
                const h = 1.0 / N;
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const idx = this.IX(i, j);
                        
                        // Velocity gradient tensor components (central differences)
                        this.du_dx[idx] = (this.u[this.IX(i + 1, j)] - this.u[this.IX(i - 1, j)]) / (2 * h);
                        this.du_dy[idx] = (this.u[this.IX(i, j + 1)] - this.u[this.IX(i, j - 1)]) / (2 * h);
                        this.dv_dx[idx] = (this.v[this.IX(i + 1, j)] - this.v[this.IX(i - 1, j)]) / (2 * h);
                        this.dv_dy[idx] = (this.v[this.IX(i, j + 1)] - this.v[this.IX(i, j - 1)]) / (2 * h);
                        
                        // Strain rate tensor (symmetric part): S = 1/2 * (∇u + ∇uᵀ)
                        this.S_xx[idx] = this.du_dx[idx];
                        this.S_yy[idx] = this.dv_dy[idx];
                        this.S_xy[idx] = 0.5 * (this.du_dy[idx] + this.dv_dx[idx]);
                        
                        // Rotation rate tensor (antisymmetric part): Ω = 1/2 * (∇u - ∇uᵀ)
                        this.Omega_xy[idx] = 0.5 * (this.dv_dx[idx] - this.du_dy[idx]);
                        
                        // Vorticity (z-component of curl in 2D = 2 * Ω_xy)
                        this.vorticity[idx] = this.dv_dx[idx] - this.du_dy[idx];
                        
                        // Strain rate magnitude: ||S|| = sqrt(2 * S_ij * S_ij)
                        this.strainMagnitude[idx] = Math.sqrt(
                            2 * (this.S_xx[idx] * this.S_xx[idx] + 
                                 2 * this.S_xy[idx] * this.S_xy[idx] + 
                                 this.S_yy[idx] * this.S_yy[idx])
                        );
                        
                        // Rotation rate magnitude: |Ω_xy|
                        this.rotationMagnitude[idx] = Math.abs(this.Omega_xy[idx]);
                    }
                }
            }
            
            advectParticles() {
                const N = this.N;
                
                for (let p of this.particles) {
                    // Get velocity at particle position (bilinear interpolation)
                    const i = Math.floor(p.x);
                    const j = Math.floor(p.y);
                    
                    if (i < 1 || i >= N || j < 1 || j >= N) {
                        // Reset particle
                        p.x = Math.random() * N;
                        p.y = Math.random() * N;
                        p.life = 1;
                        continue;
                    }
                    
                    const s = p.x - i;
                    const t = p.y - j;
                    
                    const u00 = this.u[this.IX(i, j)];
                    const u10 = this.u[this.IX(i + 1, j)];
                    const u01 = this.u[this.IX(i, j + 1)];
                    const u11 = this.u[this.IX(i + 1, j + 1)];
                    
                    const v00 = this.v[this.IX(i, j)];
                    const v10 = this.v[this.IX(i + 1, j)];
                    const v01 = this.v[this.IX(i, j + 1)];
                    const v11 = this.v[this.IX(i + 1, j + 1)];
                    
                    const u = (1 - s) * (1 - t) * u00 + s * (1 - t) * u10 + (1 - s) * t * u01 + s * t * u11;
                    const v = (1 - s) * (1 - t) * v00 + s * (1 - t) * v10 + (1 - s) * t * v01 + s * t * v11;
                    
                    p.x += u * this.dt * 5;
                    p.y += v * this.dt * 5;
                    
                    p.life -= 0.002;
                    
                    if (p.life <= 0 || p.x < 0 || p.x > N || p.y < 0 || p.y > N) {
                        p.x = Math.random() * N;
                        p.y = Math.random() * N;
                        p.life = 1;
                    }
                }
            }
            
            step() {
                // Diffuse velocity
                this.u_prev.set(this.u);
                this.v_prev.set(this.v);
                
                this.diffuse(1, this.u, this.u_prev, this.visc, this.diffusionIterations);
                this.diffuse(2, this.v, this.v_prev, this.visc, this.diffusionIterations);
                
                this.project();
                
                // Advect velocity
                this.u_prev.set(this.u);
                this.v_prev.set(this.v);
                
                this.advect(1, this.u, this.u_prev, this.u_prev, this.v_prev);
                this.advect(2, this.v, this.v_prev, this.u_prev, this.v_prev);
                
                this.project();
                
                // Compute derived quantities
                this.computeVelocityGradientTensor();
                
                // Advect particles
                this.advectParticles();
            }
        }
        
        // Fluid Renderer
        class FluidRenderer {
            constructor(canvas, fluid) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.fluid = fluid;
                this.mode = 'velocity';
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }
            
            resize() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
            }
            
            render() {
                const cellSize = this.canvas.width / this.fluid.N;
                
                switch (this.mode) {
                    case 'velocity':
                        this.renderVelocityField(cellSize);
                        break;
                    case 'pressure':
                        this.renderPressure(cellSize);
                        break;
                    case 'vorticity':
                        this.renderVorticity(cellSize);
                        break;
                    case 'divergence':
                        this.renderDivergence(cellSize);
                        break;
                    case 'strain':
                        this.renderStrainRate(cellSize);
                        break;
                    case 'rotation':
                        this.renderRotationRate(cellSize);
                        break;
                    case 'decomposition':
                        this.renderTensorDecomposition(cellSize);
                        break;
                    case 'particles':
                        this.renderParticles();
                        break;
                }
            }
            
            renderVelocityField(cellSize) {
                const N = this.fluid.N;
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                let maxVel = 0;
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const u = this.fluid.u[this.fluid.IX(i, j)];
                        const v = this.fluid.v[this.fluid.IX(i, j)];
                        const vel = Math.sqrt(u*u + v*v);
                        if (vel > maxVel) maxVel = vel;
                    }
                }
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const u = this.fluid.u[this.fluid.IX(i, j)];
                        const v = this.fluid.v[this.fluid.IX(i, j)];
                        const vel = Math.sqrt(u*u + v*v);
                        
                        const intensity = Math.min(1, vel / (maxVel * 0.5 || 1));
                        
                        // Color based on direction and magnitude
                        const angle = Math.atan2(v, u);
                        const hue = (angle + Math.PI) / (2 * Math.PI) * 360;
                        
                        const rgb = this.hslToRgb(hue / 360, 1, intensity * 0.5);
                        
                        for (let dy = 0; dy < cellSize; dy++) {
                            for (let dx = 0; dx < cellSize; dx++) {
                                const px = Math.floor((i-1) * cellSize + dx);
                                const py = Math.floor((j-1) * cellSize + dy);
                                const idx = (py * this.canvas.width + px) * 4;
                                
                                data[idx] = rgb[0];
                                data[idx + 1] = rgb[1];
                                data[idx + 2] = rgb[2];
                                data[idx + 3] = 255;
                            }
                        }
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
                this.drawLegend('velocity');
            }
            
            renderPressure(cellSize) {
                const N = this.fluid.N;
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                let minP = Infinity, maxP = -Infinity;
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const p = this.fluid.pressure[this.fluid.IX(i, j)];
                        if (p < minP) minP = p;
                        if (p > maxP) maxP = p;
                    }
                }
                
                const range = maxP - minP || 1;
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const p = this.fluid.pressure[this.fluid.IX(i, j)];
                        const norm = (p - minP) / range;
                        
                        const r = Math.floor(norm * 255);
                        const b = Math.floor((1 - norm) * 255);
                        
                        for (let dy = 0; dy < cellSize; dy++) {
                            for (let dx = 0; dx < cellSize; dx++) {
                                const px = Math.floor((i-1) * cellSize + dx);
                                const py = Math.floor((j-1) * cellSize + dy);
                                const idx = (py * this.canvas.width + px) * 4;
                                
                                data[idx] = r;
                                data[idx + 1] = 0;
                                data[idx + 2] = b;
                                data[idx + 3] = 255;
                            }
                        }
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
                this.drawLegend('pressure');
            }
            
            renderVorticity(cellSize) {
                const N = this.fluid.N;
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                let maxVort = 0;
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const vort = Math.abs(this.fluid.vorticity[this.fluid.IX(i, j)]);
                        if (vort > maxVort) maxVort = vort;
                    }
                }
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const vort = this.fluid.vorticity[this.fluid.IX(i, j)];
                        const norm = Math.abs(vort) / (maxVort || 1);
                        
                        let r, g, b;
                        if (vort > 0) {
                            // Positive vorticity (counterclockwise) - cyan
                            r = 0;
                            g = Math.floor(norm * 255);
                            b = Math.floor(norm * 255);
                        } else {
                            // Negative vorticity (clockwise) - magenta
                            r = Math.floor(norm * 255);
                            g = 0;
                            b = Math.floor(norm * 255);
                        }
                        
                        for (let dy = 0; dy < cellSize; dy++) {
                            for (let dx = 0; dx < cellSize; dx++) {
                                const px = Math.floor((i-1) * cellSize + dx);
                                const py = Math.floor((j-1) * cellSize + dy);
                                const idx = (py * this.canvas.width + px) * 4;
                                
                                data[idx] = r;
                                data[idx + 1] = g;
                                data[idx + 2] = b;
                                data[idx + 3] = 255;
                            }
                        }
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
                this.drawLegend('vorticity');
            }
            
            renderDivergence(cellSize) {
                const N = this.fluid.N;
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                let maxDiv = 0;
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const div = Math.abs(this.fluid.divergence[this.fluid.IX(i, j)]);
                        if (div > maxDiv) maxDiv = div;
                    }
                }
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const div = this.fluid.divergence[this.fluid.IX(i, j)];
                        const norm = Math.abs(div) / (maxDiv || 0.001);
                        
                        const intensity = Math.floor(norm * 255);
                        
                        for (let dy = 0; dy < cellSize; dy++) {
                            for (let dx = 0; dx < cellSize; dx++) {
                                const px = Math.floor((i-1) * cellSize + dx);
                                const py = Math.floor((j-1) * cellSize + dy);
                                const idx = (py * this.canvas.width + px) * 4;
                                
                                data[idx] = intensity;
                                data[idx + 1] = intensity;
                                data[idx + 2] = intensity;
                                data[idx + 3] = 255;
                            }
                        }
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
                this.drawLegend('divergence');
            }
            
            renderParticles() {
                this.ctx.fillStyle = '#0a0e17';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                const N = this.fluid.N;
                const scale = this.canvas.width / N;
                
                for (let p of this.fluid.particles) {
                    const x = p.x * scale;
                    const y = p.y * scale;
                    
                    const alpha = p.life * 0.8;
                    this.ctx.fillStyle = `rgba(0, 217, 255, ${alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            renderStrainRate(cellSize) {
                const N = this.fluid.N;
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                // Find max strain rate
                let maxStrain = 0;
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const strain = this.fluid.strainMagnitude[this.fluid.IX(i, j)];
                        if (strain > maxStrain) maxStrain = strain;
                    }
                }
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const idx = this.fluid.IX(i, j);
                        const strain = this.fluid.strainMagnitude[idx];
                        const norm = Math.min(1, strain / (maxStrain * 0.5 || 1));
                        
                        // Color code by principal strain direction
                        const S_xx = this.fluid.S_xx[idx];
                        const S_yy = this.fluid.S_yy[idx];
                        const S_xy = this.fluid.S_xy[idx];
                        
                        // Principal angle: θ = 1/2 * atan2(2*S_xy, S_xx - S_yy)
                        const angle = 0.5 * Math.atan2(2 * S_xy, S_xx - S_yy);
                        const hue = ((angle + Math.PI) / (2 * Math.PI)) * 360;
                        
                        const rgb = this.hslToRgb(hue / 360, 1, norm * 0.5);
                        
                        for (let dy = 0; dy < cellSize; dy++) {
                            for (let dx = 0; dx < cellSize; dx++) {
                                const px = Math.floor((i-1) * cellSize + dx);
                                const py = Math.floor((j-1) * cellSize + dy);
                                const pidx = (py * this.canvas.width + px) * 4;
                                
                                data[pidx] = rgb[0];
                                data[pidx + 1] = rgb[1];
                                data[pidx + 2] = rgb[2];
                                data[pidx + 3] = 255;
                            }
                        }
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
                
                // Draw strain rate ellipses at selected points
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 1;
                
                const spacing = 16;
                for (let j = spacing; j <= N; j += spacing) {
                    for (let i = spacing; i <= N; i += spacing) {
                        const idx = this.fluid.IX(i, j);
                        const S_xx = this.fluid.S_xx[idx];
                        const S_yy = this.fluid.S_yy[idx];
                        const S_xy = this.fluid.S_xy[idx];
                        
                        // Eigenvalues of strain rate tensor
                        const trace = S_xx + S_yy;
                        const det = S_xx * S_yy - S_xy * S_xy;
                        const discriminant = trace * trace - 4 * det;
                        if (discriminant < 0) continue;
                        
                        const lambda1 = 0.5 * (trace + Math.sqrt(discriminant));
                        const lambda2 = 0.5 * (trace - Math.sqrt(discriminant));
                        
                        const angle = 0.5 * Math.atan2(2 * S_xy, S_xx - S_yy);
                        
                        const cx = (i - 0.5) * cellSize;
                        const cy = (j - 0.5) * cellSize;
                        const scale = cellSize * 0.4;
                        
                        this.ctx.save();
                        this.ctx.translate(cx, cy);
                        this.ctx.rotate(angle);
                        this.ctx.beginPath();
                        this.ctx.ellipse(0, 0, Math.abs(lambda1) * scale * 5, Math.abs(lambda2) * scale * 5, 0, 0, 2 * Math.PI);
                        this.ctx.stroke();
                        this.ctx.restore();
                    }
                }
                this.drawLegend('strain');
            }
            
            renderRotationRate(cellSize) {
                const N = this.fluid.N;
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                // Find max rotation rate
                let maxRot = 0;
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const rot = Math.abs(this.fluid.Omega_xy[this.fluid.IX(i, j)]);
                        if (rot > maxRot) maxRot = rot;
                    }
                }
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const idx = this.fluid.IX(i, j);
                        const rot = this.fluid.Omega_xy[idx];
                        const norm = Math.min(1, Math.abs(rot) / (maxRot * 0.5 || 1));
                        
                        let r, g, b;
                        if (rot > 0) {
                            // Positive (counterclockwise) - cyan/blue
                            r = 0;
                            g = Math.floor(norm * 217);
                            b = Math.floor(norm * 255);
                        } else {
                            // Negative (clockwise) - magenta/red
                            r = Math.floor(norm * 255);
                            g = 0;
                            b = Math.floor(norm * 110);
                        }
                        
                        for (let dy = 0; dy < cellSize; dy++) {
                            for (let dx = 0; dx < cellSize; dx++) {
                                const px = Math.floor((i-1) * cellSize + dx);
                                const py = Math.floor((j-1) * cellSize + dy);
                                const pidx = (py * this.canvas.width + px) * 4;
                                
                                data[pidx] = r;
                                data[pidx + 1] = g;
                                data[pidx + 2] = b;
                                data[pidx + 3] = 255;
                            }
                        }
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
                this.drawLegend('rotation');
            }
            
            renderTensorDecomposition(cellSize) {
                const N = this.fluid.N;
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                // Find max values for normalization
                let maxStrain = 0, maxRot = 0;
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const idx = this.fluid.IX(i, j);
                        const strain = this.fluid.strainMagnitude[idx];
                        const rot = Math.abs(this.fluid.Omega_xy[idx]);
                        if (strain > maxStrain) maxStrain = strain;
                        if (rot > maxRot) maxRot = rot;
                    }
                }
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const idx = this.fluid.IX(i, j);
                        const strain = this.fluid.strainMagnitude[idx];
                        const rot = this.fluid.Omega_xy[idx];
                        
                        // Normalize
                        const strainNorm = Math.min(1, strain / (maxStrain * 0.5 || 1));
                        const rotNorm = Math.min(1, Math.abs(rot) / (maxRot * 0.5 || 1));
                        
                        // RGB encoding:
                        // R = clockwise rotation (negative Omega_xy)
                        // G = strain magnitude
                        // B = counterclockwise rotation (positive Omega_xy)
                        const r = rot < 0 ? Math.floor(rotNorm * 255) : 0;
                        const g = Math.floor(strainNorm * 217);
                        const b = rot > 0 ? Math.floor(rotNorm * 255) : 0;
                        
                        for (let dy = 0; dy < cellSize; dy++) {
                            for (let dx = 0; dx < cellSize; dx++) {
                                const px = Math.floor((i-1) * cellSize + dx);
                                const py = Math.floor((j-1) * cellSize + dy);
                                const pidx = (py * this.canvas.width + px) * 4;
                                
                                data[pidx] = r;
                                data[pidx + 1] = g;
                                data[pidx + 2] = b;
                                data[pidx + 3] = 255;
                            }
                        }
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
                this.drawLegend('decomposition');
            }
            
            drawLegend(mode) {
                const legendWidth = 200;
                const legendHeight = 20;
                const legendX = this.canvas.width - legendWidth - 20;
                const legendY = 20;
                const padding = 10;
                
                // Calculate box height based on mode
                let boxHeight = legendHeight + 50;
                if (mode === 'decomposition') {
                    boxHeight = 100; // Taller for RGB decomposition
                }
                
                // Background
                this.ctx.fillStyle = 'rgba(10, 14, 23, 0.9)';
                this.ctx.fillRect(legendX - padding, legendY - padding, 
                                 legendWidth + 2*padding, boxHeight);
                
                // Border
                this.ctx.strokeStyle = 'rgba(0, 217, 255, 0.5)';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(legendX - padding, legendY - padding, 
                                   legendWidth + 2*padding, boxHeight);
                
                if (mode === 'velocity' || mode === 'speed') {
                    // Velocity gradient (blue to red)
                    const gradient = this.ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
                    gradient.addColorStop(0, 'rgb(0, 0, 139)');
                    gradient.addColorStop(0.33, 'rgb(0, 191, 255)');
                    gradient.addColorStop(0.67, 'rgb(255, 165, 0)');
                    gradient.addColorStop(1, 'rgb(220, 20, 60)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(legendX, legendY, legendWidth, legendHeight);
                    
                    // Labels
                    this.ctx.font = '10px JetBrains Mono';
                    this.ctx.fillStyle = 'rgba(224, 230, 237, 0.9)';
                    this.ctx.fillText('0', legendX, legendY + legendHeight + 15);
                    this.ctx.fillText('Max', legendX + legendWidth - 25, legendY + legendHeight + 15);
                    this.ctx.fillText('Velocity |u|', legendX + 55, legendY + legendHeight + 32);
                    
                } else if (mode === 'vorticity') {
                    // Vorticity gradient
                    const gradient = this.ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
                    gradient.addColorStop(0, 'rgb(255, 0, 255)');
                    gradient.addColorStop(0.5, 'rgb(0, 0, 0)');
                    gradient.addColorStop(1, 'rgb(0, 255, 255)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(legendX, legendY, legendWidth, legendHeight);
                    
                    // Labels
                    this.ctx.font = '10px JetBrains Mono';
                    this.ctx.fillStyle = 'rgba(224, 230, 237, 0.9)';
                    this.ctx.fillText('CW', legendX, legendY + legendHeight + 15);
                    this.ctx.fillText('0', legendX + legendWidth/2 - 5, legendY + legendHeight + 15);
                    this.ctx.fillText('CCW', legendX + legendWidth - 25, legendY + legendHeight + 15);
                    this.ctx.fillText('Vorticity ω = ∇×u', legendX + 35, legendY + legendHeight + 32);
                    
                } else if (mode === 'divergence') {
                    // Divergence gradient
                    const gradient = this.ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
                    gradient.addColorStop(0, 'rgb(0, 0, 0)');
                    gradient.addColorStop(1, 'rgb(255, 255, 255)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(legendX, legendY, legendWidth, legendHeight);
                    
                    // Labels
                    this.ctx.font = '10px JetBrains Mono';
                    this.ctx.fillStyle = 'rgba(224, 230, 237, 0.9)';
                    this.ctx.fillText('0', legendX, legendY + legendHeight + 15);
                    this.ctx.fillText('Max |∇·u|', legendX + legendWidth - 55, legendY + legendHeight + 15);
                    this.ctx.fillText('Divergence ∇·u', legendX + 40, legendY + legendHeight + 32);
                    
                } else if (mode === 'pressure') {
                    // Pressure gradient
                    const gradient = this.ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
                    gradient.addColorStop(0, 'rgb(0, 0, 255)');
                    gradient.addColorStop(1, 'rgb(255, 0, 0)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(legendX, legendY, legendWidth, legendHeight);
                    
                    // Labels
                    this.ctx.font = '10px JetBrains Mono';
                    this.ctx.fillStyle = 'rgba(224, 230, 237, 0.9)';
                    this.ctx.fillText('Low', legendX, legendY + legendHeight + 15);
                    this.ctx.fillText('High', legendX + legendWidth - 25, legendY + legendHeight + 15);
                    this.ctx.fillText('Pressure p', legendX + 60, legendY + legendHeight + 32);
                    
                } else if (mode === 'strain') {
                    // Strain gradient - HSL color wheel
                    const gradient = this.ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
                    for (let i = 0; i <= 10; i++) {
                        const hue = (i / 10) * 360;
                        const rgb = this.hslToRgb(hue / 360, 1, 0.5);
                        gradient.addColorStop(i / 10, `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`);
                    }
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(legendX, legendY, legendWidth, legendHeight);
                    
                    // Labels
                    this.ctx.font = '10px JetBrains Mono';
                    this.ctx.fillStyle = 'rgba(224, 230, 237, 0.9)';
                    this.ctx.fillText('0°', legendX, legendY + legendHeight + 15);
                    this.ctx.fillText('180°', legendX + legendWidth - 25, legendY + legendHeight + 15);
                    this.ctx.fillText('Strain S = ½(∇u+∇uᵀ)', legendX + 20, legendY + legendHeight + 32);
                    
                } else if (mode === 'rotation') {
                    // Rotation gradient
                    const gradient = this.ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
                    gradient.addColorStop(0, 'rgb(255, 0, 110)');
                    gradient.addColorStop(0.5, 'rgb(0, 0, 0)');
                    gradient.addColorStop(1, 'rgb(0, 217, 255)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(legendX, legendY, legendWidth, legendHeight);
                    
                    // Labels
                    this.ctx.font = '10px JetBrains Mono';
                    this.ctx.fillStyle = 'rgba(224, 230, 237, 0.9)';
                    this.ctx.fillText('CW', legendX, legendY + legendHeight + 15);
                    this.ctx.fillText('CCW', legendX + legendWidth - 25, legendY + legendHeight + 15);
                    this.ctx.fillText('Rotation Ω = ½(∇u−∇uᵀ)', legendX + 15, legendY + legendHeight + 32);
                    
                } else if (mode === 'decomposition') {
                    // RGB decomposition legend - show three separate bars
                    const barHeight = 14;
                    const spacing = 4;
                    
                    // Red bar (clockwise rotation)
                    const redGradient = this.ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
                    redGradient.addColorStop(0, 'rgb(0, 0, 0)');
                    redGradient.addColorStop(1, 'rgb(255, 0, 0)');
                    this.ctx.fillStyle = redGradient;
                    this.ctx.fillRect(legendX, legendY, legendWidth, barHeight);
                    
                    // Green bar (strain)
                    const greenGradient = this.ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
                    greenGradient.addColorStop(0, 'rgb(0, 0, 0)');
                    greenGradient.addColorStop(1, 'rgb(0, 217, 0)');
                    this.ctx.fillStyle = greenGradient;
                    this.ctx.fillRect(legendX, legendY + barHeight + spacing, legendWidth, barHeight);
                    
                    // Blue bar (counterclockwise)
                    const blueGradient = this.ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
                    blueGradient.addColorStop(0, 'rgb(0, 0, 0)');
                    blueGradient.addColorStop(1, 'rgb(0, 100, 255)');
                    this.ctx.fillStyle = blueGradient;
                    this.ctx.fillRect(legendX, legendY + 2*(barHeight + spacing), legendWidth, barHeight);
                    
                    // Labels
                    this.ctx.font = '9px JetBrains Mono';
                    this.ctx.fillStyle = 'rgba(224, 230, 237, 0.9)';
                    this.ctx.fillText('R: Clockwise Ω', legendX, legendY + 3*barHeight + 2*spacing + 12);
                    this.ctx.fillText('G: Strain |S|', legendX, legendY + 3*barHeight + 2*spacing + 24);
                    this.ctx.fillText('B: Counter-CW Ω', legendX, legendY + 3*barHeight + 2*spacing + 36);
                }
            }
            
            hslToRgb(h, s, l) {
                let r, g, b;
                
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }
        }
        
        // Application
        const canvas = document.getElementById('fluidCanvas');
        const fluid = new FluidSimulation(256);
        const renderer = new FluidRenderer(canvas, fluid);
        
        let isPaused = false;
        let isMouseDown = false;
        let lastX = 0, lastY = 0;
        let forceMagnitude = 50;
        let clickStartTime = 0;
        let clickStartX = 0, clickStartY = 0;
        
        // Mouse interaction
        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            const rect = canvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
            clickStartX = lastX;
            clickStartY = lastY;
            clickStartTime = Date.now();
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isMouseDown) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const dx = x - lastX;
            const dy = y - lastY;
            
            // Only apply force if we've moved significantly (not a click)
            if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
                fluid.addForce(x, y, dx * forceMagnitude * 0.1, dy * forceMagnitude * 0.1, canvas.width, canvas.height);
            }
            
            lastX = x;
            lastY = y;
        });
        
        canvas.addEventListener('mouseup', (e) => {
            if (isMouseDown) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Check if this was a click (short duration, little movement)
                const duration = Date.now() - clickStartTime;
                const distance = Math.sqrt(Math.pow(x - clickStartX, 2) + Math.pow(y - clickStartY, 2));
                
                if (duration < 200 && distance < 10) {
                    // This was a click - add vortex pair at location
                    fluid.addVortexAt(x, y, canvas.width, canvas.height);
                }
            }
            isMouseDown = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
        });
        
        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            lastX = touch.clientX - rect.left;
            lastY = touch.clientY - rect.top;
            clickStartX = lastX;
            clickStartY = lastY;
            clickStartTime = Date.now();
            isMouseDown = true;
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isMouseDown) return;
            
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            const dx = x - lastX;
            const dy = y - lastY;
            
            if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
                fluid.addForce(x, y, dx * forceMagnitude * 0.1, dy * forceMagnitude * 0.1, canvas.width, canvas.height);
            }
            
            lastX = x;
            lastY = y;
        });
        
        canvas.addEventListener('touchend', (e) => {
            if (isMouseDown) {
                const duration = Date.now() - clickStartTime;
                
                if (duration < 200) {
                    // This was a tap - add vortex pair at location
                    fluid.addVortexAt(clickStartX, clickStartY, canvas.width, canvas.height);
                }
            }
            isMouseDown = false;
        });
        
        // Controls
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                renderer.mode = btn.dataset.mode;
            });
        });
        
        document.getElementById('viscosity').addEventListener('input', (e) => {
            fluid.visc = parseFloat(e.target.value);
            document.getElementById('viscosity-value').textContent = fluid.visc.toFixed(5);
        });
        
        document.getElementById('timestep').addEventListener('input', (e) => {
            fluid.dt = parseFloat(e.target.value);
            document.getElementById('dt-value').textContent = fluid.dt.toFixed(2);
        });
        
        document.getElementById('force').addEventListener('input', (e) => {
            forceMagnitude = parseFloat(e.target.value);
            document.getElementById('force-value').textContent = forceMagnitude.toFixed(0);
        });
        
        document.getElementById('iterations').addEventListener('input', (e) => {
            fluid.pressureIterations = parseInt(e.target.value);
            document.getElementById('iterations-value').textContent = fluid.pressureIterations;
        });
        
        document.getElementById('diffusion-iter').addEventListener('input', (e) => {
            fluid.diffusionIterations = parseInt(e.target.value);
            document.getElementById('diffusion-value').textContent = fluid.diffusionIterations;
        });
        
        document.getElementById('reset-btn').addEventListener('click', () => {
            fluid.reset();
        });
        
        document.getElementById('add-vortex-btn').addEventListener('click', () => {
            fluid.addVortexPair();
        });
        
        document.getElementById('pause-btn').addEventListener('click', (e) => {
            isPaused = !isPaused;
            e.target.textContent = isPaused ? 'Resume' : 'Pause';
        });
        
        // Stats
        let frameCount = 0;
        let lastTime = performance.now();
        
        function updateStats() {
            const N = fluid.N;
            let maxVel = 0;
            let maxVort = 0;
            let maxStrain = 0;
            let maxRot = 0;
            
            for (let j = 1; j <= N; j++) {
                for (let i = 1; i <= N; i++) {
                    const u = fluid.u[fluid.IX(i, j)];
                    const v = fluid.v[fluid.IX(i, j)];
                    const vel = Math.sqrt(u*u + v*v);
                    if (vel > maxVel) maxVel = vel;
                    
                    const vort = Math.abs(fluid.vorticity[fluid.IX(i, j)]);
                    if (vort > maxVort) maxVort = vort;
                    
                    const strain = fluid.strainMagnitude[fluid.IX(i, j)];
                    if (strain > maxStrain) maxStrain = strain;
                    
                    const rot = fluid.rotationMagnitude[fluid.IX(i, j)];
                    if (rot > maxRot) maxRot = rot;
                }
            }
            
            document.getElementById('max-velocity').textContent = maxVel.toFixed(2);
            document.getElementById('max-vorticity').textContent = maxVort.toFixed(2);
            document.getElementById('max-strain').textContent = maxStrain.toFixed(2);
            document.getElementById('max-rotation').textContent = maxRot.toFixed(2);
            
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = currentTime;
            }
        }
        
        // Animation loop
        function animate() {
            if (!isPaused) {
                fluid.step();
                updateStats();
            }
            renderer.render();
            requestAnimationFrame(animate);
        }
        
        animate();
    </script>
</body>
</html>
