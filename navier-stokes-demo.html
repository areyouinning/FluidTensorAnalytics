<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Tensor Dynamics | Navier-Stokes Simulation</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600&family=IBM+Plex+Sans:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0e17;
            --bg-secondary: #141923;
            --bg-tertiary: #1a2332;
            --accent-primary: #00d9ff;
            --accent-secondary: #ff006e;
            --accent-tertiary: #8b5cf6;
            --text-primary: #e0e6ed;
            --text-secondary: #8b95a5;
            --border: rgba(0, 217, 255, 0.2);
        }

        body {
            font-family: 'IBM Plex Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            position: relative;
        }

        /* Atmospheric background grid */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 217, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 217, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
            z-index: 0;
        }

        .container {
            position: relative;
            z-index: 1;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            padding: 2rem 3rem;
            border-bottom: 1px solid var(--border);
            background: rgba(10, 14, 23, 0.8);
            backdrop-filter: blur(10px);
        }

        h1 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 300;
            font-family: 'JetBrains Mono', monospace;
        }

        .main-content {
            flex: 1;
            display: flex;
            gap: 2rem;
            padding: 2rem 3rem;
            overflow: hidden;
        }

        .simulation-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .canvas-container {
            position: relative;
            flex: 1;
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-secondary);
            box-shadow: 0 8px 32px rgba(0, 217, 255, 0.1);
        }

        canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
            image-rendering: pixelated;
        }

        .visualization-modes {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .mode-btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            padding: 0.5rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-weight: 400;
        }

        .mode-btn:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
            transform: translateY(-2px);
        }

        .mode-btn.active {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
            font-weight: 600;
        }

        .mode-btn[title] {
            position: relative;
        }

        .mode-btn[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 14, 23, 0.95);
            color: var(--text-primary);
            padding: 0.75rem 1rem;
            border-radius: 6px;
            border: 1px solid var(--accent-primary);
            font-size: 0.75rem;
            font-weight: 400;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 217, 255, 0.3);
        }

        .mode-btn[title]:hover::before {
            content: '';
            position: absolute;
            bottom: calc(100% + 4px);
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: var(--accent-primary);
            z-index: 1000;
            pointer-events: none;
        }

        .controls-panel {
            width: 320px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 217, 255, 0.1);
        }

        .control-section {
            margin-bottom: 1.5rem;
        }

        .control-section h3 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--accent-primary);
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .control-group {
            margin-bottom: 1rem;
        }

        .control-group label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(0, 217, 255, 0.5);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px rgba(0, 217, 255, 0.5);
        }

        .value-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--accent-primary);
            float: right;
        }

        .btn {
            font-family: 'JetBrains Mono', monospace;
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
            margin-bottom: 0.5rem;
        }

        .btn:hover {
            border-color: var(--accent-primary);
            background: rgba(0, 217, 255, 0.1);
            transform: translateY(-2px);
        }

        .stats {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-secondary);
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            line-height: 1.6;
        }

        .stats-value {
            color: var(--accent-primary);
            font-weight: 600;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .container > * {
            animation: fadeIn 0.6s ease-out backwards;
        }

        header {
            animation-delay: 0.1s;
        }

        .simulation-panel {
            animation-delay: 0.2s;
        }

        .controls-panel {
            animation-delay: 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Fluid Tensor Dynamics</h1>
            <div class="subtitle">Real-time Navier-Stokes Solution • GPU-Accelerated</div>
        </header>

        <div class="main-content">
            <div class="simulation-panel">
                <div class="visualization-modes">
                    <button class="mode-btn active" data-mode="velocity" title="Shows velocity magnitude and direction using color. Hue indicates flow direction, brightness shows speed.">Velocity Field</button>
                    <button class="mode-btn" data-mode="pressure" title="Pressure field from solving ∇²p = -∇·(u·∇u). Enforces incompressibility via Helmholtz-Hodge decomposition.">Pressure</button>
                    <button class="mode-btn" data-mode="vorticity" title="Vorticity ω = ∇×u measures local fluid rotation. Blue = clockwise, red = counterclockwise. Key for identifying vortex structures.">Vorticity (∇×u)</button>
                    <button class="mode-btn" data-mode="divergence" title="Divergence ∇·u measures expansion/compression. Should be ~0 for incompressible flow (mass conservation).">Divergence (∇·u)</button>
                    <button class="mode-btn" data-mode="strain" title="Strain rate tensor S_ij = ½(∂u_i/∂x_j + ∂u_j/∂x_i) shows pure deformation without rotation. Color indicates principal strain direction.">Strain Rate Tensor</button>
                    <button class="mode-btn" data-mode="rotation" title="Rotation rate tensor Ω_ij = ½(∂u_i/∂x_j - ∂u_j/∂x_i) isolates pure rotation without deformation.">Rotation Rate Tensor</button>
                    <button class="mode-btn" data-mode="decomposition" title="RGB decomposition: R = clockwise rotation, G = strain, B = counterclockwise rotation. Shows how velocity gradient splits into rotation + deformation.">Tensor Decomposition</button>
                    <button class="mode-btn" data-mode="particles" title="Lagrangian particle tracers advected by the velocity field. Visualizes flow pathlines and mixing.">Particle Tracers</button>
                </div>
                <div class="canvas-container">
                    <canvas id="fluidCanvas"></canvas>
                </div>
            </div>

            <div class="controls-panel">
                <div class="control-section">
                    <h3>Physical Parameters</h3>
                    <div class="control-group">
                        <label>
                            Viscosity (ν)
                            <span class="value-display" id="viscosity-value">0.0001</span>
                        </label>
                        <input type="range" id="viscosity" min="0" max="0.001" step="0.00001" value="0.0001">
                    </div>
                    <div class="control-group">
                        <label>
                            Time Step (Δt)
                            <span class="value-display" id="dt-value">0.1</span>
                        </label>
                        <input type="range" id="timestep" min="0.01" max="0.5" step="0.01" value="0.1">
                    </div>
                    <div class="control-group">
                        <label>
                            Force Magnitude
                            <span class="value-display" id="force-value">50</span>
                        </label>
                        <input type="range" id="force" min="1" max="200" step="1" value="50">
                    </div>
                </div>

                <div class="control-section">
                    <h3>Solver Settings</h3>
                    <div class="control-group">
                        <label>
                            Pressure Iterations
                            <span class="value-display" id="iterations-value">20</span>
                        </label>
                        <input type="range" id="iterations" min="5" max="50" step="1" value="20">
                    </div>
                    <div class="control-group">
                        <label>
                            Diffusion Iterations
                            <span class="value-display" id="diffusion-value">20</span>
                        </label>
                        <input type="range" id="diffusion-iter" min="5" max="50" step="1" value="20">
                    </div>
                </div>

                <div class="control-section">
                    <h3>Actions</h3>
                    <button class="btn" id="reset-btn">Reset Simulation</button>
                    <button class="btn" id="add-vortex-btn">Add Vortex Pair</button>
                    <button class="btn" id="pause-btn">Pause</button>
                </div>

                <div class="control-section">
                    <h3>Statistics</h3>
                    <div class="stats">
                        <div>Grid: <span class="stats-value" id="grid-size">128×128</span></div>
                        <div>FPS: <span class="stats-value" id="fps">60</span></div>
                        <div>Max |u|: <span class="stats-value" id="max-velocity">0.0</span></div>
                        <div>Max |ω|: <span class="stats-value" id="max-vorticity">0.0</span></div>
                        <div>Max |S|: <span class="stats-value" id="max-strain">0.0</span></div>
                        <div>Max |Ω|: <span class="stats-value" id="max-rotation">0.0</span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Navier-Stokes Fluid Simulation
        // Using Jos Stam's "Stable Fluids" method
        
        class FluidSimulation {
            constructor(N) {
                this.N = N;
                this.size = (N + 2) * (N + 2);
                
                // Velocity fields
                this.u = new Float32Array(this.size);
                this.v = new Float32Array(this.size);
                this.u_prev = new Float32Array(this.size);
                this.v_prev = new Float32Array(this.size);
                
                // Scalar fields
                this.density = new Float32Array(this.size);
                this.density_prev = new Float32Array(this.size);
                
                // Derived fields
                this.pressure = new Float32Array(this.size);
                this.vorticity = new Float32Array(this.size);
                this.divergence = new Float32Array(this.size);
                
                // Velocity gradient tensor components
                this.du_dx = new Float32Array(this.size);
                this.du_dy = new Float32Array(this.size);
                this.dv_dx = new Float32Array(this.size);
                this.dv_dy = new Float32Array(this.size);
                
                // Strain rate tensor (symmetric part): S_ij = 1/2 * (∂u_i/∂x_j + ∂u_j/∂x_i)
                this.S_xx = new Float32Array(this.size);
                this.S_xy = new Float32Array(this.size);
                this.S_yy = new Float32Array(this.size);
                
                // Rotation rate tensor (antisymmetric part): Ω_ij = 1/2 * (∂u_i/∂x_j - ∂u_j/∂x_i)
                this.Omega_xy = new Float32Array(this.size);
                
                // Strain rate magnitude and principal values
                this.strainMagnitude = new Float32Array(this.size);
                this.rotationMagnitude = new Float32Array(this.size);
                
                // Parameters
                this.visc = 0.0001;
                this.dt = 0.1;
                this.diff = 0.0;
                
                // Solver iterations
                this.pressureIterations = 20;
                this.diffusionIterations = 20;
                
                // Particles for tracer visualization
                this.particles = [];
                for (let i = 0; i < 2000; i++) {
                    this.particles.push({
                        x: Math.random() * N,
                        y: Math.random() * N,
                        life: Math.random()
                    });
                }
            }
            
            IX(i, j) {
                return i + (this.N + 2) * j;
            }
            
            // Set boundary conditions
            set_bnd(b, x) {
                const N = this.N;
                
                // Vertical edges
                for (let i = 1; i <= N; i++) {
                    x[this.IX(0, i)] = b === 1 ? -x[this.IX(1, i)] : x[this.IX(1, i)];
                    x[this.IX(N+1, i)] = b === 1 ? -x[this.IX(N, i)] : x[this.IX(N, i)];
                }
                
                // Horizontal edges
                for (let j = 1; j <= N; j++) {
                    x[this.IX(j, 0)] = b === 2 ? -x[this.IX(j, 1)] : x[this.IX(j, 1)];
                    x[this.IX(j, N+1)] = b === 2 ? -x[this.IX(j, N)] : x[this.IX(j, N)];
                }
                
                // Corners
                x[this.IX(0, 0)] = 0.5 * (x[this.IX(1, 0)] + x[this.IX(0, 1)]);
                x[this.IX(0, N+1)] = 0.5 * (x[this.IX(1, N+1)] + x[this.IX(0, N)]);
                x[this.IX(N+1, 0)] = 0.5 * (x[this.IX(N, 0)] + x[this.IX(N+1, 1)]);
                x[this.IX(N+1, N+1)] = 0.5 * (x[this.IX(N, N+1)] + x[this.IX(N+1, N)]);
            }
            
            // Linear solver for implicit diffusion and pressure
            lin_solve(b, x, x0, a, c) {
                const N = this.N;
                const iterations = b === 0 ? this.pressureIterations : this.diffusionIterations;
                
                for (let k = 0; k < iterations; k++) {
                    for (let j = 1; j <= N; j++) {
                        for (let i = 1; i <= N; i++) {
                            x[this.IX(i, j)] = (x0[this.IX(i, j)] + a * (
                                x[this.IX(i-1, j)] + x[this.IX(i+1, j)] +
                                x[this.IX(i, j-1)] + x[this.IX(i, j+1)]
                            )) / c;
                        }
                    }
                    this.set_bnd(b, x);
                }
            }
            
            // Diffusion step
            diffuse(b, x, x0, diff) {
                const a = this.dt * diff * this.N * this.N;
                this.lin_solve(b, x, x0, a, 1 + 4 * a);
            }
            
            // Advection step (semi-Lagrangian)
            advect(b, d, d0, u, v) {
                const N = this.N;
                const dt0 = this.dt * N;
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        let x = i - dt0 * u[this.IX(i, j)];
                        let y = j - dt0 * v[this.IX(i, j)];
                        
                        if (x < 0.5) x = 0.5;
                        if (x > N + 0.5) x = N + 0.5;
                        let i0 = Math.floor(x);
                        let i1 = i0 + 1;
                        
                        if (y < 0.5) y = 0.5;
                        if (y > N + 0.5) y = N + 0.5;
                        let j0 = Math.floor(y);
                        let j1 = j0 + 1;
                        
                        let s1 = x - i0;
                        let s0 = 1 - s1;
                        let t1 = y - j0;
                        let t0 = 1 - t1;
                        
                        d[this.IX(i, j)] = 
                            s0 * (t0 * d0[this.IX(i0, j0)] + t1 * d0[this.IX(i0, j1)]) +
                            s1 * (t0 * d0[this.IX(i1, j0)] + t1 * d0[this.IX(i1, j1)]);
                    }
                }
                this.set_bnd(b, d);
            }
            
            // Project to make velocity field divergence-free
            project(u, v, p, div) {
                const N = this.N;
                const h = 1.0 / N;
                
                // Compute divergence
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        div[this.IX(i, j)] = -0.5 * h * (
                            u[this.IX(i+1, j)] - u[this.IX(i-1, j)] +
                            v[this.IX(i, j+1)] - v[this.IX(i, j-1)]
                        );
                        p[this.IX(i, j)] = 0;
                    }
                }
                this.set_bnd(0, div);
                this.set_bnd(0, p);
                
                // Solve for pressure
                this.lin_solve(0, p, div, 1, 4);
                
                // Subtract pressure gradient
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        u[this.IX(i, j)] -= 0.5 * (p[this.IX(i+1, j)] - p[this.IX(i-1, j)]) / h;
                        v[this.IX(i, j)] -= 0.5 * (p[this.IX(i, j+1)] - p[this.IX(i, j-1)]) / h;
                    }
                }
                this.set_bnd(1, u);
                this.set_bnd(2, v);
            }
            
            // Velocity step (full N-S)
            vel_step() {
                // Add forces (already in u_prev, v_prev)
                
                // Diffusion
                this.diffuse(1, this.u_prev, this.u, this.visc);
                this.diffuse(2, this.v_prev, this.v, this.visc);
                
                // Project
                this.project(this.u_prev, this.v_prev, this.u, this.v);
                
                // Advection
                this.advect(1, this.u, this.u_prev, this.u_prev, this.v_prev);
                this.advect(2, this.v, this.v_prev, this.u_prev, this.v_prev);
                
                // Project again
                this.project(this.u, this.v, this.u_prev, this.v_prev);
                
                // Clear force arrays
                this.u_prev.fill(0);
                this.v_prev.fill(0);
            }
            
            // Compute vorticity
            computeVorticity() {
                const N = this.N;
                const h = 1.0 / N;
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const dv_dx = (this.v[this.IX(i+1, j)] - this.v[this.IX(i-1, j)]) / (2 * h);
                        const du_dy = (this.u[this.IX(i, j+1)] - this.u[this.IX(i, j-1)]) / (2 * h);
                        this.vorticity[this.IX(i, j)] = dv_dx - du_dy;
                    }
                }
            }
            
            // Compute divergence
            computeDivergence() {
                const N = this.N;
                const h = 1.0 / N;
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        this.divergence[this.IX(i, j)] = 0.5 * h * (
                            this.u[this.IX(i+1, j)] - this.u[this.IX(i-1, j)] +
                            this.v[this.IX(i, j+1)] - this.v[this.IX(i, j-1)]
                        );
                    }
                }
            }
            
            // Compute velocity gradient tensor
            computeVelocityGradient() {
                const N = this.N;
                const h = 1.0 / N;
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        // ∂u/∂x
                        this.du_dx[this.IX(i, j)] = (this.u[this.IX(i+1, j)] - this.u[this.IX(i-1, j)]) / (2 * h);
                        // ∂u/∂y
                        this.du_dy[this.IX(i, j)] = (this.u[this.IX(i, j+1)] - this.u[this.IX(i, j-1)]) / (2 * h);
                        // ∂v/∂x
                        this.dv_dx[this.IX(i, j)] = (this.v[this.IX(i+1, j)] - this.v[this.IX(i-1, j)]) / (2 * h);
                        // ∂v/∂y
                        this.dv_dy[this.IX(i, j)] = (this.v[this.IX(i, j+1)] - this.v[this.IX(i, j-1)]) / (2 * h);
                    }
                }
            }
            
            // Compute strain rate tensor (symmetric part of velocity gradient)
            // S_ij = 1/2 * (∂u_i/∂x_j + ∂u_j/∂x_i)
            computeStrainRate() {
                const N = this.N;
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const idx = this.IX(i, j);
                        
                        // S_xx = ∂u/∂x
                        this.S_xx[idx] = this.du_dx[idx];
                        
                        // S_yy = ∂v/∂y
                        this.S_yy[idx] = this.dv_dy[idx];
                        
                        // S_xy = S_yx = 1/2 * (∂u/∂y + ∂v/∂x)
                        this.S_xy[idx] = 0.5 * (this.du_dy[idx] + this.dv_dx[idx]);
                        
                        // Strain rate magnitude: sqrt(2 * S_ij * S_ij)
                        // For 2D: sqrt(2 * (S_xx² + S_yy² + 2*S_xy²))
                        this.strainMagnitude[idx] = Math.sqrt(2 * (
                            this.S_xx[idx] * this.S_xx[idx] +
                            this.S_yy[idx] * this.S_yy[idx] +
                            2 * this.S_xy[idx] * this.S_xy[idx]
                        ));
                    }
                }
            }
            
            // Compute rotation rate tensor (antisymmetric part of velocity gradient)
            // Ω_ij = 1/2 * (∂u_i/∂x_j - ∂u_j/∂x_i)
            computeRotationRate() {
                const N = this.N;
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const idx = this.IX(i, j);
                        
                        // Ω_xy = -Ω_yx = 1/2 * (∂u/∂y - ∂v/∂x)
                        // Note: This is equivalent to -1/2 * vorticity
                        this.Omega_xy[idx] = 0.5 * (this.du_dy[idx] - this.dv_dx[idx]);
                        
                        // Rotation magnitude
                        this.rotationMagnitude[idx] = Math.abs(this.Omega_xy[idx]);
                    }
                }
            }
            
            // Compute all tensor decomposition fields
            computeTensorDecomposition() {
                this.computeVelocityGradient();
                this.computeStrainRate();
                this.computeRotationRate();
            }
            
            // Update particle tracers
            updateParticles() {
                const N = this.N;
                
                for (let p of this.particles) {
                    const i = Math.floor(p.x);
                    const j = Math.floor(p.y);
                    
                    if (i >= 1 && i <= N && j >= 1 && j <= N) {
                        const u = this.u[this.IX(i, j)];
                        const v = this.v[this.IX(i, j)];
                        
                        p.x += u * this.dt * 5;
                        p.y += v * this.dt * 5;
                    }
                    
                    // Wrap around
                    if (p.x < 0) p.x += N;
                    if (p.x > N) p.x -= N;
                    if (p.y < 0) p.y += N;
                    if (p.y > N) p.y -= N;
                    
                    // Age particles
                    p.life -= 0.002;
                    if (p.life <= 0) {
                        p.x = Math.random() * N;
                        p.y = Math.random() * N;
                        p.life = 1.0;
                    }
                }
            }
            
            // Add force at position
            addForce(x, y, fx, fy) {
                const N = this.N;
                const i = Math.floor(x * N / 600);
                const j = Math.floor(y * N / 600);
                
                if (i >= 1 && i <= N && j >= 1 && j <= N) {
                    this.u_prev[this.IX(i, j)] += fx;
                    this.v_prev[this.IX(i, j)] += fy;
                }
            }
            
            // Add vortex pair
            addVortexPair() {
                const N = this.N;
                const cx1 = N * 0.3;
                const cy = N * 0.5;
                const cx2 = N * 0.7;
                const radius = N * 0.1;
                const strength = 50;
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        // Left vortex (counterclockwise)
                        const dx1 = i - cx1;
                        const dy1 = j - cy;
                        const r1 = Math.sqrt(dx1*dx1 + dy1*dy1);
                        if (r1 < radius && r1 > 0) {
                            const theta1 = Math.atan2(dy1, dx1);
                            this.u[this.IX(i, j)] += -strength * Math.sin(theta1) * (1 - r1/radius);
                            this.v[this.IX(i, j)] += strength * Math.cos(theta1) * (1 - r1/radius);
                        }
                        
                        // Right vortex (clockwise)
                        const dx2 = i - cx2;
                        const dy2 = j - cy;
                        const r2 = Math.sqrt(dx2*dx2 + dy2*dy2);
                        if (r2 < radius && r2 > 0) {
                            const theta2 = Math.atan2(dy2, dx2);
                            this.u[this.IX(i, j)] += strength * Math.sin(theta2) * (1 - r2/radius);
                            this.v[this.IX(i, j)] += -strength * Math.cos(theta2) * (1 - r2/radius);
                        }
                    }
                }
            }
            
            reset() {
                this.u.fill(0);
                this.v.fill(0);
                this.u_prev.fill(0);
                this.v_prev.fill(0);
                this.density.fill(0);
                this.density_prev.fill(0);
                this.pressure.fill(0);
                
                // Reset particles
                for (let p of this.particles) {
                    p.x = Math.random() * this.N;
                    p.y = Math.random() * this.N;
                    p.life = Math.random();
                }
            }
            
            step() {
                this.vel_step();
                this.computeVorticity();
                this.computeDivergence();
                this.computeTensorDecomposition();
                this.updateParticles();
            }
        }
        
        // Renderer
        class FluidRenderer {
            constructor(canvas, fluid) {
                this.canvas = canvas;
                this.fluid = fluid;
                this.ctx = canvas.getContext('2d');
                this.mode = 'velocity';
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = 600;
                this.canvas.height = 600;
            }
            
            render() {
                const N = this.fluid.N;
                const cellSize = this.canvas.width / N;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                switch(this.mode) {
                    case 'velocity':
                        this.renderVelocityField(cellSize);
                        break;
                    case 'pressure':
                        this.renderPressure(cellSize);
                        break;
                    case 'vorticity':
                        this.renderVorticity(cellSize);
                        break;
                    case 'divergence':
                        this.renderDivergence(cellSize);
                        break;
                    case 'strain':
                        this.renderStrainRate(cellSize);
                        break;
                    case 'rotation':
                        this.renderRotationRate(cellSize);
                        break;
                    case 'decomposition':
                        this.renderTensorDecomposition(cellSize);
                        break;
                    case 'particles':
                        this.renderParticles();
                        break;
                }
            }
            
            renderVelocityField(cellSize) {
                const N = this.fluid.N;
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                let maxVel = 0;
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const u = this.fluid.u[this.fluid.IX(i, j)];
                        const v = this.fluid.v[this.fluid.IX(i, j)];
                        const vel = Math.sqrt(u*u + v*v);
                        if (vel > maxVel) maxVel = vel;
                    }
                }
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const u = this.fluid.u[this.fluid.IX(i, j)];
                        const v = this.fluid.v[this.fluid.IX(i, j)];
                        const vel = Math.sqrt(u*u + v*v);
                        
                        const intensity = Math.min(1, vel / (maxVel * 0.5));
                        
                        // Color based on direction and magnitude
                        const angle = Math.atan2(v, u);
                        const hue = (angle + Math.PI) / (2 * Math.PI) * 360;
                        
                        const rgb = this.hslToRgb(hue / 360, 1, intensity * 0.5);
                        
                        for (let dy = 0; dy < cellSize; dy++) {
                            for (let dx = 0; dx < cellSize; dx++) {
                                const px = Math.floor((i-1) * cellSize + dx);
                                const py = Math.floor((j-1) * cellSize + dy);
                                const idx = (py * this.canvas.width + px) * 4;
                                
                                data[idx] = rgb[0];
                                data[idx + 1] = rgb[1];
                                data[idx + 2] = rgb[2];
                                data[idx + 3] = 255;
                            }
                        }
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
                this.drawLegend('velocity');
            }
            
            renderPressure(cellSize) {
                const N = this.fluid.N;
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                let minP = Infinity, maxP = -Infinity;
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const p = this.fluid.pressure[this.fluid.IX(i, j)];
                        if (p < minP) minP = p;
                        if (p > maxP) maxP = p;
                    }
                }
                
                const range = maxP - minP || 1;
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const p = this.fluid.pressure[this.fluid.IX(i, j)];
                        const norm = (p - minP) / range;
                        
                        const r = Math.floor(norm * 255);
                        const b = Math.floor((1 - norm) * 255);
                        
                        for (let dy = 0; dy < cellSize; dy++) {
                            for (let dx = 0; dx < cellSize; dx++) {
                                const px = Math.floor((i-1) * cellSize + dx);
                                const py = Math.floor((j-1) * cellSize + dy);
                                const idx = (py * this.canvas.width + px) * 4;
                                
                                data[idx] = r;
                                data[idx + 1] = 0;
                                data[idx + 2] = b;
                                data[idx + 3] = 255;
                            }
                        }
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
                this.drawLegend('pressure');
            }
            
            renderVorticity(cellSize) {
                const N = this.fluid.N;
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                let maxVort = 0;
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const vort = Math.abs(this.fluid.vorticity[this.fluid.IX(i, j)]);
                        if (vort > maxVort) maxVort = vort;
                    }
                }
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const vort = this.fluid.vorticity[this.fluid.IX(i, j)];
                        const norm = Math.abs(vort) / (maxVort || 1);
                        
                        let r, g, b;
                        if (vort > 0) {
                            // Positive vorticity (counterclockwise) - cyan
                            r = 0;
                            g = Math.floor(norm * 255);
                            b = Math.floor(norm * 255);
                        } else {
                            // Negative vorticity (clockwise) - magenta
                            r = Math.floor(norm * 255);
                            g = 0;
                            b = Math.floor(norm * 255);
                        }
                        
                        for (let dy = 0; dy < cellSize; dy++) {
                            for (let dx = 0; dx < cellSize; dx++) {
                                const px = Math.floor((i-1) * cellSize + dx);
                                const py = Math.floor((j-1) * cellSize + dy);
                                const idx = (py * this.canvas.width + px) * 4;
                                
                                data[idx] = r;
                                data[idx + 1] = g;
                                data[idx + 2] = b;
                                data[idx + 3] = 255;
                            }
                        }
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
                this.drawLegend('vorticity');
            }
            
            renderDivergence(cellSize) {
                const N = this.fluid.N;
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                let maxDiv = 0;
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const div = Math.abs(this.fluid.divergence[this.fluid.IX(i, j)]);
                        if (div > maxDiv) maxDiv = div;
                    }
                }
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const div = this.fluid.divergence[this.fluid.IX(i, j)];
                        const norm = Math.abs(div) / (maxDiv || 0.001);
                        
                        const intensity = Math.floor(norm * 255);
                        
                        for (let dy = 0; dy < cellSize; dy++) {
                            for (let dx = 0; dx < cellSize; dx++) {
                                const px = Math.floor((i-1) * cellSize + dx);
                                const py = Math.floor((j-1) * cellSize + dy);
                                const idx = (py * this.canvas.width + px) * 4;
                                
                                data[idx] = intensity;
                                data[idx + 1] = intensity;
                                data[idx + 2] = intensity;
                                data[idx + 3] = 255;
                            }
                        }
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
                this.drawLegend('divergence');
            }
            
            renderParticles() {
                this.ctx.fillStyle = '#0a0e17';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                const N = this.fluid.N;
                const scale = this.canvas.width / N;
                
                for (let p of this.fluid.particles) {
                    const x = p.x * scale;
                    const y = p.y * scale;
                    
                    const alpha = p.life * 0.8;
                    this.ctx.fillStyle = `rgba(0, 217, 255, ${alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            renderStrainRate(cellSize) {
                const N = this.fluid.N;
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                // Find max strain rate
                let maxStrain = 0;
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const strain = this.fluid.strainMagnitude[this.fluid.IX(i, j)];
                        if (strain > maxStrain) maxStrain = strain;
                    }
                }
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const idx = this.fluid.IX(i, j);
                        const strain = this.fluid.strainMagnitude[idx];
                        const norm = Math.min(1, strain / (maxStrain * 0.5 || 1));
                        
                        // Color code by principal strain direction
                        const S_xx = this.fluid.S_xx[idx];
                        const S_yy = this.fluid.S_yy[idx];
                        const S_xy = this.fluid.S_xy[idx];
                        
                        // Principal angle: θ = 1/2 * atan2(2*S_xy, S_xx - S_yy)
                        const angle = 0.5 * Math.atan2(2 * S_xy, S_xx - S_yy);
                        const hue = ((angle + Math.PI) / (2 * Math.PI)) * 360;
                        
                        const rgb = this.hslToRgb(hue / 360, 1, norm * 0.5);
                        
                        for (let dy = 0; dy < cellSize; dy++) {
                            for (let dx = 0; dx < cellSize; dx++) {
                                const px = Math.floor((i-1) * cellSize + dx);
                                const py = Math.floor((j-1) * cellSize + dy);
                                const pidx = (py * this.canvas.width + px) * 4;
                                
                                data[pidx] = rgb[0];
                                data[pidx + 1] = rgb[1];
                                data[pidx + 2] = rgb[2];
                                data[pidx + 3] = 255;
                            }
                        }
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
                
                // Draw strain rate ellipses at selected points
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 1;
                
                const spacing = 16;
                for (let j = spacing; j <= N; j += spacing) {
                    for (let i = spacing; i <= N; i += spacing) {
                        const idx = this.fluid.IX(i, j);
                        const S_xx = this.fluid.S_xx[idx];
                        const S_yy = this.fluid.S_yy[idx];
                        const S_xy = this.fluid.S_xy[idx];
                        
                        // Eigenvalues of strain rate tensor
                        const trace = S_xx + S_yy;
                        const det = S_xx * S_yy - S_xy * S_xy;
                        const lambda1 = 0.5 * (trace + Math.sqrt(trace * trace - 4 * det));
                        const lambda2 = 0.5 * (trace - Math.sqrt(trace * trace - 4 * det));
                        
                        const angle = 0.5 * Math.atan2(2 * S_xy, S_xx - S_yy);
                        
                        const cx = (i - 0.5) * cellSize;
                        const cy = (j - 0.5) * cellSize;
                        const scale = cellSize * 0.4;
                        
                        this.ctx.save();
                        this.ctx.translate(cx, cy);
                        this.ctx.rotate(angle);
                        this.ctx.beginPath();
                        this.ctx.ellipse(0, 0, Math.abs(lambda1) * scale * 5, Math.abs(lambda2) * scale * 5, 0, 0, 2 * Math.PI);
                        this.ctx.stroke();
                        this.ctx.restore();
                    }
                }
                this.drawLegend('strain');
            }
            
            renderRotationRate(cellSize) {
                const N = this.fluid.N;
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                let maxRot = 0;
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const rot = this.fluid.rotationMagnitude[this.fluid.IX(i, j)];
                        if (rot > maxRot) maxRot = rot;
                    }
                }
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const idx = this.fluid.IX(i, j);
                        const omega = this.fluid.Omega_xy[idx];
                        const norm = Math.abs(omega) / (maxRot || 1);
                        
                        let r, g, b;
                        if (omega > 0) {
                            // Positive rotation (counterclockwise) - cyan/blue
                            r = 0;
                            g = Math.floor(norm * 217);
                            b = Math.floor(norm * 255);
                        } else {
                            // Negative rotation (clockwise) - magenta/red
                            r = Math.floor(norm * 255);
                            g = 0;
                            b = Math.floor(norm * 110);
                        }
                        
                        for (let dy = 0; dy < cellSize; dy++) {
                            for (let dx = 0; dx < cellSize; dx++) {
                                const px = Math.floor((i-1) * cellSize + dx);
                                const py = Math.floor((j-1) * cellSize + dy);
                                const pidx = (py * this.canvas.width + px) * 4;
                                
                                data[pidx] = r;
                                data[pidx + 1] = g;
                                data[pidx + 2] = b;
                                data[pidx + 3] = 255;
                            }
                        }
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
                this.drawLegend('rotation');
            }
            
            renderTensorDecomposition(cellSize) {
                const N = this.fluid.N;
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                // Find max values
                let maxStrain = 0, maxRot = 0;
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const strain = this.fluid.strainMagnitude[this.fluid.IX(i, j)];
                        const rot = this.fluid.rotationMagnitude[this.fluid.IX(i, j)];
                        if (strain > maxStrain) maxStrain = strain;
                        if (rot > maxRot) maxRot = rot;
                    }
                }
                
                // Visualize strain (green) vs rotation (magenta/cyan)
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const idx = this.fluid.IX(i, j);
                        const strain = this.fluid.strainMagnitude[idx] / (maxStrain || 1);
                        const omega = this.fluid.Omega_xy[idx];
                        const rot = Math.abs(omega) / (maxRot || 1);
                        
                        // RGB decomposition:
                        // R: Clockwise rotation (negative omega)
                        // G: Strain (deformation)
                        // B: Counterclockwise rotation (positive omega)
                        
                        const r = omega < 0 ? Math.floor(rot * 255) : 0;
                        const g = Math.floor(strain * 217);
                        const b = omega > 0 ? Math.floor(rot * 255) : 0;
                        
                        for (let dy = 0; dy < cellSize; dy++) {
                            for (let dx = 0; dx < cellSize; dx++) {
                                const px = Math.floor((i-1) * cellSize + dx);
                                const py = Math.floor((j-1) * cellSize + dy);
                                const pidx = (py * this.canvas.width + px) * 4;
                                
                                data[pidx] = r;
                                data[pidx + 1] = g;
                                data[pidx + 2] = b;
                                data[pidx + 3] = 255;
                            }
                        }
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
                this.drawLegend('vorticity-decomp');
            }
            
            drawLegend(mode) {
                const legendWidth = 200;
                const legendHeight = 20;
                const legendX = this.canvas.width - legendWidth - 20;
                const legendY = 20;
                const padding = 10;
                
                // Background
                this.ctx.fillStyle = 'rgba(10, 14, 23, 0.85)';
                this.ctx.fillRect(legendX - padding, legendY - padding, 
                                 legendWidth + 2*padding, legendHeight + 50);
                
                // Border
                this.ctx.strokeStyle = 'rgba(0, 217, 255, 0.3)';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(legendX - padding, legendY - padding, 
                                   legendWidth + 2*padding, legendHeight + 50);
                
                if (mode === 'velocity' || mode === 'speed') {
                    // Velocity gradient (blue to red)
                    const gradient = this.ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
                    gradient.addColorStop(0, 'rgb(0, 0, 139)');
                    gradient.addColorStop(0.33, 'rgb(0, 191, 255)');
                    gradient.addColorStop(0.67, 'rgb(255, 165, 0)');
                    gradient.addColorStop(1, 'rgb(220, 20, 60)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(legendX, legendY, legendWidth, legendHeight);
                    
                    // Labels
                    this.ctx.font = '10px JetBrains Mono';
                    this.ctx.fillStyle = 'rgba(224, 230, 237, 0.9)';
                    this.ctx.fillText('0', legendX, legendY + legendHeight + 15);
                    this.ctx.fillText('Max', legendX + legendWidth - 25, legendY + legendHeight + 15);
                    this.ctx.fillText(mode === 'velocity' ? 'Velocity Magnitude' : 'Speed', 
                                     legendX + 30, legendY + legendHeight + 30);
                    
                } else if (mode === 'vorticity') {
                    // Vorticity gradient (blue-white-red for neg-zero-pos)
                    const gradient = this.ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
                    gradient.addColorStop(0, 'rgb(0, 0, 255)');
                    gradient.addColorStop(0.5, 'rgb(255, 255, 255)');
                    gradient.addColorStop(1, 'rgb(255, 0, 0)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(legendX, legendY, legendWidth, legendHeight);
                    
                    // Labels
                    this.ctx.font = '10px JetBrains Mono';
                    this.ctx.fillStyle = 'rgba(224, 230, 237, 0.9)';
                    this.ctx.fillText('-ω', legendX, legendY + legendHeight + 15);
                    this.ctx.fillText('0', legendX + legendWidth/2 - 5, legendY + legendHeight + 15);
                    this.ctx.fillText('+ω', legendX + legendWidth - 15, legendY + legendHeight + 15);
                    this.ctx.fillText('Vorticity (curl)', legendX + 50, legendY + legendHeight + 30);
                    
                } else if (mode === 'divergence') {
                    // Divergence gradient
                    const gradient = this.ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
                    gradient.addColorStop(0, 'rgb(255, 0, 0)');
                    gradient.addColorStop(0.5, 'rgb(255, 255, 255)');
                    gradient.addColorStop(1, 'rgb(0, 0, 255)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(legendX, legendY, legendWidth, legendHeight);
                    
                    // Labels
                    this.ctx.font = '10px JetBrains Mono';
                    this.ctx.fillStyle = 'rgba(224, 230, 237, 0.9)';
                    this.ctx.fillText('Source', legendX, legendY + legendHeight + 15);
                    this.ctx.fillText('Sink', legendX + legendWidth - 25, legendY + legendHeight + 15);
                    this.ctx.fillText('Divergence (∇·u)', legendX + 45, legendY + legendHeight + 30);
                    
                } else if (mode === 'pressure') {
                    // Pressure gradient
                    const gradient = this.ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
                    gradient.addColorStop(0, 'rgb(0, 0, 139)');
                    gradient.addColorStop(0.5, 'rgb(127, 255, 0)');
                    gradient.addColorStop(1, 'rgb(255, 0, 0)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(legendX, legendY, legendWidth, legendHeight);
                    
                    // Labels
                    this.ctx.font = '10px JetBrains Mono';
                    this.ctx.fillStyle = 'rgba(224, 230, 237, 0.9)';
                    this.ctx.fillText('Low', legendX, legendY + legendHeight + 15);
                    this.ctx.fillText('High', legendX + legendWidth - 25, legendY + legendHeight + 15);
                    this.ctx.fillText('Pressure', legendX + 70, legendY + legendHeight + 30);
                    
                } else if (mode === 'strain') {
                    // Strain gradient
                    const gradient = this.ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
                    gradient.addColorStop(0, 'rgb(0, 0, 0)');
                    gradient.addColorStop(0.5, 'rgb(139, 0, 139)');
                    gradient.addColorStop(1, 'rgb(255, 0, 255)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(legendX, legendY, legendWidth, legendHeight);
                    
                    // Labels
                    this.ctx.font = '10px JetBrains Mono';
                    this.ctx.fillStyle = 'rgba(224, 230, 237, 0.9)';
                    this.ctx.fillText('0', legendX, legendY + legendHeight + 15);
                    this.ctx.fillText('Max', legendX + legendWidth - 25, legendY + legendHeight + 15);
                    this.ctx.fillText('Strain Rate', legendX + 60, legendY + legendHeight + 30);
                    
                } else if (mode === 'rotation') {
                    // Rotation gradient
                    const gradient = this.ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
                    gradient.addColorStop(0, 'rgb(0, 0, 0)');
                    gradient.addColorStop(0.5, 'rgb(0, 100, 0)');
                    gradient.addColorStop(1, 'rgb(0, 255, 0)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(legendX, legendY, legendWidth, legendHeight);
                    
                    // Labels
                    this.ctx.font = '10px JetBrains Mono';
                    this.ctx.fillStyle = 'rgba(224, 230, 237, 0.9)';
                    this.ctx.fillText('0', legendX, legendY + legendHeight + 15);
                    this.ctx.fillText('Max', legendX + legendWidth - 25, legendY + legendHeight + 15);
                    this.ctx.fillText('Rotation Rate', legendX + 55, legendY + legendHeight + 30);
                    
                } else if (mode === 'vorticity-decomp') {
                    // RGB decomposition legend - show three separate bars
                    const barHeight = 12;
                    const spacing = 3;
                    
                    // Red bar (clockwise)
                    const redGradient = this.ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
                    redGradient.addColorStop(0, 'rgb(0, 0, 0)');
                    redGradient.addColorStop(1, 'rgb(255, 0, 0)');
                    this.ctx.fillStyle = redGradient;
                    this.ctx.fillRect(legendX, legendY, legendWidth, barHeight);
                    
                    // Green bar (strain)
                    const greenGradient = this.ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
                    greenGradient.addColorStop(0, 'rgb(0, 0, 0)');
                    greenGradient.addColorStop(1, 'rgb(0, 217, 0)');
                    this.ctx.fillStyle = greenGradient;
                    this.ctx.fillRect(legendX, legendY + barHeight + spacing, legendWidth, barHeight);
                    
                    // Blue bar (counterclockwise)
                    const blueGradient = this.ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
                    blueGradient.addColorStop(0, 'rgb(0, 0, 0)');
                    blueGradient.addColorStop(1, 'rgb(0, 0, 255)');
                    this.ctx.fillStyle = blueGradient;
                    this.ctx.fillRect(legendX, legendY + 2*(barHeight + spacing), legendWidth, barHeight);
                    
                    // Labels
                    this.ctx.font = '9px JetBrains Mono';
                    this.ctx.fillStyle = 'rgba(224, 230, 237, 0.9)';
                    this.ctx.fillText('R: Clockwise', legendX, legendY + 3*barHeight + 2*spacing + 12);
                    this.ctx.fillText('G: Strain', legendX, legendY + 3*barHeight + 2*spacing + 23);
                    this.ctx.fillText('B: Counter-CW', legendX, legendY + 3*barHeight + 2*spacing + 34);
                }
            }
            
            hslToRgb(h, s, l) {
                let r, g, b;
                
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }
        }
        
        // Application
        const canvas = document.getElementById('fluidCanvas');
        const fluid = new FluidSimulation(256);
        const renderer = new FluidRenderer(canvas, fluid);
        
        let isPaused = false;
        let isMouseDown = false;
        let lastX = 0, lastY = 0;
        let forceMagnitude = 50;
        
        // Mouse interaction
        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            const rect = canvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isMouseDown) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const dx = x - lastX;
            const dy = y - lastY;
            
            fluid.addForce(x, y, dx * forceMagnitude * 0.1, dy * forceMagnitude * 0.1);
            
            lastX = x;
            lastY = y;
        });
        
        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
        });
        
        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            lastX = touch.clientX - rect.left;
            lastY = touch.clientY - rect.top;
            isMouseDown = true;
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isMouseDown) return;
            
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            const dx = x - lastX;
            const dy = y - lastY;
            
            fluid.addForce(x, y, dx * forceMagnitude * 0.1, dy * forceMagnitude * 0.1);
            
            lastX = x;
            lastY = y;
        });
        
        canvas.addEventListener('touchend', () => {
            isMouseDown = false;
        });
        
        // Controls
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                renderer.mode = btn.dataset.mode;
            });
        });
        
        document.getElementById('viscosity').addEventListener('input', (e) => {
            fluid.visc = parseFloat(e.target.value);
            document.getElementById('viscosity-value').textContent = fluid.visc.toFixed(5);
        });
        
        document.getElementById('timestep').addEventListener('input', (e) => {
            fluid.dt = parseFloat(e.target.value);
            document.getElementById('dt-value').textContent = fluid.dt.toFixed(2);
        });
        
        document.getElementById('force').addEventListener('input', (e) => {
            forceMagnitude = parseFloat(e.target.value);
            document.getElementById('force-value').textContent = forceMagnitude.toFixed(0);
        });
        
        document.getElementById('iterations').addEventListener('input', (e) => {
            fluid.pressureIterations = parseInt(e.target.value);
            document.getElementById('iterations-value').textContent = fluid.pressureIterations;
        });
        
        document.getElementById('diffusion-iter').addEventListener('input', (e) => {
            fluid.diffusionIterations = parseInt(e.target.value);
            document.getElementById('diffusion-value').textContent = fluid.diffusionIterations;
        });
        
        document.getElementById('reset-btn').addEventListener('click', () => {
            fluid.reset();
        });
        
        document.getElementById('add-vortex-btn').addEventListener('click', () => {
            fluid.addVortexPair();
        });
        
        document.getElementById('pause-btn').addEventListener('click', (e) => {
            isPaused = !isPaused;
            e.target.textContent = isPaused ? 'Resume' : 'Pause';
        });
        
        // Stats
        let frameCount = 0;
        let lastTime = performance.now();
        
        function updateStats() {
            const N = fluid.N;
            let maxVel = 0;
            let maxVort = 0;
            let maxStrain = 0;
            let maxRot = 0;
            
            for (let j = 1; j <= N; j++) {
                for (let i = 1; i <= N; i++) {
                    const u = fluid.u[fluid.IX(i, j)];
                    const v = fluid.v[fluid.IX(i, j)];
                    const vel = Math.sqrt(u*u + v*v);
                    if (vel > maxVel) maxVel = vel;
                    
                    const vort = Math.abs(fluid.vorticity[fluid.IX(i, j)]);
                    if (vort > maxVort) maxVort = vort;
                    
                    const strain = fluid.strainMagnitude[fluid.IX(i, j)];
                    if (strain > maxStrain) maxStrain = strain;
                    
                    const rot = fluid.rotationMagnitude[fluid.IX(i, j)];
                    if (rot > maxRot) maxRot = rot;
                }
            }
            
            document.getElementById('max-velocity').textContent = maxVel.toFixed(2);
            document.getElementById('max-vorticity').textContent = maxVort.toFixed(2);
            document.getElementById('max-strain').textContent = maxStrain.toFixed(2);
            document.getElementById('max-rotation').textContent = maxRot.toFixed(2);
            
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = currentTime;
            }
        }
        
        // Animation loop
        function animate() {
            if (!isPaused) {
                fluid.step();
                updateStats();
            }
            renderer.render();
            requestAnimationFrame(animate);
        }
        
        animate();
    </script>
</body>
</html>
