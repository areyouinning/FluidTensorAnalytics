<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimal Channel Networks | Drainage Basin Optimization</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600&family=IBM+Plex+Sans:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0e17;
            --bg-secondary: #141923;
            --bg-tertiary: #1a2332;
            --accent-primary: #00d9ff;
            --accent-secondary: #ff006e;
            --accent-tertiary: #8b5cf6;
            --accent-green: #10b981;
            --text-primary: #e0e6ed;
            --text-secondary: #8b95a5;
            --border: rgba(0, 217, 255, 0.2);
        }

        body {
            font-family: 'IBM Plex Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 217, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 217, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
            z-index: 0;
        }

        .container {
            position: relative;
            z-index: 1;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            padding: 2rem 3rem;
            border-bottom: 1px solid var(--border);
            background: rgba(10, 14, 23, 0.8);
            backdrop-filter: blur(10px);
        }

        h1 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 300;
            font-family: 'JetBrains Mono', monospace;
        }

        .main-content {
            flex: 1;
            display: flex;
            gap: 2rem;
            padding: 2rem 3rem;
            overflow: hidden;
        }

        .simulation-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .canvas-container {
            position: relative;
            flex: 1;
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-secondary);
            box-shadow: 0 8px 32px rgba(0, 217, 255, 0.1);
        }

        canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .visualization-modes {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .mode-btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            padding: 0.5rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-weight: 400;
        }

        .mode-btn:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
            transform: translateY(-2px);
        }

        .mode-btn.active {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
            font-weight: 600;
        }

        .controls-panel {
            width: 320px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 217, 255, 0.1);
        }

        .control-section {
            margin-bottom: 1.5rem;
        }

        .control-section h3 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--accent-primary);
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .control-group {
            margin-bottom: 1rem;
        }

        .control-group label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(0, 217, 255, 0.5);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px rgba(0, 217, 255, 0.5);
        }

        .value-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--accent-primary);
            float: right;
        }

        .btn {
            font-family: 'JetBrains Mono', monospace;
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
            margin-bottom: 0.5rem;
        }

        .btn:hover {
            border-color: var(--accent-primary);
            background: rgba(0, 217, 255, 0.1);
            transform: translateY(-2px);
        }

        .stats {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-secondary);
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            line-height: 1.6;
        }

        .stats-value {
            color: var(--accent-primary);
            font-weight: 600;
        }

        .info-box {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-secondary);
            padding: 1rem;
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 4px;
            line-height: 1.6;
            margin-bottom: 1rem;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .container > * {
            animation: fadeIn 0.6s ease-out backwards;
        }

        header {
            animation-delay: 0.1s;
        }

        .simulation-panel {
            animation-delay: 0.2s;
        }

        .controls-panel {
            animation-delay: 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Optimal Channel Networks</h1>
            <div class="subtitle">Hill Tunneling Optimization â€¢ Energy Minimization (E = Î£A^Î³L)</div>
        </header>

        <div class="main-content">
            <div class="simulation-panel">
                <div class="visualization-modes">
                    <button class="mode-btn active" data-mode="network">Channel Network</button>
                    <button class="mode-btn" data-mode="strahler">Strahler Order</button>
                    <button class="mode-btn" data-mode="elevation">Elevation Field</button>
                    <button class="mode-btn" data-mode="flow">Flow Accumulation</button>
                    <button class="mode-btn" data-mode="energy">Energy Dissipation</button>
                    <button class="mode-btn" data-mode="slope">Slope Field</button>
                </div>
                <div class="canvas-container">
                    <canvas id="networkCanvas"></canvas>
                </div>
                <div class="canvas-container" style="height: 200px;">
                    <canvas id="energyPlot"></canvas>
                </div>
            </div>

            <div class="controls-panel">
                <div class="info-box">
                    ðŸ’¡ Ten optimization algorithms: HTO, SA, Gradient, Adam, Tabu Search, VNS, GRASP, GA, Memetic, and Differential Evolution
                </div>

                <div class="control-section">
                    <h3>Optimization Algorithm</h3>
                    <button class="btn" id="hto-mode" style="background: rgba(0, 217, 255, 0.2); border-color: var(--accent-primary);">Hill Tunneling (HTO)</button>
                    <button class="btn" id="sa-mode">Simulated Annealing (SA)</button>
                    <button class="btn" id="gradient-mode">Greedy Gradient</button>
                    <button class="btn" id="adam-mode">Adam Optimizer</button>
                    <button class="btn" id="tabu-mode">Tabu Search</button>
                    <button class="btn" id="vns-mode">Variable Neighborhood</button>
                    <button class="btn" id="grasp-mode">GRASP</button>
                    <button class="btn" id="ga-mode">Genetic Algorithm</button>
                    <button class="btn" id="memetic-mode">Memetic Algorithm</button>
                    <button class="btn" id="de-mode">Differential Evolution</button>
                </div>

                <div class="control-section">
                    <h3>Network Parameters</h3>
                    <div class="stats">
                        <div>Grid Size: <span class="stats-value" id="grid-size-display">10Ã—10</span></div>
                        <div>Min Drainage: <span class="stats-value">1</span></div>
                        <div>Energy Exp (Î³): <span class="stats-value">1.0</span></div>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>Algorithm Parameters</h3>
                    <div id="hto-params">
                        <div class="control-group">
                            <label>
                                Î± (Max Changes)
                                <span class="value-display" id="alpha-value">30</span>
                            </label>
                            <input type="range" id="alpha" min="5" max="100" step="5" value="30">
                        </div>
                        <div class="control-group">
                            <label>
                                Î² (Phase 1 Failures)
                                <span class="value-display" id="beta-value">50</span>
                            </label>
                            <input type="range" id="beta" min="10" max="200" step="10" value="50">
                        </div>
                        <div class="control-group">
                            <label>
                                Î© (Phase 2 Failures)
                                <span class="value-display" id="omega-value">500</span>
                            </label>
                            <input type="range" id="omega" min="100" max="2000" step="100" value="500">
                        </div>
                    </div>
                    <div id="sa-params" style="display: none;">
                        <div class="control-group">
                            <label>
                                Initial Temperature
                                <span class="value-display" id="temp-value">50</span>
                            </label>
                            <input type="range" id="temp" min="10" max="200" step="10" value="50">
                        </div>
                        <div class="control-group">
                            <label>
                                Cooling Rate
                                <span class="value-display" id="cooling-value">0.95</span>
                            </label>
                            <input type="range" id="cooling" min="0.85" max="0.99" step="0.01" value="0.95">
                        </div>
                        <div class="control-group">
                            <label>
                                Iterations per Temp
                                <span class="value-display" id="iter-temp-value">100</span>
                            </label>
                            <input type="range" id="iter-temp" min="50" max="500" step="50" value="100">
                        </div>
                    </div>
                    <div id="gradient-params" style="display: none;">
                        <p style="color: #8b95a5; font-size: 11px;">No tunable parameters</p>
                    </div>
                    <div id="adam-params" style="display: none;">
                        <div class="control-group">
                            <label>Learning Rate (Î±): <span id="adam-lr-value">0.1</span></label>
                            <input type="range" id="adam-lr" min="0.01" max="1.0" step="0.01" value="0.1">
                        </div>
                        <div class="control-group">
                            <label>Beta1 (momentum): <span id="adam-beta1-value">0.9</span></label>
                            <input type="range" id="adam-beta1" min="0.5" max="0.99" step="0.01" value="0.9">
                        </div>
                        <div class="control-group">
                            <label>Beta2 (RMS): <span id="adam-beta2-value">0.999</span></label>
                            <input type="range" id="adam-beta2" min="0.9" max="0.9999" step="0.0001" value="0.999">
                        </div>
                        <div class="control-group">
                            <label>Epsilon: <span id="adam-eps-value">1e-8</span></label>
                            <input type="range" id="adam-eps" min="-10" max="-6" step="0.1" value="-8">
                        </div>
                    </div>
                    <div id="tabu-params" style="display: none;">
                        <div class="control-group">
                            <label>Tabu Tenure: <span id="tabu-tenure-value">10</span></label>
                            <input type="range" id="tabu-tenure" min="5" max="50" step="5" value="10">
                        </div>
                    </div>
                    <div id="vns-params" style="display: none;">
                        <div class="control-group">
                            <label>Max k (swaps): <span id="vns-maxk-value">5</span></label>
                            <input type="range" id="vns-maxk" min="1" max="15" step="1" value="5">
                        </div>
                    </div>
                    <div id="grasp-params" style="display: none;">
                        <div class="control-group">
                            <label>Alpha (greediness): <span id="grasp-alpha-value">0.3</span></label>
                            <input type="range" id="grasp-alpha" min="0.0" max="1.0" step="0.1" value="0.3">
                        </div>
                    </div>
                    <div id="ga-params" style="display: none;">
                        <div class="control-group">
                            <label>Population Size: <span id="ga-popsize-value">20</span></label>
                            <input type="range" id="ga-popsize" min="10" max="50" step="5" value="20">
                        </div>
                        <div class="control-group">
                            <label>Mutation Rate: <span id="ga-mutation-value">0.1</span></label>
                            <input type="range" id="ga-mutation" min="0.01" max="0.5" step="0.01" value="0.1">
                        </div>
                    </div>
                    <div id="memetic-params" style="display: none;">
                        <div class="control-group">
                            <label>Population Size: <span id="memetic-popsize-value">10</span></label>
                            <input type="range" id="memetic-popsize" min="5" max="30" step="5" value="10">
                        </div>
                        <div class="control-group">
                            <label>Local Search Depth: <span id="memetic-depth-value">10</span></label>
                            <input type="range" id="memetic-depth" min="5" max="50" step="5" value="10">
                        </div>
                    </div>
                    <div id="de-params" style="display: none;">
                        <div class="control-group">
                            <label>Population Size: <span id="de-popsize-value">15</span></label>
                            <input type="range" id="de-popsize" min="10" max="40" step="5" value="15">
                        </div>
                        <div class="control-group">
                            <label>F (scaling): <span id="de-f-value">0.8</span></label>
                            <input type="range" id="de-f" min="0.1" max="2.0" step="0.1" value="0.8">
                        </div>
                        <div class="control-group">
                            <label>CR (crossover): <span id="de-cr-value">0.7</span></label>
                            <input type="range" id="de-cr" min="0.0" max="1.0" step="0.1" value="0.7">
                        </div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Grid Size</h3>
                    <button class="btn" id="grid-10" style="background: rgba(0, 217, 255, 0.2); border-color: var(--accent-primary);">10Ã—10</button>
                    <button class="btn" id="grid-20">20Ã—20</button>
                </div>

                <div class="control-section">
                    <h3>Actions</h3>
                    <button class="btn" id="evolve-btn">Optimize Network (100 swaps)</button>
                    <button class="btn" id="reset-btn">Reset Network</button>
                    <button class="btn" id="auto-btn">Auto-Optimize</button>
                </div>

                <div class="control-section">
                    <h3>Network Metrics</h3>
                    <div class="stats">
                        <div>Total Length: <span class="stats-value" id="total-length">0</span></div>
                        <div>Channel Count: <span class="stats-value" id="channel-count">0</span></div>
                        <div>Bifurcation Ratio: <span class="stats-value" id="bifurcation">0.0</span></div>
                        <div>Total Energy: <span class="stats-value" id="total-energy">0.0</span></div>
                        <div>Max Flow: <span class="stats-value" id="max-flow">0</span></div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Algorithm Status</h3>
                    <div class="stats">
                        <div>Mode: <span class="stats-value" id="algo-mode">HTO</span></div>
                        <div>Status: <span class="stats-value" id="algo-status">Phase 1</span></div>
                        <div>Evaluations: <span class="stats-value" id="eval-count">0</span></div>
                        <div>Improvements: <span class="stats-value" id="success-count">0</span></div>
                        <div>Accept Rate: <span class="stats-value" id="accept-rate">0%</span></div>
                        <div id="success-lengths-row">Success Lengths: <span class="stats-value" id="success-lengths">0</span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Optimal Channel Network Simulation
        // Based on OCN theory (Rodriguez-Iturbe & Rinaldo)
        
        class ChannelNetwork {
            constructor(N) {
                this.N = N;
                this.size = N * N;
                
                // Network connectivity - each cell points to its downstream neighbor
                this.downstream = new Int32Array(this.size);
                
                // Flow accumulation (drainage area)
                this.flowAccum = new Float32Array(this.size);
                
                // Distance to outlet (network coordinate)
                this.distToOutlet = new Float32Array(this.size);
                
                // Energy dissipation
                this.energy = new Float32Array(this.size);
                
                // Track recently swapped links for visualization
                this.recentSwaps = new Set();
                
                // Optimization mode
                this.optimizationMode = 'hto'; // 'hto', 'sa', 'gradient', 'adam', 'tabu', 'vns', 'grasp', 'ga', 'memetic', 'de'
                
                // Adam optimizer parameters
                this.adamLearningRate = 0.1;
                this.adamBeta1 = 0.9;  // First moment decay
                this.adamBeta2 = 0.999; // Second moment decay
                this.adamEpsilon = 1e-8;
                this.adamM = new Map(); // First moment estimates (per cell)
                this.adamV = new Map(); // Second moment estimates (per cell)
                this.adamT = 0; // Time step
                
                // Tabu Search parameters
                this.tabuTenure = 10; // How long a move stays tabu
                this.tabuList = []; // List of recent moves
                
                // Variable Neighborhood Search parameters
                this.vnsMaxK = 5; // Maximum neighborhood size
                this.vnsCurrentK = 1; // Current neighborhood
                
                // GRASP parameters
                this.graspAlpha = 0.3; // Greediness (0=pure greedy, 1=pure random)
                
                // Genetic Algorithm parameters
                this.gaPopSize = 20;
                this.gaMutationRate = 0.1;
                this.gaPopulation = [];
                this.gaGeneration = 0;
                
                // Memetic Algorithm parameters
                this.memeticPopSize = 10;
                this.memeticLocalSearchDepth = 10;
                this.memeticPopulation = [];
                
                // Differential Evolution parameters
                this.dePopSize = 15;
                this.deF = 0.8; // Scaling factor
                this.deCR = 0.7; // Crossover probability
                this.dePopulation = [];
                
                // Hill Tunneling Optimization parameters (from thesis)
                this.alpha = 30; // Max changes before evaluation (tuned via meta-optimization)
                this.beta = 50;  // Max consecutive failures in phase 1
                this.omega = 500; // Max consecutive failures in phase 2 (10:1 ratio)
                
                this.phase = 1; // Start in uniform random phase
                this.successLengths = []; // List of successful change lengths
                
                // Simulated Annealing parameters (Johnson et al. 1989)
                this.temperature = 50; // Initial temperature
                this.initialTemperature = 50;
                this.saCoolingRate = 0.95; // Geometric cooling schedule
                this.saIterationsPerTemp = 100; // Changes before cooling
                this.saIterationsAtTemp = 0;
                
                // Shared parameters
                this.consecutiveFailures = 0;
                
                // Energy parameters
                this.gamma = 1.0;   // Energy exponent from thesis (was 0.5 in some OCN papers)
                this.minDrainageArea = 1;
                
                // Outlet
                this.outletX = 0; // Lower left corner
                this.outletY = N - 1;
                this.outletIdx = this.IX(this.outletX, this.outletY);
                
                // Stats
                this.totalEnergy = 0;
                this.evaluationCount = 0;
                this.improvementCount = 0;
                this.energyHistory = [];
                this.changesPerSuccess = [];
                
                this.buildInitialNetwork();
            }
            
            IX(i, j) {
                return i + this.N * j;
            }
            
            getCoords(idx) {
                return {
                    i: idx % this.N,
                    j: Math.floor(idx / this.N)
                };
            }
            
            buildInitialNetwork() {
                // Initialize: outlet points to itself, track which nodes are in the tree
                for (let idx = 0; idx < this.size; idx++) {
                    this.downstream[idx] = -1; // Unconnected
                }
                this.downstream[this.outletIdx] = this.outletIdx; // Outlet points to itself
                
                // Connect outlet to one random neighbor to start
                // A(3541,3482)=1 means 3482 flows into 3541
                const neighbors = this.getValidNeighbors(this.outletIdx);
                if (neighbors.length > 0) {
                    const firstNode = neighbors[Math.floor(Math.random() * neighbors.length)];
                    this.downstream[firstNode] = this.outletIdx;
                }
                
                // Track which nodes are already in the tree
                const inTree = new Set();
                inTree.add(this.outletIdx);
                for (let idx = 0; idx < this.size; idx++) {
                    if (this.downstream[idx] >= 0) {
                        inTree.add(idx);
                    }
                }
                
                // Build tree: repeatedly pick a random connected node and add an unconnected neighbor
                while (inTree.size < this.size) {
                    // Pick random node that's already in tree
                    const treeArray = Array.from(inTree);
                    const targetNode = treeArray[Math.floor(Math.random() * treeArray.length)];
                    
                    // Get valid neighbors
                    const neighbors = this.getValidNeighbors(targetNode);
                    
                    // Try random neighbor
                    if (neighbors.length > 0) {
                        const candidateNode = neighbors[Math.floor(Math.random() * neighbors.length)];
                        
                        // Check if candidate is valid:
                        // 1. Not already in tree (Check = Check + sum(sum(A(:,Next))))
                        // 2. Not the outlet
                        // 3. Not zero (invalid)
                        
                        if (!inTree.has(candidateNode) && 
                            candidateNode !== this.outletIdx && 
                            candidateNode >= 0) {
                            // Add to tree
                            this.downstream[candidateNode] = targetNode;
                            inTree.add(candidateNode);
                        }
                    }
                }
                
                // Additional randomization: 3600 random reconnections with loop checking
                // This is the "Additionally Randomize" section from Initializer.m
                for (let iter = 0; iter < 3600; iter++) {
                    // Pick random node (not outlet)
                    let node = Math.floor(Math.random() * this.size);
                    if (node === this.outletIdx) continue;
                    
                    const oldDown = this.downstream[node];
                    const neighbors = this.getValidNeighbors(node);
                    
                    if (neighbors.length > 0) {
                        const newDown = neighbors[Math.floor(Math.random() * neighbors.length)];
                        
                        // Check validity
                        if (newDown === oldDown || newDown === this.outletIdx) {
                            continue;
                        }
                        
                        // Try the change
                        this.downstream[node] = newDown;
                        
                        // Check for loop by walking downstream to outlet
                        let test = newDown;
                        let loopDetected = false;
                        const visited = new Set();
                        
                        while (test !== this.outletIdx && !visited.has(test)) {
                            visited.add(test);
                            
                            if (test === node) {
                                // Loop detected!
                                loopDetected = true;
                                break;
                            }
                            
                            test = this.downstream[test];
                            
                            if (test < 0) {
                                // Disconnected - shouldn't happen but safe to reject
                                loopDetected = true;
                                break;
                            }
                        }
                        
                        if (loopDetected) {
                            // Revert
                            this.downstream[node] = oldDown;
                        }
                        // Otherwise keep the change (Omega = 2, success)
                    }
                }
                
                this.computeFlowAccumulation();
                this.computeDistances();
                this.computeEnergy();
            }
            
            computeFlowAccumulation() {
                // Reset
                this.flowAccum.fill(1);
                
                // Process from furthest to nearest (reverse topological order)
                const sorted = this.topologicalSort();
                
                for (let i = sorted.length - 1; i >= 0; i--) {
                    const idx = sorted[i];
                    const down = this.downstream[idx];
                    
                    if (down !== idx) {
                        this.flowAccum[down] += this.flowAccum[idx];
                    }
                }
            }
            
            topologicalSort() {
                // BFS from outlet backwards to get processing order
                const visited = new Uint8Array(this.size);
                const queue = [this.outletIdx];
                const result = [];
                visited[this.outletIdx] = 1;
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    result.push(current);
                    
                    // Find all cells that flow into current
                    for (let idx = 0; idx < this.size; idx++) {
                        if (!visited[idx] && this.downstream[idx] === current) {
                            visited[idx] = 1;
                            queue.push(idx);
                        }
                    }
                }
                
                return result;
            }
            
            computeDistances() {
                // Network distance to outlet
                this.distToOutlet.fill(Infinity);
                this.distToOutlet[this.outletIdx] = 0;
                
                const sorted = this.topologicalSort();
                
                for (const idx of sorted) {
                    const down = this.downstream[idx];
                    if (down !== idx) {
                        const dist = this.getEuclideanDist(idx, down);
                        this.distToOutlet[idx] = this.distToOutlet[down] + dist;
                    }
                }
            }
            
            getEuclideanDist(idx1, idx2) {
                const c1 = this.getCoords(idx1);
                const c2 = this.getCoords(idx2);
                const dx = c1.i - c2.i;
                const dy = c1.j - c2.j;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            computeEnergy() {
                // Energy dissipation: E = sum_i (A_i^gamma * L_i)
                // where A_i is drainage area, L_i is link length
                // gamma typically 0.5 (from hydraulic geometry)
                
                this.totalEnergy = 0;
                
                for (let idx = 0; idx < this.size; idx++) {
                    const down = this.downstream[idx];
                    if (down !== idx) {
                        const length = this.getEuclideanDist(idx, down);
                        this.energy[idx] = Math.pow(this.flowAccum[idx], this.gamma) * length;
                        this.totalEnergy += this.energy[idx];
                    } else {
                        this.energy[idx] = 0;
                    }
                }
            }
            
            computeStrahlerOrder() {
                // Compute Strahler stream order for each node
                this.strahlerOrder = new Int32Array(this.size);
                this.strahlerOrder.fill(0);
                
                // First verify all nodes are connected by checking they can reach outlet
                const canReachOutlet = new Uint8Array(this.size);
                for (let idx = 0; idx < this.size; idx++) {
                    let current = idx;
                    const visited = new Set();
                    
                    while (current !== this.outletIdx && !visited.has(current)) {
                        visited.add(current);
                        current = this.downstream[current];
                        
                        if (current < 0 || current >= this.size) {
                            break; // Invalid
                        }
                    }
                    
                    if (current === this.outletIdx) {
                        canReachOutlet[idx] = 1;
                    }
                }
                
                // Process in topological order from outlet backwards
                const sorted = this.topologicalSort();
                
                // Process from headwaters to outlet (reverse of topological sort)
                for (let i = sorted.length - 1; i >= 0; i--) {
                    const idx = sorted[i];
                    
                    // Skip if not connected
                    if (!canReachOutlet[idx]) continue;
                    
                    // Find all tributaries (nodes that flow into this one)
                    const tributaries = [];
                    for (let j = 0; j < this.size; j++) {
                        if (canReachOutlet[j] && this.downstream[j] === idx && j !== idx) {
                            tributaries.push(j);
                        }
                    }
                    
                    if (tributaries.length === 0) {
                        // Headwater - order 1
                        this.strahlerOrder[idx] = 1;
                    } else if (tributaries.length === 1) {
                        // Single tributary - inherit order
                        this.strahlerOrder[idx] = Math.max(1, this.strahlerOrder[tributaries[0]]);
                    } else {
                        // Multiple tributaries - Strahler rules
                        const orders = tributaries.map(t => this.strahlerOrder[t]).filter(o => o > 0);
                        if (orders.length === 0) {
                            this.strahlerOrder[idx] = 1;
                        } else {
                            const maxOrder = Math.max(...orders);
                            const maxCount = orders.filter(o => o === maxOrder).length;
                            
                            if (maxCount >= 2) {
                                // Two or more streams of same order merge -> increment
                                this.strahlerOrder[idx] = maxOrder + 1;
                            } else {
                                // Only one stream of max order -> inherit
                                this.strahlerOrder[idx] = maxOrder;
                            }
                        }
                    }
                }
                
                return Math.max(...Array.from(this.strahlerOrder));
            }
            
            getValidNeighbors(idx) {
                // Get valid downstream neighbors (8-connected, excluding upstream)
                const { i, j } = this.getCoords(idx);
                const neighbors = [];
                
                for (let dj = -1; dj <= 1; dj++) {
                    for (let di = -1; di <= 1; di++) {
                        if (di === 0 && dj === 0) continue;
                        
                        const ni = i + di;
                        const nj = j + dj;
                        
                        if (ni >= 0 && ni < this.N && nj >= 0 && nj < this.N) {
                            const nidx = this.IX(ni, nj);
                            
                            // Check for diagonal crossing
                            // Diagonals can cross if two nodes use opposite diagonals in a 2x2 square
                            const isDiagonal = (di !== 0 && dj !== 0);
                            let wouldCross = false;
                            
                            if (isDiagonal) {
                                // Check if the perpendicular diagonal is already in use
                                // For diagonal (i,j) -> (i+di, j+dj), check (i+di, j) -> (i, j+dj)
                                const corner1 = this.IX(i + di, j);
                                const corner2 = this.IX(i, j + dj);
                                
                                if (corner1 >= 0 && corner1 < this.size && 
                                    corner2 >= 0 && corner2 < this.size) {
                                    // Would cross if corner1 flows to corner2 or vice versa
                                    if (this.downstream[corner1] === corner2 || 
                                        this.downstream[corner2] === corner1) {
                                        wouldCross = true;
                                    }
                                }
                            }
                            
                            if (!wouldCross && !this.wouldCreateLoop(idx, nidx)) {
                                neighbors.push(nidx);
                            }
                        }
                    }
                }
                
                return neighbors;
            }
            
            wouldCreateLoop(source, newTarget) {
                // Check if routing source to newTarget would create a loop
                // by walking downstream from newTarget
                let current = newTarget;
                const visited = new Set();
                
                while (current !== this.outletIdx && !visited.has(current)) {
                    visited.add(current);
                    current = this.downstream[current];
                    
                    if (current === source) {
                        return true; // Loop detected
                    }
                }
                
                return false;
            }
            
            makeRandomChange() {
                // Select a random cell (not outlet) and give it a new downstream neighbor
                let idx = Math.floor(Math.random() * this.size);
                while (idx === this.outletIdx) {
                    idx = Math.floor(Math.random() * this.size);
                }
                
                const neighbors = this.getValidNeighbors(idx);
                if (neighbors.length === 0) return null;
                
                const oldDown = this.downstream[idx];
                const newDown = neighbors[Math.floor(Math.random() * neighbors.length)];
                
                if (newDown !== oldDown) {
                    this.downstream[idx] = newDown;
                    return { idx, oldDown, newDown };
                }
                return null;
            }
            
            revertChanges(changes) {
                // Revert a series of changes
                for (const change of changes) {
                    this.downstream[change.idx] = change.oldDown;
                }
            }
            
            hillTunnelingStep() {
                // Hill Tunneling Optimization algorithm from thesis
                
                // Phase 1 or Phase 2?
                let numChanges;
                if (this.phase === 1) {
                    // Uniform distribution [1, alpha]
                    numChanges = Math.floor(Math.random() * this.alpha) + 1;
                } else {
                    // Memory-based: pick from successful lengths list Â± [0,2]
                    if (this.successLengths.length === 0) {
                        return false; // No successful lengths yet
                    }
                    const baseLength = this.successLengths[Math.floor(Math.random() * this.successLengths.length)];
                    const perturbation = Math.floor(Math.random() * 5) - 2; // [-2, 2]
                    numChanges = Math.max(1, baseLength + perturbation);
                }
                
                // Store current configuration
                const savedDownstream = new Int32Array(this.downstream);
                const oldEnergy = this.totalEnergy;
                
                // Make numChanges random changes
                const changes = [];
                for (let i = 0; i < numChanges; i++) {
                    const change = this.makeRandomChange();
                    if (change) {
                        changes.push(change);
                    }
                }
                
                // Evaluate objective function
                this.computeFlowAccumulation();
                this.computeDistances();
                this.computeEnergy();
                
                const newEnergy = this.totalEnergy;
                this.evaluationCount++;
                
                if (newEnergy < oldEnergy) {
                    // Accept!
                    this.improvementCount++;
                    this.consecutiveFailures = 0;
                    
                    // Add to successful lengths
                    this.successLengths.push(numChanges);
                    
                    // Track energy history
                    this.energyHistory.push(newEnergy);
                    this.changesPerSuccess.push(numChanges);
                    
                    // Highlight changed links
                    for (const change of changes) {
                        this.recentSwaps.add(change.idx);
                    }
                    
                    // Keep only recent swaps highlighted (last 30)
                    if (this.recentSwaps.size > 30) {
                        const toDelete = Array.from(this.recentSwaps).slice(0, this.recentSwaps.size - 30);
                        toDelete.forEach(idx => this.recentSwaps.delete(idx));
                    }
                    
                    return true;
                } else {
                    // Reject - revert
                    this.downstream.set(savedDownstream);
                    this.computeFlowAccumulation();
                    this.computeDistances();
                    this.computeEnergy();
                    
                    this.consecutiveFailures++;
                    
                    // Check if we should switch phases
                    if (this.phase === 1 && this.consecutiveFailures >= this.beta) {
                        this.phase = 2;
                        this.consecutiveFailures = 0;
                    } else if (this.phase === 2 && this.consecutiveFailures >= this.omega) {
                        // Optimization complete
                        return false;
                    }
                    
                    return true;
                }
            }
            
            simulatedAnnealingStep() {
                // Simulated Annealing from Johnson et al. (1989)
                
                // Make a single random change
                let idx = Math.floor(Math.random() * this.size);
                while (idx === this.outletIdx) {
                    idx = Math.floor(Math.random() * this.size);
                }
                
                const neighbors = this.getValidNeighbors(idx);
                if (neighbors.length === 0) return true;
                
                const oldDown = this.downstream[idx];
                const newDown = neighbors[Math.floor(Math.random() * neighbors.length)];
                
                if (newDown === oldDown) return true;
                
                const oldEnergy = this.totalEnergy;
                
                // Make the change
                this.downstream[idx] = newDown;
                this.computeFlowAccumulation();
                this.computeDistances();
                this.computeEnergy();
                
                const newEnergy = this.totalEnergy;
                const deltaE = newEnergy - oldEnergy;
                
                this.evaluationCount++;
                this.saIterationsAtTemp++;
                
                // Metropolis criterion: accept if improves OR with probability exp(-Î”E/T)
                const acceptProbability = deltaE < 0 ? 1 : Math.exp(-deltaE / this.temperature);
                
                if (Math.random() < acceptProbability) {
                    // Accept
                    if (deltaE < 0) {
                        this.improvementCount++;
                        this.recentSwaps.add(idx);
                        
                        // Keep only recent swaps highlighted
                        if (this.recentSwaps.size > 30) {
                            const arr = Array.from(this.recentSwaps);
                            this.recentSwaps.delete(arr[0]);
                        }
                    }
                    
                    this.consecutiveFailures = 0;
                    this.energyHistory.push(newEnergy);
                } else {
                    // Reject - revert
                    this.downstream[idx] = oldDown;
                    this.computeFlowAccumulation();
                    this.computeDistances();
                    this.computeEnergy();
                    
                    this.consecutiveFailures++;
                }
                
                // Cool down temperature periodically
                if (this.saIterationsAtTemp >= this.saIterationsPerTemp) {
                    this.temperature *= this.saCoolingRate;
                    this.saIterationsAtTemp = 0;
                }
                
                // Stop if temperature too low or too many consecutive failures
                if (this.temperature < 0.001 || this.consecutiveFailures >= 1000) {
                    return false;
                }
                
                return true;
            }
            
            greedyGradientStep() {
                // "Adam-like" for discrete optimization:
                // Compute Î”E for ALL possible single swaps, pick the best
                
                let bestDeltaE = 0;
                let bestIdx = -1;
                let bestNewDown = -1;
                
                const currentEnergy = this.totalEnergy;
                
                // For each cell (except outlet)
                for (let idx = 0; idx < this.size; idx++) {
                    if (idx === this.outletIdx) continue;
                    
                    const currentDown = this.downstream[idx];
                    const neighbors = this.getValidNeighbors(idx);
                    
                    // Try each valid neighbor
                    for (const newDown of neighbors) {
                        if (newDown === currentDown) continue;
                        
                        // Temporarily make the swap
                        this.downstream[idx] = newDown;
                        this.computeFlowAccumulation();
                        this.computeDistances();
                        this.computeEnergy();
                        
                        const newEnergy = this.totalEnergy;
                        const deltaE = newEnergy - currentEnergy;
                        
                        this.evaluationCount++;
                        
                        // Is this the best improvement so far?
                        if (deltaE < bestDeltaE) {
                            bestDeltaE = deltaE;
                            bestIdx = idx;
                            bestNewDown = newDown;
                        }
                        
                        // Revert
                        this.downstream[idx] = currentDown;
                    }
                }
                
                // Restore original state
                this.computeFlowAccumulation();
                this.computeDistances();
                this.computeEnergy();
                
                // Apply the best swap if one was found
                if (bestIdx >= 0 && bestDeltaE < 0) {
                    this.downstream[bestIdx] = bestNewDown;
                    this.computeFlowAccumulation();
                    this.computeDistances();
                    this.computeEnergy();
                    
                    this.improvementCount++;
                    this.consecutiveFailures = 0;
                    this.recentSwaps.add(bestIdx);
                    
                    // Keep only recent swaps highlighted
                    if (this.recentSwaps.size > 30) {
                        const arr = Array.from(this.recentSwaps);
                        this.recentSwaps.delete(arr[0]);
                    }
                    
                    this.energyHistory.push(this.totalEnergy);
                    
                    return true;
                } else {
                    // No improving move found - at local minimum
                    this.consecutiveFailures++;
                    return this.consecutiveFailures < 10; // Stop after 10 failures
                }
            }
            
            adamOptimizerStep() {
                // Adam optimizer for discrete network optimization
                // Uses gradient estimates with momentum and adaptive learning rates
                
                this.adamT++; // Increment timestep
                
                // Compute gradients for all cells
                const gradients = new Map();
                const currentEnergy = this.totalEnergy;
                
                // Sample a subset of cells for computational efficiency
                const cellsToSample = Math.min(this.size, Math.ceil(this.size * 0.2)); // Sample 20%
                const indices = [];
                for (let i = 0; i < this.size; i++) {
                    if (i !== this.outletIdx) indices.push(i);
                }
                
                // Shuffle and take subset
                for (let i = indices.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [indices[i], indices[j]] = [indices[j], indices[i]];
                }
                const sampledIndices = indices.slice(0, cellsToSample);
                
                // Compute gradients for sampled cells
                for (const idx of sampledIndices) {
                    const currentDown = this.downstream[idx];
                    const neighbors = this.getValidNeighbors(idx);
                    
                    let bestDeltaE = 0;
                    let bestNeighbor = currentDown;
                    
                    for (const newDown of neighbors) {
                        if (newDown === currentDown) continue;
                        
                        // Temporarily swap
                        this.downstream[idx] = newDown;
                        this.computeFlowAccumulation();
                        this.computeDistances();
                        this.computeEnergy();
                        
                        const deltaE = this.totalEnergy - currentEnergy;
                        this.evaluationCount++;
                        
                        if (deltaE < bestDeltaE) {
                            bestDeltaE = deltaE;
                            bestNeighbor = newDown;
                        }
                        
                        // Revert
                        this.downstream[idx] = currentDown;
                    }
                    
                    // Store gradient as (energy improvement, best direction)
                    if (bestDeltaE < 0) {
                        gradients.set(idx, {gradient: -bestDeltaE, direction: bestNeighbor});
                    }
                }
                
                // Restore state
                this.computeFlowAccumulation();
                this.computeDistances();
                this.computeEnergy();
                
                // Update moments and apply Adam updates
                let appliedUpdate = false;
                const updates = [];
                
                for (const [idx, {gradient, direction}] of gradients) {
                    // Initialize moments if needed
                    if (!this.adamM.has(idx)) {
                        this.adamM.set(idx, 0);
                        this.adamV.set(idx, 0);
                    }
                    
                    // Update biased first moment estimate
                    const m = this.adamBeta1 * this.adamM.get(idx) + (1 - this.adamBeta1) * gradient;
                    this.adamM.set(idx, m);
                    
                    // Update biased second moment estimate
                    const v = this.adamBeta2 * this.adamV.get(idx) + (1 - this.adamBeta2) * gradient * gradient;
                    this.adamV.set(idx, v);
                    
                    // Compute bias-corrected moments
                    const mHat = m / (1 - Math.pow(this.adamBeta1, this.adamT));
                    const vHat = v / (1 - Math.pow(this.adamBeta2, this.adamT));
                    
                    // Compute update strength
                    const updateStrength = this.adamLearningRate * mHat / (Math.sqrt(vHat) + this.adamEpsilon);
                    
                    // Store for probabilistic application
                    updates.push({idx, direction, strength: updateStrength});
                }
                
                // Sort by update strength and apply top updates
                updates.sort((a, b) => b.strength - a.strength);
                
                const numUpdates = Math.max(1, Math.floor(updates.length * 0.3)); // Apply top 30%
                
                for (let i = 0; i < numUpdates && i < updates.length; i++) {
                    const {idx, direction} = updates[i];
                    this.downstream[idx] = direction;
                    this.recentSwaps.add(idx);
                    appliedUpdate = true;
                }
                
                if (appliedUpdate) {
                    this.computeFlowAccumulation();
                    this.computeDistances();
                    this.computeEnergy();
                    
                    if (this.totalEnergy < currentEnergy) {
                        this.improvementCount++;
                        this.consecutiveFailures = 0;
                    } else {
                        this.consecutiveFailures++;
                    }
                    
                    // Keep only recent swaps highlighted
                    if (this.recentSwaps.size > 30) {
                        const arr = Array.from(this.recentSwaps);
                        for (let i = 0; i < this.recentSwaps.size - 30; i++) {
                            this.recentSwaps.delete(arr[i]);
                        }
                    }
                    
                    this.energyHistory.push(this.totalEnergy);
                    return true;
                } else {
                    this.consecutiveFailures++;
                    return this.consecutiveFailures < 100; // Continue trying
                }
            }
            
            tabuSearchStep() {
                // Tabu Search: explore neighborhood but forbid recently visited moves
                const currentEnergy = this.totalEnergy;
                let bestDeltaE = Infinity;
                let bestIdx = -1;
                let bestNewDown = -1;
                
                // Sample random subset of cells
                const cellsToTry = Math.min(this.size, Math.ceil(this.size * 0.3));
                const indices = [];
                for (let i = 0; i < this.size; i++) {
                    if (i !== this.outletIdx) indices.push(i);
                }
                
                for (let i = indices.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [indices[i], indices[j]] = [indices[j], indices[i]];
                }
                
                for (let t = 0; t < cellsToTry; t++) {
                    const idx = indices[t];
                    const currentDown = this.downstream[idx];
                    const neighbors = this.getValidNeighbors(idx);
                    
                    for (const newDown of neighbors) {
                        if (newDown === currentDown) continue;
                        
                        // Check if this move is tabu
                        const moveKey = `${idx}-${newDown}`;
                        if (this.tabuList.includes(moveKey)) continue;
                        
                        // Try swap
                        this.downstream[idx] = newDown;
                        this.computeFlowAccumulation();
                        this.computeDistances();
                        this.computeEnergy();
                        
                        const deltaE = this.totalEnergy - currentEnergy;
                        this.evaluationCount++;
                        
                        // Track best non-tabu move (even if worse)
                        if (deltaE < bestDeltaE) {
                            bestDeltaE = deltaE;
                            bestIdx = idx;
                            bestNewDown = newDown;
                        }
                        
                        // Revert
                        this.downstream[idx] = currentDown;
                    }
                }
                
                // Restore state
                this.computeFlowAccumulation();
                this.computeDistances();
                this.computeEnergy();
                
                // Make best move
                if (bestIdx >= 0) {
                    this.downstream[bestIdx] = bestNewDown;
                    this.computeFlowAccumulation();
                    this.computeDistances();
                    this.computeEnergy();
                    
                    // Add to tabu list
                    const moveKey = `${bestIdx}-${bestNewDown}`;
                    this.tabuList.push(moveKey);
                    if (this.tabuList.length > this.tabuTenure) {
                        this.tabuList.shift();
                    }
                    
                    if (bestDeltaE < 0) {
                        this.improvementCount++;
                        this.consecutiveFailures = 0;
                    } else {
                        this.consecutiveFailures++;
                    }
                    
                    this.recentSwaps.add(bestIdx);
                    if (this.recentSwaps.size > 30) {
                        const arr = Array.from(this.recentSwaps);
                        this.recentSwaps.delete(arr[0]);
                    }
                    
                    this.energyHistory.push(this.totalEnergy);
                    return true;
                }
                
                return this.consecutiveFailures < 50;
            }
            
            vnsStep() {
                // Variable Neighborhood Search: systematically change neighborhood size
                const currentEnergy = this.totalEnergy;
                let improved = false;
                
                // Try k random swaps
                const swaps = [];
                for (let i = 0; i < this.vnsCurrentK; i++) {
                    const cells = [];
                    for (let idx = 0; idx < this.size; idx++) {
                        if (idx !== this.outletIdx) cells.push(idx);
                    }
                    const idx = cells[Math.floor(Math.random() * cells.length)];
                    const neighbors = this.getValidNeighbors(idx);
                    if (neighbors.length > 0) {
                        const newDown = neighbors[Math.floor(Math.random() * neighbors.length)];
                        swaps.push({idx, old: this.downstream[idx], new: newDown});
                        this.downstream[idx] = newDown;
                    }
                }
                
                this.computeFlowAccumulation();
                this.computeDistances();
                this.computeEnergy();
                this.evaluationCount++;
                
                if (this.totalEnergy < currentEnergy) {
                    // Improvement! Reset to k=1
                    this.vnsCurrentK = 1;
                    this.improvementCount++;
                    this.consecutiveFailures = 0;
                    improved = true;
                    
                    for (const swap of swaps) {
                        this.recentSwaps.add(swap.idx);
                    }
                } else {
                    // No improvement, revert and increase k
                    for (const swap of swaps) {
                        this.downstream[swap.idx] = swap.old;
                    }
                    this.computeFlowAccumulation();
                    this.computeDistances();
                    this.computeEnergy();
                    
                    this.vnsCurrentK++;
                    if (this.vnsCurrentK > this.vnsMaxK) {
                        this.vnsCurrentK = 1;
                    }
                    this.consecutiveFailures++;
                }
                
                if (this.recentSwaps.size > 30) {
                    const arr = Array.from(this.recentSwaps);
                    this.recentSwaps.delete(arr[0]);
                }
                
                this.energyHistory.push(this.totalEnergy);
                return this.consecutiveFailures < 100;
            }
            
            graspStep() {
                // GRASP: Greedy Randomized Adaptive Search
                // Build solution greedily with randomness, then locally optimize
                
                const currentEnergy = this.totalEnergy;
                
                // Randomized greedy construction
                const cells = [];
                for (let idx = 0; idx < this.size; idx++) {
                    if (idx !== this.outletIdx) cells.push(idx);
                }
                
                // Pick random cell
                const idx = cells[Math.floor(Math.random() * cells.length)];
                const currentDown = this.downstream[idx];
                const neighbors = this.getValidNeighbors(idx);
                
                if (neighbors.length === 0) return true;
                
                // Evaluate all neighbors
                const candidates = [];
                for (const newDown of neighbors) {
                    this.downstream[idx] = newDown;
                    this.computeFlowAccumulation();
                    this.computeDistances();
                    this.computeEnergy();
                    candidates.push({newDown, energy: this.totalEnergy});
                    this.evaluationCount++;
                }
                
                // Sort by energy
                candidates.sort((a, b) => a.energy - b.energy);
                
                // Select from RCL (Restricted Candidate List)
                const rclSize = Math.max(1, Math.ceil(candidates.length * this.graspAlpha));
                const selected = candidates[Math.floor(Math.random() * rclSize)];
                
                // Apply selected move
                this.downstream[idx] = selected.newDown;
                this.computeFlowAccumulation();
                this.computeDistances();
                this.computeEnergy();
                
                if (this.totalEnergy < currentEnergy) {
                    this.improvementCount++;
                    this.consecutiveFailures = 0;
                    this.recentSwaps.add(idx);
                } else {
                    this.consecutiveFailures++;
                }
                
                if (this.recentSwaps.size > 30) {
                    const arr = Array.from(this.recentSwaps);
                    this.recentSwaps.delete(arr[0]);
                }
                
                this.energyHistory.push(this.totalEnergy);
                return this.consecutiveFailures < 100;
            }
            
            gaStep() {
                // Genetic Algorithm step
                
                // Initialize population if needed
                if (this.gaPopulation.length === 0) {
                    for (let i = 0; i < this.gaPopSize; i++) {
                        const network = new Int32Array(this.size);
                        for (let j = 0; j < this.size; j++) {
                            network[j] = this.downstream[j];
                        }
                        // Mutate to create diversity
                        for (let j = 0; j < this.size * 0.1; j++) {
                            const idx = Math.floor(Math.random() * this.size);
                            if (idx !== this.outletIdx) {
                                const neighbors = this.getValidNeighbors(idx);
                                if (neighbors.length > 0) {
                                    network[idx] = neighbors[Math.floor(Math.random() * neighbors.length)];
                                }
                            }
                        }
                        this.gaPopulation.push(network);
                    }
                }
                
                // Evaluate population
                const fitness = [];
                for (const individual of this.gaPopulation) {
                    for (let i = 0; i < this.size; i++) {
                        this.downstream[i] = individual[i];
                    }
                    this.computeFlowAccumulation();
                    this.computeDistances();
                    this.computeEnergy();
                    fitness.push(this.totalEnergy);
                    this.evaluationCount++;
                }
                
                // Find best
                const bestIdx = fitness.indexOf(Math.min(...fitness));
                const bestEnergy = fitness[bestIdx];
                
                // Update current if better
                if (bestEnergy < this.totalEnergy) {
                    for (let i = 0; i < this.size; i++) {
                        this.downstream[i] = this.gaPopulation[bestIdx][i];
                    }
                    this.computeFlowAccumulation();
                    this.computeDistances();
                    this.computeEnergy();
                    this.improvementCount++;
                    this.consecutiveFailures = 0;
                } else {
                    this.consecutiveFailures++;
                }
                
                // Selection (tournament)
                const newPop = [];
                for (let i = 0; i < this.gaPopSize; i++) {
                    const i1 = Math.floor(Math.random() * this.gaPopSize);
                    const i2 = Math.floor(Math.random() * this.gaPopSize);
                    newPop.push(fitness[i1] < fitness[i2] ? this.gaPopulation[i1] : this.gaPopulation[i2]);
                }
                
                // Crossover
                for (let i = 0; i < this.gaPopSize; i += 2) {
                    if (i + 1 < this.gaPopSize && Math.random() < 0.7) {
                        const parent1 = newPop[i];
                        const parent2 = newPop[i + 1];
                        const crossPoint = Math.floor(Math.random() * this.size);
                        
                        const child1 = new Int32Array(this.size);
                        const child2 = new Int32Array(this.size);
                        
                        for (let j = 0; j < this.size; j++) {
                            if (j < crossPoint) {
                                child1[j] = parent1[j];
                                child2[j] = parent2[j];
                            } else {
                                child1[j] = parent2[j];
                                child2[j] = parent1[j];
                            }
                        }
                        
                        newPop[i] = child1;
                        newPop[i + 1] = child2;
                    }
                }
                
                // Mutation
                for (const individual of newPop) {
                    if (Math.random() < this.gaMutationRate) {
                        const idx = Math.floor(Math.random() * this.size);
                        if (idx !== this.outletIdx) {
                            for (let i = 0; i < this.size; i++) {
                                this.downstream[i] = individual[i];
                            }
                            const neighbors = this.getValidNeighbors(idx);
                            if (neighbors.length > 0) {
                                individual[idx] = neighbors[Math.floor(Math.random() * neighbors.length)];
                            }
                        }
                    }
                }
                
                this.gaPopulation = newPop;
                this.gaGeneration++;
                
                this.energyHistory.push(this.totalEnergy);
                return this.consecutiveFailures < 50;
            }
            
            memeticStep() {
                // Memetic Algorithm: GA + local search
                
                // Initialize population if needed
                if (this.memeticPopulation.length === 0) {
                    for (let i = 0; i < this.memeticPopSize; i++) {
                        const network = new Int32Array(this.size);
                        for (let j = 0; j < this.size; j++) {
                            network[j] = this.downstream[j];
                        }
                        // Mutate
                        for (let j = 0; j < this.size * 0.1; j++) {
                            const idx = Math.floor(Math.random() * this.size);
                            if (idx !== this.outletIdx) {
                                const neighbors = this.getValidNeighbors(idx);
                                if (neighbors.length > 0) {
                                    network[idx] = neighbors[Math.floor(Math.random() * neighbors.length)];
                                }
                            }
                        }
                        this.memeticPopulation.push(network);
                    }
                }
                
                // Evaluate and locally optimize each individual
                const fitness = [];
                for (const individual of this.memeticPopulation) {
                    // Set network
                    for (let i = 0; i < this.size; i++) {
                        this.downstream[i] = individual[i];
                    }
                    
                    // Local search
                    for (let ls = 0; ls < this.memeticLocalSearchDepth; ls++) {
                        const idx = Math.floor(Math.random() * this.size);
                        if (idx === this.outletIdx) continue;
                        
                        const currentDown = this.downstream[idx];
                        const neighbors = this.getValidNeighbors(idx);
                        
                        this.computeFlowAccumulation();
                        this.computeDistances();
                        this.computeEnergy();
                        const currentE = this.totalEnergy;
                        
                        let bestE = currentE;
                        let bestDown = currentDown;
                        
                        for (const newDown of neighbors) {
                            this.downstream[idx] = newDown;
                            this.computeFlowAccumulation();
                            this.computeDistances();
                            this.computeEnergy();
                            this.evaluationCount++;
                            
                            if (this.totalEnergy < bestE) {
                                bestE = this.totalEnergy;
                                bestDown = newDown;
                            }
                        }
                        
                        this.downstream[idx] = bestDown;
                        
                        // Update individual
                        individual[idx] = bestDown;
                    }
                    
                    this.computeFlowAccumulation();
                    this.computeDistances();
                    this.computeEnergy();
                    fitness.push(this.totalEnergy);
                }
                
                // Find best
                const bestIdx = fitness.indexOf(Math.min(...fitness));
                const bestEnergy = fitness[bestIdx];
                
                if (bestEnergy < this.totalEnergy) {
                    for (let i = 0; i < this.size; i++) {
                        this.downstream[i] = this.memeticPopulation[bestIdx][i];
                    }
                    this.computeFlowAccumulation();
                    this.computeDistances();
                    this.computeEnergy();
                    this.improvementCount++;
                    this.consecutiveFailures = 0;
                } else {
                    this.consecutiveFailures++;
                }
                
                // Simple selection and mutation for next generation
                const newPop = [];
                for (let i = 0; i < this.memeticPopSize; i++) {
                    const i1 = Math.floor(Math.random() * this.memeticPopSize);
                    const i2 = Math.floor(Math.random() * this.memeticPopSize);
                    const selected = fitness[i1] < fitness[i2] ? this.memeticPopulation[i1] : this.memeticPopulation[i2];
                    const child = new Int32Array(this.size);
                    for (let j = 0; j < this.size; j++) {
                        child[j] = selected[j];
                    }
                    newPop.push(child);
                }
                
                this.memeticPopulation = newPop;
                this.energyHistory.push(this.totalEnergy);
                return this.consecutiveFailures < 30;
            }
            
            deStep() {
                // Differential Evolution
                
                // Initialize population if needed
                if (this.dePopulation.length === 0) {
                    for (let i = 0; i < this.dePopSize; i++) {
                        const network = new Int32Array(this.size);
                        for (let j = 0; j < this.size; j++) {
                            network[j] = this.downstream[j];
                        }
                        // Mutate to create diversity
                        for (let j = 0; j < this.size * 0.15; j++) {
                            const idx = Math.floor(Math.random() * this.size);
                            if (idx !== this.outletIdx) {
                                const neighbors = this.getValidNeighbors(idx);
                                if (neighbors.length > 0) {
                                    network[idx] = neighbors[Math.floor(Math.random() * neighbors.length)];
                                }
                            }
                        }
                        this.dePopulation.push(network);
                    }
                }
                
                // Evaluate population
                const fitness = [];
                for (const individual of this.dePopulation) {
                    for (let i = 0; i < this.size; i++) {
                        this.downstream[i] = individual[i];
                    }
                    this.computeFlowAccumulation();
                    this.computeDistances();
                    this.computeEnergy();
                    fitness.push(this.totalEnergy);
                    this.evaluationCount++;
                }
                
                // Find best
                const bestIdx = fitness.indexOf(Math.min(...fitness));
                const bestEnergy = fitness[bestIdx];
                
                if (bestEnergy < this.totalEnergy) {
                    for (let i = 0; i < this.size; i++) {
                        this.downstream[i] = this.dePopulation[bestIdx][i];
                    }
                    this.computeFlowAccumulation();
                    this.computeDistances();
                    this.computeEnergy();
                    this.improvementCount++;
                    this.consecutiveFailures = 0;
                } else {
                    this.consecutiveFailures++;
                }
                
                // DE mutation and crossover
                const newPop = [];
                for (let i = 0; i < this.dePopSize; i++) {
                    // Select three random distinct individuals
                    let r1, r2, r3;
                    do { r1 = Math.floor(Math.random() * this.dePopSize); } while (r1 === i);
                    do { r2 = Math.floor(Math.random() * this.dePopSize); } while (r2 === i || r2 === r1);
                    do { r3 = Math.floor(Math.random() * this.dePopSize); } while (r3 === i || r3 === r1 || r3 === r2);
                    
                    const trial = new Int32Array(this.size);
                    
                    for (let j = 0; j < this.size; j++) {
                        if (Math.random() < this.deCR || j === Math.floor(Math.random() * this.size)) {
                            // Discrete DE: if different, use r1, else stay with current
                            if (this.dePopulation[r2][j] !== this.dePopulation[r3][j]) {
                                trial[j] = this.dePopulation[r1][j];
                            } else {
                                trial[j] = this.dePopulation[i][j];
                            }
                        } else {
                            trial[j] = this.dePopulation[i][j];
                        }
                    }
                    
                    // Evaluate trial
                    for (let j = 0; j < this.size; j++) {
                        this.downstream[j] = trial[j];
                    }
                    this.computeFlowAccumulation();
                    this.computeDistances();
                    this.computeEnergy();
                    const trialFitness = this.totalEnergy;
                    this.evaluationCount++;
                    
                    // Selection
                    if (trialFitness < fitness[i]) {
                        newPop.push(trial);
                    } else {
                        newPop.push(this.dePopulation[i]);
                    }
                }
                
                this.dePopulation = newPop;
                this.energyHistory.push(this.totalEnergy);
                return this.consecutiveFailures < 50;
            }
            
            optimizeNetwork(steps = 100) {
                for (let i = 0; i < steps; i++) {
                    let shouldContinue;
                    
                    switch(this.optimizationMode) {
                        case 'hto':
                            shouldContinue = this.hillTunnelingStep();
                            break;
                        case 'sa':
                            shouldContinue = this.simulatedAnnealingStep();
                            break;
                        case 'gradient':
                            shouldContinue = this.greedyGradientStep();
                            break;
                        case 'adam':
                            shouldContinue = this.adamOptimizerStep();
                            break;
                        case 'tabu':
                            shouldContinue = this.tabuSearchStep();
                            break;
                        case 'vns':
                            shouldContinue = this.vnsStep();
                            break;
                        case 'grasp':
                            shouldContinue = this.graspStep();
                            break;
                        case 'ga':
                            shouldContinue = this.gaStep();
                            break;
                        case 'memetic':
                            shouldContinue = this.memeticStep();
                            break;
                        case 'de':
                            shouldContinue = this.deStep();
                            break;
                        default:
                            shouldContinue = this.hillTunnelingStep();
                    }
                    
                    if (!shouldContinue) {
                        break; // Optimization complete
                    }
                }
            }
            
            setOutlet(x, y) {
                const newOutletIdx = this.IX(
                    Math.floor(x * this.N),
                    Math.floor(y * this.N)
                );
                
                if (newOutletIdx !== this.outletIdx) {
                    this.outletX = Math.floor(x * this.N);
                    this.outletY = Math.floor(y * this.N);
                    this.outletIdx = newOutletIdx;
                    this.buildInitialNetwork();
                    this.recentSwaps.clear();
                    this.phase = 1;
                    this.successLengths = [];
                    this.consecutiveFailures = 0;
                    this.evaluationCount = 0;
                    this.improvementCount = 0;
                    this.energyHistory = [];
                    this.changesPerSuccess = [];
                }
            }
            
            setOptimizationMode(mode) {
                this.optimizationMode = mode;
                
                // Reset algorithm-specific state
                this.phase = 1;
                this.successLengths = [];
                this.temperature = this.initialTemperature;
                this.saIterationsAtTemp = 0;
                this.consecutiveFailures = 0;
                this.evaluationCount = 0;
                this.improvementCount = 0;
                this.energyHistory = [];
                this.changesPerSuccess = [];
                this.recentSwaps.clear();
                
                // Reset Adam state
                this.adamM.clear();
                this.adamV.clear();
                this.adamT = 0;
                
                // Reset new algorithm states
                this.tabuList = [];
                this.vnsCurrentK = 1;
                this.gaPopulation = [];
                this.gaGeneration = 0;
                this.memeticPopulation = [];
                this.dePopulation = [];
            }
            
            reset() {
                this.buildInitialNetwork();
                this.recentSwaps.clear();
                this.phase = 1;
                this.successLengths = [];
                this.temperature = this.initialTemperature;
                this.saIterationsAtTemp = 0;
                this.consecutiveFailures = 0;
                this.evaluationCount = 0;
                this.improvementCount = 0;
                this.energyHistory = [];
                this.changesPerSuccess = [];
            }
            
            getNetworkStats() {
                let totalLength = 0;
                let maxFlow = 0;
                let channelCount = 0;
                
                for (let idx = 0; idx < this.size; idx++) {
                    if (this.flowAccum[idx] >= this.minDrainageArea) {
                        channelCount++;
                    }
                    
                    const down = this.downstream[idx];
                    if (down !== idx) {
                        totalLength += this.getEuclideanDist(idx, down);
                    }
                    
                    if (this.flowAccum[idx] > maxFlow) {
                        maxFlow = this.flowAccum[idx];
                    }
                }
                
                const drainageDensity = totalLength / this.size;
                
                // Estimate bifurcation ratio from network structure
                let junctions = 0;
                let totalBranches = 0;
                
                for (let idx = 0; idx < this.size; idx++) {
                    let tributaries = 0;
                    for (let i = 0; i < this.size; i++) {
                        if (this.downstream[i] === idx && i !== idx) {
                            tributaries++;
                        }
                    }
                    if (tributaries > 1) {
                        junctions++;
                        totalBranches += tributaries;
                    }
                }
                
                const bifurcationRatio = junctions > 0 ? totalBranches / junctions : 0;
                
                const acceptanceRate = this.evaluationCount > 0 ? 
                    (this.improvementCount / this.evaluationCount * 100).toFixed(1) : 0;
                
                let algorithmStatus = '';
                if (this.optimizationMode === 'hto') {
                    algorithmStatus = this.phase === 1 ? 'Phase 1 (Uniform)' : 'Phase 2 (Memory)';
                } else if (this.optimizationMode === 'sa') {
                    algorithmStatus = `T=${this.temperature.toFixed(2)}`;
                } else if (this.optimizationMode === 'gradient') {
                    algorithmStatus = 'Steepest Descent';
                } else if (this.optimizationMode === 'adam') {
                    algorithmStatus = `t=${this.adamT}, Î±=${this.adamLearningRate.toFixed(3)}`;
                } else if (this.optimizationMode === 'tabu') {
                    algorithmStatus = `Tabu size: ${this.tabuList.length}`;
                } else if (this.optimizationMode === 'vns') {
                    algorithmStatus = `k=${this.vnsCurrentK}/${this.vnsMaxK}`;
                } else if (this.optimizationMode === 'grasp') {
                    algorithmStatus = `Î±=${this.graspAlpha.toFixed(2)} (greediness)`;
                } else if (this.optimizationMode === 'ga') {
                    algorithmStatus = `Gen ${this.gaGeneration}, Pop=${this.gaPopSize}`;
                } else if (this.optimizationMode === 'memetic') {
                    algorithmStatus = `Pop=${this.memeticPopSize}, LS=${this.memeticLocalSearchDepth}`;
                } else if (this.optimizationMode === 'de') {
                    algorithmStatus = `Pop=${this.dePopSize}, F=${this.deF.toFixed(2)}`;
                }
                
                return {
                    totalLength: totalLength.toFixed(1),
                    channelCount,
                    drainageDensity,
                    bifurcationRatio,
                    totalEnergy: this.totalEnergy.toFixed(1),
                    maxFlow: Math.floor(maxFlow),
                    evaluationCount: this.evaluationCount,
                    improvementCount: this.improvementCount,
                    acceptanceRate,
                    algorithmStatus,
                    successLengthsCount: this.successLengths.length,
                    mode: this.optimizationMode
                };
            }
        }
        
        // Energy Plot Renderer
        class EnergyPlotter {
            constructor(canvas, network) {
                this.canvas = canvas;
                this.network = network;
                this.ctx = canvas.getContext('2d');
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }
            
            render() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const padding = 40;
                
                // Clear background
                this.ctx.fillStyle = '#141923';
                this.ctx.fillRect(0, 0, width, height);
                
                const history = this.network.energyHistory;
                if (history.length < 2) return;
                
                // Find min/max for scaling
                let minE = Math.min(...history);
                let maxE = Math.max(...history);
                const range = maxE - minE || 1;
                
                // Add some padding to the range
                minE -= range * 0.1;
                maxE += range * 0.1;
                const scaledRange = maxE - minE;
                
                const plotWidth = width - 2 * padding;
                const plotHeight = height - 2 * padding;
                
                // Draw axes
                this.ctx.strokeStyle = 'rgba(139, 149, 165, 0.3)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, padding);
                this.ctx.lineTo(padding, height - padding);
                this.ctx.lineTo(width - padding, height - padding);
                this.ctx.stroke();
                
                // Draw grid lines
                this.ctx.strokeStyle = 'rgba(139, 149, 165, 0.1)';
                for (let i = 0; i <= 5; i++) {
                    const y = padding + (plotHeight * i / 5);
                    this.ctx.beginPath();
                    this.ctx.moveTo(padding, y);
                    this.ctx.lineTo(width - padding, y);
                    this.ctx.stroke();
                }
                
                // Draw energy curve
                this.ctx.strokeStyle = '#00d9ff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                for (let i = 0; i < history.length; i++) {
                    const x = padding + (i / (history.length - 1)) * plotWidth;
                    const y = height - padding - ((history[i] - minE) / scaledRange) * plotHeight;
                    
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();
                
                // Add shadow effect
                this.ctx.strokeStyle = 'rgba(0, 217, 255, 0.3)';
                this.ctx.lineWidth = 4;
                this.ctx.stroke();
                
                // Labels
                this.ctx.fillStyle = '#8b95a5';
                this.ctx.font = '11px JetBrains Mono';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Successful Evaluations', width / 2, height - 5);
                
                this.ctx.save();
                this.ctx.translate(15, height / 2);
                this.ctx.rotate(-Math.PI / 2);
                this.ctx.fillText('Energy (E = Î£A^Î³L)', 0, 0);
                this.ctx.restore();
                
                // Y-axis labels
                this.ctx.textAlign = 'right';
                for (let i = 0; i <= 5; i++) {
                    const value = maxE - (scaledRange * i / 5);
                    const y = padding + (plotHeight * i / 5);
                    this.ctx.fillText(value.toFixed(0), padding - 5, y + 4);
                }
                
                // X-axis labels
                this.ctx.textAlign = 'center';
                const xLabels = [0, Math.floor(history.length / 2), history.length - 1];
                for (const label of xLabels) {
                    const x = padding + (label / (history.length - 1)) * plotWidth;
                    this.ctx.fillText(label.toString(), x, height - padding + 15);
                }
                
                // Current value indicator
                if (history.length > 0) {
                    const lastE = history[history.length - 1];
                    const x = width - padding;
                    const y = height - padding - ((lastE - minE) / scaledRange) * plotHeight;
                    
                    this.ctx.fillStyle = '#ff006e';
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 4, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
        }
        
        // Renderer
        class NetworkRenderer {
            constructor(canvas, network) {
                this.canvas = canvas;
                this.network = network;
                this.ctx = canvas.getContext('2d');
                this.mode = 'network';
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }
            
            render() {
                this.ctx.fillStyle = '#141923';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                switch(this.mode) {
                    case 'network':
                        this.renderNetwork();
                        break;
                    case 'elevation':
                        this.renderElevation();
                        break;
                    case 'flow':
                        this.renderFlowAccumulation();
                        break;
                    case 'energy':
                        this.renderEnergy();
                        break;
                    case 'slope':
                        this.renderSlope();
                        break;
                    case 'strahler':
                        this.renderStrahler();
                        break;
                }
            }
            
            renderNetwork() {
                const N = this.network.N;
                const cellSize = Math.min(this.canvas.width, this.canvas.height) / N;
                
                // Draw background
                this.ctx.fillStyle = '#1a2332';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw all network links first
                for (let idx = 0; idx < this.network.size; idx++) {
                    const down = this.network.downstream[idx];
                    if (down === idx) continue; // Skip outlet
                    
                    const c1 = this.network.getCoords(idx);
                    const c2 = this.network.getCoords(down);
                    
                    const flow = this.network.flowAccum[idx];
                    const width = Math.max(0.5, Math.sqrt(flow) * 0.15);
                    
                    // Color by flow accumulation
                    const t = Math.min(1, Math.log(flow + 1) / Math.log(this.network.size));
                    const r = Math.floor(t * 100);
                    const g = Math.floor((0.7 + t * 0.3) * 217);
                    const b = Math.floor(200 + t * 55);
                    
                    // Check if this link was recently swapped
                    const isRecent = this.network.recentSwaps.has(idx);
                    
                    if (isRecent) {
                        // Highlight recent swaps in bright cyan
                        this.ctx.strokeStyle = '#00ffff';
                        this.ctx.lineWidth = width * 2;
                        this.ctx.shadowColor = '#00ffff';
                        this.ctx.shadowBlur = 10;
                    } else {
                        this.ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;
                        this.ctx.lineWidth = width;
                        this.ctx.shadowBlur = 0;
                    }
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo((c1.i + 0.5) * cellSize, (c1.j + 0.5) * cellSize);
                    this.ctx.lineTo((c2.i + 0.5) * cellSize, (c2.j + 0.5) * cellSize);
                    this.ctx.stroke();
                }
                
                this.ctx.shadowBlur = 0;
                
                // Draw all nodes as small dots
                for (let idx = 0; idx < this.network.size; idx++) {
                    if (idx === this.network.outletIdx) continue; // Skip outlet (drawn separately)
                    
                    const c = this.network.getCoords(idx);
                    
                    this.ctx.fillStyle = '#2a3441';
                    this.ctx.beginPath();
                    this.ctx.arc(
                        (c.i + 0.5) * cellSize,
                        (c.j + 0.5) * cellSize,
                        cellSize * 0.08,
                        0,
                        Math.PI * 2
                    );
                    this.ctx.fill();
                }
                
                // Draw arrows only for channels (above minDrainageArea threshold)
                for (let idx = 0; idx < this.network.size; idx++) {
                    const down = this.network.downstream[idx];
                    if (down === idx) continue;
                    
                    const flow = this.network.flowAccum[idx];
                    const isChannel = flow >= this.network.minDrainageArea;
                    const isRecent = this.network.recentSwaps.has(idx);
                    
                    if (isChannel && !isRecent) {
                        const c1 = this.network.getCoords(idx);
                        const c2 = this.network.getCoords(down);
                        
                        const angle = Math.atan2(c2.j - c1.j, c2.i - c1.i);
                        const mx = (c1.i + c2.i) / 2;
                        const my = (c1.j + c2.j) / 2;
                        const arrowSize = cellSize * 0.2;
                        
                        // Color by flow accumulation
                        const t = Math.min(1, Math.log(flow + 1) / Math.log(this.network.size));
                        const r = Math.floor(t * 100);
                        const g = Math.floor((0.7 + t * 0.3) * 217);
                        const b = Math.floor(200 + t * 55);
                        
                        this.ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;
                        this.ctx.lineWidth = Math.max(0.5, Math.sqrt(flow) * 0.15);
                        
                        this.ctx.save();
                        this.ctx.translate((mx + 0.5) * cellSize, (my + 0.5) * cellSize);
                        this.ctx.rotate(angle);
                        this.ctx.beginPath();
                        this.ctx.moveTo(-arrowSize, -arrowSize * 0.5);
                        this.ctx.lineTo(0, 0);
                        this.ctx.lineTo(-arrowSize, arrowSize * 0.5);
                        this.ctx.stroke();
                        this.ctx.restore();
                    }
                }
                
                // Draw nodes for junctions
                for (let idx = 0; idx < this.network.size; idx++) {
                    let tributaries = 0;
                    for (let i = 0; i < this.network.size; i++) {
                        if (this.network.downstream[i] === idx && i !== idx) {
                            tributaries++;
                        }
                    }
                    
                    if (tributaries > 1) {
                        const c = this.network.getCoords(idx);
                        this.ctx.fillStyle = 'rgba(0, 217, 255, 0.5)';
                        this.ctx.beginPath();
                        this.ctx.arc(
                            (c.i + 0.5) * cellSize,
                            (c.j + 0.5) * cellSize,
                            cellSize * 0.15,
                            0,
                            Math.PI * 2
                        );
                        this.ctx.fill();
                    }
                }
                
                // Draw outlet prominently
                this.ctx.fillStyle = '#ff006e';
                this.ctx.shadowColor = '#ff006e';
                this.ctx.shadowBlur = 15;
                this.ctx.beginPath();
                this.ctx.arc(
                    (this.network.outletX + 0.5) * cellSize,
                    (this.network.outletY + 0.5) * cellSize,
                    cellSize * 0.4,
                    0,
                    Math.PI * 2
                );
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            renderElevation() {
                // Show distance to outlet as proxy for elevation
                const N = this.network.N;
                const cellSize = Math.min(this.canvas.width, this.canvas.height) / N;
                
                let maxDist = 0;
                for (let i = 0; i < this.network.size; i++) {
                    if (this.network.distToOutlet[i] < Infinity && this.network.distToOutlet[i] > maxDist) {
                        maxDist = this.network.distToOutlet[i];
                    }
                }
                
                for (let j = 0; j < N; j++) {
                    for (let i = 0; i < N; i++) {
                        const idx = this.network.IX(i, j);
                        const dist = this.network.distToOutlet[idx];
                        const norm = dist < Infinity ? dist / maxDist : 0;
                        
                        const r = Math.floor(norm * 100);
                        const g = Math.floor(norm * 150 + 50);
                        const b = Math.floor(norm * 200 + 55);
                        
                        this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        this.ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                    }
                }
            }
            
            renderFlowAccumulation() {
                const N = this.network.N;
                const cellSize = Math.min(this.canvas.width, this.canvas.height) / N;
                
                let maxFlow = 0;
                for (let i = 0; i < this.network.size; i++) {
                    if (this.network.flowAccum[i] > maxFlow) maxFlow = this.network.flowAccum[i];
                }
                
                for (let j = 0; j < N; j++) {
                    for (let i = 0; i < N; i++) {
                        const idx = this.network.IX(i, j);
                        const norm = Math.log(this.network.flowAccum[idx] + 1) / Math.log(maxFlow + 1);
                        
                        const r = Math.floor(norm * 255);
                        const g = Math.floor(norm * 217);
                        const b = Math.floor(255);
                        
                        this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        this.ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                    }
                }
            }
            
            renderEnergy() {
                const N = this.network.N;
                const cellSize = Math.min(this.canvas.width, this.canvas.height) / N;
                
                let maxEnergy = 0;
                for (let i = 0; i < this.network.size; i++) {
                    if (this.network.energy[i] > maxEnergy) maxEnergy = this.network.energy[i];
                }
                
                for (let j = 0; j < N; j++) {
                    for (let i = 0; i < N; i++) {
                        const idx = this.network.IX(i, j);
                        const norm = Math.min(1, this.network.energy[idx] / maxEnergy);
                        
                        const r = Math.floor(norm * 255);
                        const g = Math.floor(norm * 100);
                        const b = Math.floor(norm * 110);
                        
                        this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        this.ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                    }
                }
            }
            
            renderSlope() {
                // Show energy per link
                const N = this.network.N;
                const cellSize = Math.min(this.canvas.width, this.canvas.height) / N;
                
                let maxEnergy = 0;
                for (let i = 0; i < this.network.size; i++) {
                    if (this.network.energy[i] > maxEnergy) maxEnergy = this.network.energy[i];
                }
                
                this.ctx.fillStyle = '#141923';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                for (let idx = 0; idx < this.network.size; idx++) {
                    const down = this.network.downstream[idx];
                    if (down === idx) continue;
                    
                    const norm = this.network.energy[idx] / (maxEnergy || 1);
                    const intensity = Math.floor(norm * 255);
                    
                    const c1 = this.network.getCoords(idx);
                    const c2 = this.network.getCoords(down);
                    
                    this.ctx.strokeStyle = `rgb(${intensity}, ${intensity}, ${intensity})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo((c1.i + 0.5) * cellSize, (c1.j + 0.5) * cellSize);
                    this.ctx.lineTo((c2.i + 0.5) * cellSize, (c2.j + 0.5) * cellSize);
                    this.ctx.stroke();
                }
            }
            
            renderStrahler() {
                // Compute and visualize Strahler stream order
                const N = this.network.N;
                const cellSize = Math.min(this.canvas.width, this.canvas.height) / N;
                
                // Compute Strahler orders
                const maxOrder = this.network.computeStrahlerOrder();
                
                // Background
                this.ctx.fillStyle = '#141923';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Color palette for Strahler orders (blue to red)
                const getStrahlerColor = (order, max) => {
                    const colors = [
                        [100, 150, 255],  // Order 1: Light blue
                        [0, 217, 255],    // Order 2: Cyan
                        [0, 255, 150],    // Order 3: Green-cyan
                        [255, 200, 0],    // Order 4: Yellow
                        [255, 100, 0],    // Order 5: Orange
                        [255, 0, 110],    // Order 6+: Magenta
                    ];
                    const idx = Math.min(order - 1, colors.length - 1);
                    return colors[idx];
                };
                
                // Draw links colored by Strahler order
                for (let idx = 0; idx < this.network.size; idx++) {
                    const down = this.network.downstream[idx];
                    if (down === idx) continue;
                    
                    const order = this.network.strahlerOrder[idx];
                    if (order === 0) continue; // Skip unconnected nodes
                    
                    const [r, g, b] = getStrahlerColor(order, maxOrder);
                    const width = Math.max(1, order * 0.8);
                    
                    const c1 = this.network.getCoords(idx);
                    const c2 = this.network.getCoords(down);
                    
                    this.ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;
                    this.ctx.lineWidth = width;
                    this.ctx.beginPath();
                    this.ctx.moveTo((c1.i + 0.5) * cellSize, (c1.j + 0.5) * cellSize);
                    this.ctx.lineTo((c2.i + 0.5) * cellSize, (c2.j + 0.5) * cellSize);
                    this.ctx.stroke();
                }
                
                // Draw legend
                const legendX = this.canvas.width - 120;
                const legendY = 20;
                const legendHeight = 20 * Math.min(maxOrder, 6);
                
                // Legend background
                this.ctx.fillStyle = 'rgba(20, 25, 35, 0.85)';
                this.ctx.fillRect(legendX - 10, legendY - 10, 110, legendHeight + 30);
                
                // Legend title
                this.ctx.fillStyle = '#8b95a5';
                this.ctx.font = '12px JetBrains Mono';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('Strahler Order', legendX, legendY);
                
                // Legend entries
                for (let order = 1; order <= Math.min(maxOrder, 6); order++) {
                    const y = legendY + 15 + (order - 1) * 20;
                    const [r, g, b] = getStrahlerColor(order, maxOrder);
                    
                    // Color box
                    this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    this.ctx.fillRect(legendX, y, 15, 3);
                    
                    // Label
                    this.ctx.fillStyle = '#d9d9d9';
                    this.ctx.font = '11px JetBrains Mono';
                    this.ctx.fillText(`${order}`, legendX + 20, y + 5);
                }
            }
        }
        
        // Application
        const canvas = document.getElementById('networkCanvas');
        const energyCanvas = document.getElementById('energyPlot');
        const network = new ChannelNetwork(10); // 10Ã—10 grid as in thesis
        
        const renderer = new NetworkRenderer(canvas, network);
        const energyPlotter = new EnergyPlotter(energyCanvas, network);
        
        let isAutoOptimizing = false;
        let autoOptimizeInterval = null;
        
        function updateStats() {
            const stats = network.getNetworkStats();
            document.getElementById('total-length').textContent = stats.totalLength;
            document.getElementById('channel-count').textContent = stats.channelCount;
            document.getElementById('bifurcation').textContent = stats.bifurcationRatio.toFixed(2);
            document.getElementById('total-energy').textContent = stats.totalEnergy;
            document.getElementById('max-flow').textContent = stats.maxFlow;
            document.getElementById('eval-count').textContent = stats.evaluationCount;
            document.getElementById('success-count').textContent = stats.improvementCount;
            document.getElementById('accept-rate').textContent = stats.acceptanceRate + '%';
            document.getElementById('algo-status').textContent = stats.algorithmStatus;
            
            // Show/hide success lengths based on mode
            const successLengthsRow = document.getElementById('success-lengths-row');
            if (stats.mode === 'hto') {
                successLengthsRow.style.display = 'block';
                document.getElementById('success-lengths').textContent = stats.successLengthsCount;
            } else {
                successLengthsRow.style.display = 'none';
            }
            
            // Update mode display
            const modeNames = { 
                hto: 'HTO', 
                sa: 'SA', 
                gradient: 'Gradient', 
                adam: 'Adam',
                tabu: 'Tabu',
                vns: 'VNS',
                grasp: 'GRASP',
                ga: 'GA',
                memetic: 'Memetic',
                de: 'DE'
            };
            document.getElementById('algo-mode').textContent = modeNames[stats.mode];
        }
        
        function animate() {
            renderer.render();
            energyPlotter.render();
            updateStats();
            requestAnimationFrame(animate);
        }
        
        // Grid size selection
        document.getElementById('grid-10').addEventListener('click', (e) => {
            const currentMode = network.optimizationMode;
            const newNetwork = new ChannelNetwork(10);
            Object.assign(network, newNetwork);
            network.setOptimizationMode(currentMode);
            document.querySelectorAll('#grid-10, #grid-20').forEach(btn => {
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.borderColor = 'var(--border)';
            });
            e.target.style.background = 'rgba(0, 217, 255, 0.2)';
            e.target.style.borderColor = 'var(--accent-primary)';
            document.getElementById('grid-size-display').textContent = '10Ã—10';
        });
        
        document.getElementById('grid-20').addEventListener('click', (e) => {
            const currentMode = network.optimizationMode;
            const newNetwork = new ChannelNetwork(20);
            Object.assign(network, newNetwork);
            network.setOptimizationMode(currentMode);
            document.querySelectorAll('#grid-10, #grid-20').forEach(btn => {
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.borderColor = 'var(--border)';
            });
            e.target.style.background = 'rgba(0, 217, 255, 0.2)';
            e.target.style.borderColor = 'var(--accent-primary)';
            document.getElementById('grid-size-display').textContent = '20Ã—20';
        });
        
        // HTO parameter controls
        document.getElementById('alpha').addEventListener('input', (e) => {
            network.alpha = parseInt(e.target.value);
            document.getElementById('alpha-value').textContent = network.alpha;
        });
        
        document.getElementById('beta').addEventListener('input', (e) => {
            network.beta = parseInt(e.target.value);
            document.getElementById('beta-value').textContent = network.beta;
        });
        
        document.getElementById('omega').addEventListener('input', (e) => {
            network.omega = parseInt(e.target.value);
            document.getElementById('omega-value').textContent = network.omega;
        });
        
        // SA parameter controls
        document.getElementById('temp').addEventListener('input', (e) => {
            network.initialTemperature = parseInt(e.target.value);
            network.temperature = network.initialTemperature;
            document.getElementById('temp-value').textContent = network.initialTemperature;
        });
        
        document.getElementById('cooling').addEventListener('input', (e) => {
            network.saCoolingRate = parseFloat(e.target.value);
            document.getElementById('cooling-value').textContent = network.saCoolingRate.toFixed(2);
        });
        
        document.getElementById('iter-temp').addEventListener('input', (e) => {
            network.saIterationsPerTemp = parseInt(e.target.value);
            document.getElementById('iter-temp-value').textContent = network.saIterationsPerTemp;
        });
        
        // Adam parameter controls
        document.getElementById('adam-lr').addEventListener('input', (e) => {
            network.adamLearningRate = parseFloat(e.target.value);
            document.getElementById('adam-lr-value').textContent = network.adamLearningRate.toFixed(2);
        });
        
        document.getElementById('adam-beta1').addEventListener('input', (e) => {
            network.adamBeta1 = parseFloat(e.target.value);
            document.getElementById('adam-beta1-value').textContent = network.adamBeta1.toFixed(2);
        });
        
        document.getElementById('adam-beta2').addEventListener('input', (e) => {
            network.adamBeta2 = parseFloat(e.target.value);
            document.getElementById('adam-beta2-value').textContent = network.adamBeta2.toFixed(4);
        });
        
        document.getElementById('adam-eps').addEventListener('input', (e) => {
            const exp = parseFloat(e.target.value);
            network.adamEpsilon = Math.pow(10, exp);
            document.getElementById('adam-eps-value').textContent = `1e${exp.toFixed(0)}`;
        });
        
        // Tabu Search parameter controls
        document.getElementById('tabu-tenure').addEventListener('input', (e) => {
            network.tabuTenure = parseInt(e.target.value);
            document.getElementById('tabu-tenure-value').textContent = network.tabuTenure;
        });
        
        // VNS parameter controls
        document.getElementById('vns-maxk').addEventListener('input', (e) => {
            network.vnsMaxK = parseInt(e.target.value);
            document.getElementById('vns-maxk-value').textContent = network.vnsMaxK;
        });
        
        // GRASP parameter controls
        document.getElementById('grasp-alpha').addEventListener('input', (e) => {
            network.graspAlpha = parseFloat(e.target.value);
            document.getElementById('grasp-alpha-value').textContent = network.graspAlpha.toFixed(1);
        });
        
        // GA parameter controls
        document.getElementById('ga-popsize').addEventListener('input', (e) => {
            network.gaPopSize = parseInt(e.target.value);
            network.gaPopulation = []; // Reset population on change
            document.getElementById('ga-popsize-value').textContent = network.gaPopSize;
        });
        
        document.getElementById('ga-mutation').addEventListener('input', (e) => {
            network.gaMutationRate = parseFloat(e.target.value);
            document.getElementById('ga-mutation-value').textContent = network.gaMutationRate.toFixed(2);
        });
        
        // Memetic parameter controls
        document.getElementById('memetic-popsize').addEventListener('input', (e) => {
            network.memeticPopSize = parseInt(e.target.value);
            network.memeticPopulation = []; // Reset population on change
            document.getElementById('memetic-popsize-value').textContent = network.memeticPopSize;
        });
        
        document.getElementById('memetic-depth').addEventListener('input', (e) => {
            network.memeticLocalSearchDepth = parseInt(e.target.value);
            document.getElementById('memetic-depth-value').textContent = network.memeticLocalSearchDepth;
        });
        
        // DE parameter controls
        document.getElementById('de-popsize').addEventListener('input', (e) => {
            network.dePopSize = parseInt(e.target.value);
            network.dePopulation = []; // Reset population on change
            document.getElementById('de-popsize-value').textContent = network.dePopSize;
        });
        
        document.getElementById('de-f').addEventListener('input', (e) => {
            network.deF = parseFloat(e.target.value);
            document.getElementById('de-f-value').textContent = network.deF.toFixed(1);
        });
        
        document.getElementById('de-cr').addEventListener('input', (e) => {
            network.deCR = parseFloat(e.target.value);
            document.getElementById('de-cr-value').textContent = network.deCR.toFixed(1);
        });
        
        // Algorithm mode selection
        document.getElementById('hto-mode').addEventListener('click', (e) => {
            network.setOptimizationMode('hto');
            document.querySelectorAll('#hto-mode, #sa-mode, #gradient-mode, #adam-mode, #tabu-mode, #vns-mode, #grasp-mode, #ga-mode, #memetic-mode, #de-mode').forEach(btn => {
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.borderColor = 'var(--border)';
            });
            e.target.style.background = 'rgba(0, 217, 255, 0.2)';
            e.target.style.borderColor = 'var(--accent-primary)';
            
            document.querySelectorAll('[id$="-params"]').forEach(el => el.style.display = 'none');
            document.getElementById('hto-params').style.display = 'block';
        });
        
        document.getElementById('sa-mode').addEventListener('click', (e) => {
            network.setOptimizationMode('sa');
            document.querySelectorAll('#hto-mode, #sa-mode, #gradient-mode, #adam-mode, #tabu-mode, #vns-mode, #grasp-mode, #ga-mode, #memetic-mode, #de-mode').forEach(btn => {
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.borderColor = 'var(--border)';
            });
            e.target.style.background = 'rgba(0, 217, 255, 0.2)';
            e.target.style.borderColor = 'var(--accent-primary)';
            
            document.querySelectorAll('[id$="-params"]').forEach(el => el.style.display = 'none');
            document.getElementById('sa-params').style.display = 'block';
        });
        
        document.getElementById('gradient-mode').addEventListener('click', (e) => {
            network.setOptimizationMode('gradient');
            document.querySelectorAll('#hto-mode, #sa-mode, #gradient-mode, #adam-mode, #tabu-mode, #vns-mode, #grasp-mode, #ga-mode, #memetic-mode, #de-mode').forEach(btn => {
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.borderColor = 'var(--border)';
            });
            e.target.style.background = 'rgba(0, 217, 255, 0.2)';
            e.target.style.borderColor = 'var(--accent-primary)';
            
            document.querySelectorAll('[id$="-params"]').forEach(el => el.style.display = 'none');
            document.getElementById('gradient-params').style.display = 'block';
        });
        
        document.getElementById('adam-mode').addEventListener('click', (e) => {
            network.setOptimizationMode('adam');
            document.querySelectorAll('#hto-mode, #sa-mode, #gradient-mode, #adam-mode, #tabu-mode, #vns-mode, #grasp-mode, #ga-mode, #memetic-mode, #de-mode').forEach(btn => {
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.borderColor = 'var(--border)';
            });
            e.target.style.background = 'rgba(0, 217, 255, 0.2)';
            e.target.style.borderColor = 'var(--accent-primary)';
            
            // Show adam params, hide others
            document.querySelectorAll('[id$="-params"]').forEach(el => el.style.display = 'none');
            document.getElementById('adam-params').style.display = 'block';
        });
        
        document.getElementById('tabu-mode').addEventListener('click', (e) => {
            network.setOptimizationMode('tabu');
            document.querySelectorAll('#hto-mode, #sa-mode, #gradient-mode, #adam-mode, #tabu-mode, #vns-mode, #grasp-mode, #ga-mode, #memetic-mode, #de-mode').forEach(btn => {
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.borderColor = 'var(--border)';
            });
            e.target.style.background = 'rgba(0, 217, 255, 0.2)';
            e.target.style.borderColor = 'var(--accent-primary)';
            
            document.querySelectorAll('[id$="-params"]').forEach(el => el.style.display = 'none');
            document.getElementById('tabu-params').style.display = 'block';
        });
        
        document.getElementById('vns-mode').addEventListener('click', (e) => {
            network.setOptimizationMode('vns');
            document.querySelectorAll('#hto-mode, #sa-mode, #gradient-mode, #adam-mode, #tabu-mode, #vns-mode, #grasp-mode, #ga-mode, #memetic-mode, #de-mode').forEach(btn => {
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.borderColor = 'var(--border)';
            });
            e.target.style.background = 'rgba(0, 217, 255, 0.2)';
            e.target.style.borderColor = 'var(--accent-primary)';
            
            document.querySelectorAll('[id$="-params"]').forEach(el => el.style.display = 'none');
            document.getElementById('vns-params').style.display = 'block';
        });
        
        document.getElementById('grasp-mode').addEventListener('click', (e) => {
            network.setOptimizationMode('grasp');
            document.querySelectorAll('#hto-mode, #sa-mode, #gradient-mode, #adam-mode, #tabu-mode, #vns-mode, #grasp-mode, #ga-mode, #memetic-mode, #de-mode').forEach(btn => {
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.borderColor = 'var(--border)';
            });
            e.target.style.background = 'rgba(0, 217, 255, 0.2)';
            e.target.style.borderColor = 'var(--accent-primary)';
            
            document.querySelectorAll('[id$="-params"]').forEach(el => el.style.display = 'none');
            document.getElementById('grasp-params').style.display = 'block';
        });
        
        document.getElementById('ga-mode').addEventListener('click', (e) => {
            network.setOptimizationMode('ga');
            document.querySelectorAll('#hto-mode, #sa-mode, #gradient-mode, #adam-mode, #tabu-mode, #vns-mode, #grasp-mode, #ga-mode, #memetic-mode, #de-mode').forEach(btn => {
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.borderColor = 'var(--border)';
            });
            e.target.style.background = 'rgba(0, 217, 255, 0.2)';
            e.target.style.borderColor = 'var(--accent-primary)';
            
            document.querySelectorAll('[id$="-params"]').forEach(el => el.style.display = 'none');
            document.getElementById('ga-params').style.display = 'block';
        });
        
        document.getElementById('memetic-mode').addEventListener('click', (e) => {
            network.setOptimizationMode('memetic');
            document.querySelectorAll('#hto-mode, #sa-mode, #gradient-mode, #adam-mode, #tabu-mode, #vns-mode, #grasp-mode, #ga-mode, #memetic-mode, #de-mode').forEach(btn => {
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.borderColor = 'var(--border)';
            });
            e.target.style.background = 'rgba(0, 217, 255, 0.2)';
            e.target.style.borderColor = 'var(--accent-primary)';
            
            document.querySelectorAll('[id$="-params"]').forEach(el => el.style.display = 'none');
            document.getElementById('memetic-params').style.display = 'block';
        });
        
        document.getElementById('de-mode').addEventListener('click', (e) => {
            network.setOptimizationMode('de');
            document.querySelectorAll('#hto-mode, #sa-mode, #gradient-mode, #adam-mode, #tabu-mode, #vns-mode, #grasp-mode, #ga-mode, #memetic-mode, #de-mode').forEach(btn => {
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.borderColor = 'var(--border)';
            });
            e.target.style.background = 'rgba(0, 217, 255, 0.2)';
            e.target.style.borderColor = 'var(--accent-primary)';
            
            document.querySelectorAll('[id$="-params"]').forEach(el => el.style.display = 'none');
            document.getElementById('de-params').style.display = 'block';
        });
        
        // Controls
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                renderer.mode = btn.dataset.mode;
            });
        });
        
        
        document.getElementById('evolve-btn').addEventListener('click', () => {
            network.optimizeNetwork(100);
        });
        
        document.getElementById('reset-btn').addEventListener('click', () => {
            network.reset();
        });
        
        document.getElementById('auto-btn').addEventListener('click', (e) => {
            isAutoOptimizing = !isAutoOptimizing;
            e.target.textContent = isAutoOptimizing ? 'Stop Auto-Optimize' : 'Auto-Optimize';
            
            if (isAutoOptimizing) {
                autoOptimizeInterval = setInterval(() => {
                    network.optimizeNetwork(10);
                }, 100);
            } else {
                clearInterval(autoOptimizeInterval);
            }
        });
        
        // Mouse interaction - set outlet
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            network.setOutlet(x, y);
        });
        
        animate();
    </script>
</body>
</html>
