<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Objective Reservoir Optimization - Sequent Peak Algorithm</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0e14;
            --bg-secondary: #141923;
            --bg-tertiary: #1f2531;
            --text-primary: #e6edf3;
            --text-secondary: #8b95a5;
            --border: #2a3441;
            --accent-primary: #00d9ff;
            --accent-secondary: #ff006e;
            --accent-tertiary: #8b5cf6;
            --accent-green: #10b981;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 1rem;
        }

        header {
            text-align: center;
            padding: 2rem 0;
            border-bottom: 1px solid var(--border);
            margin-bottom: 1.5rem;
        }

        h1 {
            font-size: 2rem;
            color: var(--accent-primary);
            margin-bottom: 0.5rem;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 1.5rem;
        }

        .simulation-panel {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 1.5rem;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .controls-panel {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 1.5rem;
            border: 1px solid var(--border);
            overflow-y: auto;
            max-height: calc(100vh - 200px);
        }

        .control-section {
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .control-section:last-child {
            border-bottom: none;
        }

        .control-section h3 {
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--accent-primary);
            margin-bottom: 0.75rem;
        }

        .control-group {
            margin-bottom: 0.75rem;
        }

        .control-group label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="number"], input[type="text"] {
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .btn {
            width: 100%;
            padding: 0.6rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
            margin-bottom: 0.5rem;
        }

        .btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .info-box {
            background: rgba(0, 217, 255, 0.1);
            border: 1px solid rgba(0, 217, 255, 0.3);
            border-radius: 4px;
            padding: 0.75rem;
            font-size: 0.75rem;
            margin-bottom: 1rem;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .stats {
            font-size: 0.7rem;
            font-family: 'JetBrains Mono', monospace;
        }

        .stats > div {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
            border-bottom: 1px solid var(--bg-tertiary);
        }

        .stats-value {
            color: var(--accent-primary);
            font-weight: 600;
        }

        .value-display {
            color: var(--accent-primary);
            font-weight: 600;
            float: right;
        }

        .pareto-point {
            cursor: pointer;
            transition: all 0.2s;
        }

        .pareto-point:hover {
            transform: scale(1.3);
        }

        select {
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .algorithm-label {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0,0,0,0.7);
            padding: 0.3rem 0.5rem;
            border-radius: 3px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Multi-Objective Reservoir Optimization</h1>
            <div class="subtitle">Sequent Peak Algorithm ‚Ä¢ Pareto Front Analysis ‚Ä¢ Irrigation vs Municipal Demand</div>
        </header>

        <div class="main-content">
            <div class="simulation-panel">
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                    <div class="info-box">
                        <strong>üìä Sequent Peak Algorithm</strong><br>
                        <span style="font-size: 0.65rem;">
                        Analyzes cumulative demand minus inflow to find required storage. Peaks in deficit curve = storage needed. Used to determine feasible yield-storage relationships.
                        </span>
                    </div>
                    <div class="info-box">
                        <strong>üéØ Problem Formulation</strong><br>
                        <span style="font-size: 0.65rem;">
                        Two objectives: (1) Minimize Stage 2 restriction days, (2) Maximize yield. Stage 3 ban incurs 1000√ó penalty. Irrigation cuts: 25%‚Üí50%‚Üí100% at thresholds.
                        </span>
                    </div>
                    <div class="info-box">
                        <strong>ü§ñ Multi-Objective Optimizers</strong><br>
                        <span style="font-size: 0.65rem;">
                        NSGA-II: genetic evolution with Pareto ranking. Adam variants: use gradient descent with adaptive learning on decomposed/weighted objectives.
                        </span>
                    </div>
                </div>

                <div class="info-box" style="margin-bottom: 1rem;">
                    üíß Click any point on Pareto fronts to view solution details. Optimize reservoir operations with drought restrictions.
                </div>

                <div class="canvas-container" style="height: 200px; margin-bottom: 1rem;">
                    <canvas id="hydrologyCanvas"></canvas>
                </div>

                <div class="canvas-container" style="height: 300px; margin-bottom: 1rem;">
                    <canvas id="combinedParetoCanvas"></canvas>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <div class="canvas-container" style="height: 250px;">
                        <div class="algorithm-label" id="algo1-label" style="color: var(--accent-primary);">Storage 1</div>
                        <canvas id="storageCanvas1"></canvas>
                    </div>
                    <div class="canvas-container" style="height: 250px;">
                        <div class="algorithm-label" id="algo2-label" style="color: var(--accent-secondary);">Storage 2</div>
                        <canvas id="storageCanvas2"></canvas>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem;">
                    <div class="canvas-container" style="height: 250px;">
                        <div class="algorithm-label" id="algo3-label" style="color: var(--accent-tertiary);">Storage 3</div>
                        <canvas id="storageCanvas3"></canvas>
                    </div>
                    <div class="canvas-container" style="height: 250px;">
                        <div class="algorithm-label" id="algo4-label" style="color: var(--accent-green);">Storage 4</div>
                        <canvas id="storageCanvas4"></canvas>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem;">
                    <div class="canvas-container" style="height: 300px;">
                        <div class="algorithm-label" id="pareto1-label" style="color: var(--accent-primary);">Pareto Front 1</div>
                        <canvas id="paretoCanvas1"></canvas>
                    </div>
                    <div class="canvas-container" style="height: 300px;">
                        <div class="algorithm-label" id="pareto2-label" style="color: var(--accent-secondary);">Pareto Front 2</div>
                        <canvas id="paretoCanvas2"></canvas>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem;">
                    <div class="canvas-container" style="height: 300px;">
                        <div class="algorithm-label" id="pareto3-label" style="color: var(--accent-tertiary);">Pareto Front 3</div>
                        <canvas id="paretoCanvas3"></canvas>
                    </div>
                    <div class="canvas-container" style="height: 300px;">
                        <div class="algorithm-label" id="pareto4-label" style="color: var(--accent-green);">Pareto Front 4</div>
                        <canvas id="paretoCanvas4"></canvas>
                    </div>
                </div>
            </div>

            <div class="controls-panel">
                <div class="control-section">
                    <h3>Reservoir Parameters</h3>
                    <div class="control-group">
                        <label>Storage Capacity (units): <span class="value-display" id="capacity-value">100</span></label>
                        <input type="range" id="capacity" min="50" max="500" step="10" value="100">
                    </div>
                    <div class="control-group">
                        <label>Simulation Length (years): <span class="value-display" id="sim-length-value">50</span></label>
                        <input type="range" id="sim-length" min="10" max="200" step="10" value="50">
                    </div>
                    <div class="control-group">
                        <label>Log-Pearson III Skew: <span class="value-display" id="skew-value">0.0</span></label>
                        <input type="range" id="skew" min="-2" max="2" step="0.1" value="0">
                    </div>
                </div>

                <div class="control-section">
                    <h3>Demand Structure</h3>
                    <div class="control-group">
                        <label>Municipal Demand (% of capacity): <span class="value-display" id="municipal-value">40</span></label>
                        <input type="range" id="municipal" min="10" max="80" step="5" value="40">
                    </div>
                    <div class="control-group">
                        <label>Irrigation Demand (% of capacity): <span class="value-display" id="irrigation-value">60</span></label>
                        <input type="range" id="irrigation" min="10" max="100" step="5" value="60">
                    </div>
                    <div style="font-size: 0.65rem; color: var(--text-secondary); margin-top: 0.5rem;">
                        Note: Drought restriction thresholds and cutback %'s are now optimized by the algorithms (5 decision variables per solution)
                    </div>
                </div>

                <div class="control-section">
                    <h3>Optimization Mode</h3>
                    <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                        <button class="btn" id="mode-single" style="flex: 1; background: rgba(0, 217, 255, 0.2); border-color: var(--accent-primary);">Single Optimizer</button>
                        <button class="btn" id="mode-compare" style="flex: 1;">Compare 4</button>
                    </div>
                    <div id="single-algo-select" style="margin-bottom: 0.5rem;">
                        <select id="single-algo" style="width: 100%;">
                            <option value="nsga2" selected>NSGA-II</option>
                            <option value="moadam">MO-Adam</option>
                            <option value="moead">MOEA/D-Adam</option>
                            <option value="mgda">MGDA-Adam</option>
                            <option value="paretoadam">Pareto-Adam</option>
                        </select>
                    </div>
                    <div id="multi-algo-select" style="display: none;">
                        <div style="font-size: 0.7rem; color: var(--text-secondary); margin-bottom: 0.5rem;">
                            Select 4 algorithms to compare:
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.4rem;">
                            <select id="algo-1" class="algo-select">
                                <option value="nsga2" selected>NSGA-II</option>
                                <option value="moadam">MO-Adam</option>
                                <option value="moead">MOEA/D-Adam</option>
                                <option value="mgda">MGDA-Adam</option>
                                <option value="paretoadam">Pareto-Adam</option>
                            </select>
                            <select id="algo-2" class="algo-select">
                                <option value="nsga2">NSGA-II</option>
                                <option value="moadam" selected>MO-Adam</option>
                                <option value="moead">MOEA/D-Adam</option>
                                <option value="mgda">MGDA-Adam</option>
                                <option value="paretoadam">Pareto-Adam</option>
                            </select>
                            <select id="algo-3" class="algo-select">
                                <option value="nsga2">NSGA-II</option>
                                <option value="moadam">MO-Adam</option>
                                <option value="moead" selected>MOEA/D-Adam</option>
                                <option value="mgda">MGDA-Adam</option>
                                <option value="paretoadam">Pareto-Adam</option>
                            </select>
                            <select id="algo-4" class="algo-select">
                                <option value="nsga2">NSGA-II</option>
                                <option value="moadam">MO-Adam</option>
                                <option value="moead">MOEA/D-Adam</option>
                                <option value="mgda" selected>MGDA-Adam</option>
                                <option value="paretoadam">Pareto-Adam</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Algorithm Selection</h3>
                    <div class="control-group">
                        <label>Population Size: <span class="value-display" id="popsize-value">50</span></label>
                        <input type="range" id="popsize" min="20" max="200" step="10" value="50">
                    </div>
                    <div class="control-group">
                        <label>Generations: <span class="value-display" id="generations-value">100</span></label>
                        <input type="range" id="generations" min="50" max="500" step="50" value="100">
                    </div>
                </div>

                <div class="control-section">
                    <h3>Actions</h3>
                    <button class="btn" id="optimize-btn">üöÄ Run 4-Way Optimization</button>
                    <button class="btn" id="stop-btn" disabled>‚èπÔ∏è Stop</button>
                    <div id="progress-status" style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.5rem; display: none;">
                        Optimizing... <span id="progress-text">0%</span>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Performance Metrics</h3>
                    <div class="stats">
                        <div>Hypervolume: <span class="stats-value" id="hypervolume">-</span></div>
                        <div>Pareto Solutions: <span class="stats-value" id="pareto-count">-</span></div>
                        <div>Generation: <span class="stats-value" id="generation">0</span></div>
                        <div>Best Yield: <span class="stats-value" id="best-yield">-</span></div>
                        <div>Min Stage 2 Days: <span class="stats-value" id="min-stage2">-</span></div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Selected Solution</h3>
                    <div class="stats">
                        <div>Yield (%): <span class="stats-value" id="sol-yield">-</span></div>
                        <div>Stage 2 Days: <span class="stats-value" id="sol-stage2">-</span></div>
                        <div>Stage 3 Days: <span class="stats-value" id="sol-stage3">-</span></div>
                        <div>Avg Storage (%): <span class="stats-value" id="sol-storage">-</span></div>
                    </div>
                    <div style="font-size: 0.65rem; color: var(--text-secondary); margin-top: 0.5rem; border-top: 1px solid var(--bg-tertiary); padding-top: 0.5rem;">
                        <strong>Optimized Policy:</strong><br>
                        Stage 1 @ <span class="stats-value" id="sol-s1-thresh">-</span>%, cut <span class="stats-value" id="sol-s1-cut">-</span>%<br>
                        Stage 2 @ <span class="stats-value" id="sol-s2-thresh">-</span>%, cut <span class="stats-value" id="sol-s2-cut">-</span>%<br>
                        Stage 3 @ <span class="stats-value" id="sol-s3-thresh">-</span>%, cut 100%
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ====================================================================
        // STATISTICAL UTILITIES
        // ====================================================================
        
        // Standard normal random variable (Box-Muller transform)
        function randomNormal(mean = 0, std = 1) {
            let u1 = Math.random();
            let u2 = Math.random();
            let z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            return z0 * std + mean;
        }
        
        // Log-Pearson Type III distribution
        function generateLogPearsonIII(n, mean, cv, skew) {
            // Generate n samples from Log-Pearson III distribution
            // mean: mean of the data
            // cv: coefficient of variation
            // skew: skewness coefficient
            
            const stdDev = mean * cv;
            const flows = [];
            
            for (let i = 0; i < n; i++) {
                if (Math.abs(skew) < 0.01) {
                    // Lognormal approximation when skew ‚âà 0
                    const logMean = Math.log(mean) - 0.5 * Math.log(1 + cv * cv);
                    const logStd = Math.sqrt(Math.log(1 + cv * cv));
                    const logFlow = randomNormal(logMean, logStd);
                    flows.push(Math.exp(logFlow));
                } else {
                    // Wilson-Hilferty approximation for Pearson III
                    const z = randomNormal(0, 1);
                    const k = skew;
                    const y = z - k * (z * z - 1) / 6 + k * k * z * (z * z - 3) / 36;
                    const x = mean + stdDev * y;
                    flows.push(Math.max(0, x));
                }
            }
            
            return flows;
        }
        
        // ====================================================================
        // SEQUENT PEAK ALGORITHM
        // ====================================================================
        
        class ReservoirSimulation {
            constructor(capacity, flows, demand, policy) {
                this.capacity = capacity;
                this.flows = flows;
                this.demand = demand; // {municipal, irrigation}
                this.policy = policy; // {stage1Threshold, stage2Threshold, stage3Threshold, stage1Cutback, stage2Cutback}
                this.n = flows.length;
            }
            
            simulate() {
                const storage = new Array(this.n);
                const release = new Array(this.n);
                const shortage = new Array(this.n);
                const stage2Days = [];
                const stage3Days = [];
                
                storage[0] = this.capacity * 0.8; // Start at 80% full
                
                for (let t = 0; t < this.n; t++) {
                    const s = storage[t];
                    const storagePct = s / this.capacity * 100;
                    
                    // Determine restriction stage based on policy thresholds
                    let irrigationFactor = 1.0;
                    let stage = 0;
                    
                    if (storagePct < this.policy.stage3Threshold) {
                        irrigationFactor = 0; // Complete ban (100% cutback)
                        stage = 3;
                        stage3Days.push(t);
                    } else if (storagePct < this.policy.stage2Threshold) {
                        irrigationFactor = 1 - (this.policy.stage2Cutback / 100); // Policy-defined cutback
                        stage = 2;
                        stage2Days.push(t);
                    } else if (storagePct < this.policy.stage1Threshold) {
                        irrigationFactor = 1 - (this.policy.stage1Cutback / 100); // Policy-defined cutback
                        stage = 1;
                    }
                    
                    // Calculate demand with restrictions
                    const municipalDemand = this.demand.municipal;
                    const irrigationDemand = this.demand.irrigation * irrigationFactor;
                    const totalDemand = municipalDemand + irrigationDemand;
                    
                    // Release is min of demand and available water
                    const available = s + this.flows[t];
                    const actualRelease = Math.min(totalDemand, available);
                    release[t] = actualRelease;
                    
                    // Shortage
                    shortage[t] = totalDemand - actualRelease;
                    
                    // Update storage
                    const newStorage = Math.max(0, Math.min(this.capacity, s + this.flows[t] - actualRelease));
                    
                    if (t < this.n - 1) {
                        storage[t + 1] = newStorage;
                    }
                }
                
                // Calculate metrics
                const totalDemand = this.n * (this.demand.municipal + this.demand.irrigation);
                const totalRelease = release.reduce((a, b) => a + b, 0);
                const yieldPct = (totalRelease / totalDemand) * 100;
                const avgStorage = storage.reduce((a, b) => a + b, 0) / this.n;
                const avgStoragePct = (avgStorage / this.capacity) * 100;
                
                return {
                    storage,
                    release,
                    shortage,
                    yieldPct,
                    avgStoragePct,
                    stage2Days: stage2Days.length,
                    stage3Days: stage3Days.length,
                    totalShortage: shortage.reduce((a, b) => a + b, 0)
                };
            }
        }
        
        // ====================================================================
        // MULTI-OBJECTIVE PROBLEM DEFINITION
        // ====================================================================
        
        class ReservoirOptimizationProblem {
            constructor(params) {
                this.capacity = params.capacity;
                this.simLength = params.simLength;
                this.skew = params.skew;
                this.municipal = params.municipal;
                this.irrigation = params.irrigation;
                
                // Generate synthetic flows (mean = capacity)
                this.flows = generateLogPearsonIII(
                    this.simLength * 12, // Monthly timesteps
                    this.capacity / 12, // Monthly mean flow
                    0.6, // CV
                    this.skew
                );
            }
            
            evaluate(solution) {
                // Solution is 5-dimensional:
                // [stage1Threshold, stage2Threshold, stage3Threshold, stage1Cutback, stage2Cutback]
                // All thresholds are in % of capacity (0-100)
                // Cutbacks are in % (0-100)
                
                const policy = {
                    stage1Threshold: solution[0],
                    stage2Threshold: solution[1],
                    stage3Threshold: solution[2],
                    stage1Cutback: solution[3],
                    stage2Cutback: solution[4]
                };
                
                const sim = new ReservoirSimulation(
                    this.capacity,
                    this.flows,
                    {
                        municipal: this.municipal * this.capacity / 100 / 12, // Monthly
                        irrigation: this.irrigation * this.capacity / 100 / 12
                    },
                    policy
                );
                
                const result = sim.simulate();
                
                // Objectives:
                // 1. Minimize Stage 2 days (normalized)
                // 2. Maximize yield (convert to minimization: -yield)
                // 3. MASSIVE penalty for Stage 3 days
                
                const obj1 = result.stage2Days; // Minimize
                const obj2 = -result.yieldPct; // Maximize yield -> minimize -yield
                const penalty = result.stage3Days * 1000; // Severe penalty
                
                return {
                    objectives: [obj1 + penalty, obj2],
                    stage2Days: result.stage2Days,
                    stage3Days: result.stage3Days,
                    yieldPct: result.yieldPct,
                    avgStoragePct: result.avgStoragePct,
                    storage: result.storage,
                    solution: solution,
                    policy: policy
                };
            }
            
            randomSolution() {
                // Generate valid random solution
                // Ensure stage1 > stage2 > stage3
                const stage1 = 50 + Math.random() * 30; // 50-80%
                const stage2 = 30 + Math.random() * (stage1 - 30); // 30 to stage1
                const stage3 = 10 + Math.random() * (stage2 - 10); // 10 to stage2
                
                const cutback1 = 10 + Math.random() * 30; // 10-40%
                const cutback2 = cutback1 + 10 + Math.random() * 30; // Higher than cutback1
                
                return [stage1, stage2, stage3, cutback1, Math.min(cutback2, 90)];
            }
        }
        
        // ====================================================================
        // PARETO DOMINANCE
        // ====================================================================
        
        function dominates(a, b) {
            // a dominates b if a is no worse in all objectives and better in at least one
            let betterInOne = false;
            for (let i = 0; i < a.objectives.length; i++) {
                if (a.objectives[i] > b.objectives[i]) return false;
                if (a.objectives[i] < b.objectives[i]) betterInOne = true;
            }
            return betterInOne;
        }
        
        function getParetoFront(population) {
            const front = [];
            for (const individual of population) {
                let isDominated = false;
                for (const other of population) {
                    if (dominates(other, individual)) {
                        isDominated = true;
                        break;
                    }
                }
                if (!isDominated) {
                    front.push(individual);
                }
            }
            return front;
        }
        
        function crowdingDistance(front) {
            const n = front.length;
            if (n === 0) return front;
            
            const distances = new Array(n).fill(0);
            const m = front[0].objectives.length;
            
            for (let obj = 0; obj < m; obj++) {
                // Sort by objective
                const sorted = front.map((ind, idx) => ({ind, idx}))
                    .sort((a, b) => a.ind.objectives[obj] - b.ind.objectives[obj]);
                
                // Boundary points get infinite distance
                distances[sorted[0].idx] = Infinity;
                distances[sorted[n-1].idx] = Infinity;
                
                const range = sorted[n-1].ind.objectives[obj] - sorted[0].ind.objectives[obj];
                if (range > 0) {
                    for (let i = 1; i < n - 1; i++) {
                        distances[sorted[i].idx] += 
                            (sorted[i+1].ind.objectives[obj] - sorted[i-1].ind.objectives[obj]) / range;
                    }
                }
            }
            
            return front.map((ind, idx) => ({...ind, crowding: distances[idx]}));
        }
        
        // ====================================================================
        // NSGA-II ALGORITHM
        // ====================================================================
        
        class NSGAII {
            constructor(problem, popSize, generations) {
                this.problem = problem;
                this.popSize = popSize;
                this.generations = generations;
                this.population = [];
                this.paretoFronts = [];
            }
            
            initialize() {
                this.population = [];
                for (let i = 0; i < this.popSize; i++) {
                    const solution = this.problem.randomSolution();
                    const result = this.problem.evaluate(solution);
                    this.population.push(result);
                }
            }
            
            evolve() {
                const offspring = [];
                
                // Generate offspring through tournament selection and variation
                for (let i = 0; i < this.popSize; i++) {
                    // Tournament selection
                    const parent1 = this.tournamentSelect();
                    const parent2 = this.tournamentSelect();
                    
                    // Crossover
                    const child = this.crossover(parent1, parent2);
                    
                    // Mutation
                    const mutated = this.mutate(child);
                    
                    offspring.push(this.problem.evaluate(mutated));
                }
                
                // Combine parents and offspring
                const combined = [...this.population, ...offspring];
                
                // Non-dominated sorting and crowding distance
                this.population = this.selectNextGeneration(combined);
            }
            
            tournamentSelect() {
                const i1 = Math.floor(Math.random() * this.population.length);
                const i2 = Math.floor(Math.random() * this.population.length);
                
                if (dominates(this.population[i1], this.population[i2])) {
                    return this.population[i1].solution;
                } else if (dominates(this.population[i2], this.population[i1])) {
                    return this.population[i2].solution;
                } else {
                    return Math.random() < 0.5 ? this.population[i1].solution : this.population[i2].solution;
                }
            }
            
            crossover(p1, p2) {
                // SBX crossover for each variable
                const child = new Array(5);
                for (let i = 0; i < 5; i++) {
                    if (Math.random() < 0.9) {
                        const beta = Math.random() < 0.5 ? 
                            Math.pow(2 * Math.random(), 1/3) : 
                            Math.pow(0.5 / (1 - Math.random()), 1/3);
                        child[i] = 0.5 * ((1 + beta) * p1[i] + (1 - beta) * p2[i]);
                    } else {
                        child[i] = p1[i];
                    }
                }
                return this.ensureValid(child);
            }
            
            mutate(solution) {
                const mutated = [...solution];
                for (let i = 0; i < 5; i++) {
                    if (Math.random() < 0.1) {
                        mutated[i] += (Math.random() - 0.5) * 20;
                    }
                }
                return this.ensureValid(mutated);
            }
            
            ensureValid(solution) {
                // Ensure thresholds are ordered and in bounds
                solution[0] = Math.max(40, Math.min(90, solution[0])); // stage1: 40-90%
                solution[1] = Math.max(20, Math.min(solution[0] - 5, solution[1])); // stage2 < stage1
                solution[2] = Math.max(5, Math.min(solution[1] - 5, solution[2])); // stage3 < stage2
                solution[3] = Math.max(5, Math.min(50, solution[3])); // cutback1: 5-50%
                solution[4] = Math.max(solution[3] + 5, Math.min(95, solution[4])); // cutback2 > cutback1
                return solution;
            }
            
            selectNextGeneration(combined) {
                const fronts = [];
                let remaining = [...combined];
                
                while (remaining.length > 0) {
                    const front = getParetoFront(remaining);
                    fronts.push(crowdingDistance(front));
                    remaining = remaining.filter(ind => !front.includes(ind));
                }
                
                this.paretoFronts = fronts;
                
                // Select individuals for next generation
                const selected = [];
                for (const front of fronts) {
                    if (selected.length + front.length <= this.popSize) {
                        selected.push(...front);
                    } else {
                        // Sort by crowding distance and fill remaining slots
                        const sorted = front.sort((a, b) => b.crowding - a.crowding);
                        selected.push(...sorted.slice(0, this.popSize - selected.length));
                        break;
                    }
                }
                
                return selected;
            }
            
            getParetoFront() {
                return this.paretoFronts[0] || [];
            }
        }
        
        // ====================================================================
        // MO-ADAM ALGORITHM
        // ====================================================================
        
        class MOAdam {
            constructor(problem, popSize, generations) {
                this.problem = problem;
                this.popSize = popSize;
                this.generations = generations;
                this.population = [];
                this.m = []; // First moment
                this.v = []; // Second moment
                this.t = 0;
                this.beta1 = 0.9;
                this.beta2 = 0.999;
                this.eps = 1e-8;
                this.alpha = 0.5;
            }
            
            initialize() {
                this.population = [];
                this.m = [];
                this.v = [];
                
                for (let i = 0; i < this.popSize; i++) {
                    const solution = this.problem.randomSolution();
                    this.population.push(this.problem.evaluate(solution));
                    this.m.push(new Array(5).fill(0));
                    this.v.push(new Array(5).fill(0));
                }
            }
            
            evolve() {
                this.t++;
                
                for (let i = 0; i < this.popSize; i++) {
                    const current = this.population[i].solution;
                    const grad = new Array(5);
                    
                    // Compute gradient for each variable
                    for (let j = 0; j < 5; j++) {
                        const delta = 0.5;
                        const perturbed = [...current];
                        perturbed[j] += delta;
                        
                        const fPlus = this.problem.evaluate(this.ensureValid(perturbed));
                        perturbed[j] = current[j] - delta;
                        const fMinus = this.problem.evaluate(this.ensureValid(perturbed));
                        
                        // Multi-objective gradient (weighted sum)
                        grad[j] = ((fPlus.objectives[0] + fPlus.objectives[1]) - 
                                  (fMinus.objectives[0] + fMinus.objectives[1])) / (2 * delta);
                    }
                    
                    // Adam update for each variable
                    const newSolution = [...current];
                    for (let j = 0; j < 5; j++) {
                        this.m[i][j] = this.beta1 * this.m[i][j] + (1 - this.beta1) * grad[j];
                        this.v[i][j] = this.beta2 * this.v[i][j] + (1 - this.beta2) * grad[j] * grad[j];
                        
                        const mHat = this.m[i][j] / (1 - Math.pow(this.beta1, this.t));
                        const vHat = this.v[i][j] / (1 - Math.pow(this.beta2, this.t));
                        
                        newSolution[j] = current[j] - this.alpha * mHat / (Math.sqrt(vHat) + this.eps);
                    }
                    
                    this.population[i] = this.problem.evaluate(this.ensureValid(newSolution));
                }
            }
            
            ensureValid(solution) {
                solution[0] = Math.max(40, Math.min(90, solution[0]));
                solution[1] = Math.max(20, Math.min(solution[0] - 5, solution[1]));
                solution[2] = Math.max(5, Math.min(solution[1] - 5, solution[2]));
                solution[3] = Math.max(5, Math.min(50, solution[3]));
                solution[4] = Math.max(solution[3] + 5, Math.min(95, solution[4]));
                return solution;
            }
            
            getParetoFront() {
                return getParetoFront(this.population);
            }
        }
        
        // ====================================================================
        // MOEA/D-ADAM ALGORITHM
        // ====================================================================
        
        class MOEADAdam {
            constructor(problem, popSize, generations) {
                this.problem = problem;
                this.popSize = popSize;
                this.generations = generations;
                this.population = [];
                this.weights = [];
                this.m = [];
                this.v = [];
                this.t = 0;
                
                // Generate weight vectors
                for (let i = 0; i < popSize; i++) {
                    const w1 = i / (popSize - 1);
                    const w2 = 1 - w1;
                    this.weights.push([w1, w2]);
                }
            }
            
            initialize() {
                this.population = [];
                this.m = [];
                this.v = [];
                
                for (let i = 0; i < this.popSize; i++) {
                    const solution = this.problem.randomSolution();
                    this.population.push(this.problem.evaluate(solution));
                    this.m.push(new Array(5).fill(0));
                    this.v.push(new Array(5).fill(0));
                }
            }
            
            evolve() {
                this.t++;
                
                for (let i = 0; i < this.popSize; i++) {
                    const weight = this.weights[i];
                    const current = this.population[i].solution;
                    const grad = new Array(5);
                    
                    for (let j = 0; j < 5; j++) {
                        const delta = 0.5;
                        const perturbed = [...current];
                        perturbed[j] += delta;
                        
                        const fPlus = this.problem.evaluate(this.ensureValid(perturbed));
                        perturbed[j] = current[j] - delta;
                        const fMinus = this.problem.evaluate(this.ensureValid(perturbed));
                        
                        // Tchebycheff gradient
                        const gradPlus = Math.max(weight[0] * fPlus.objectives[0], weight[1] * fPlus.objectives[1]);
                        const gradMinus = Math.max(weight[0] * fMinus.objectives[0], weight[1] * fMinus.objectives[1]);
                        grad[j] = (gradPlus - gradMinus) / (2 * delta);
                    }
                    
                    const newSolution = [...current];
                    for (let j = 0; j < 5; j++) {
                        this.m[i][j] = 0.9 * this.m[i][j] + 0.1 * grad[j];
                        this.v[i][j] = 0.999 * this.v[i][j] + 0.001 * grad[j] * grad[j];
                        
                        const mHat = this.m[i][j] / (1 - Math.pow(0.9, this.t));
                        const vHat = this.v[i][j] / (1 - Math.pow(0.999, this.t));
                        
                        newSolution[j] = current[j] - 0.5 * mHat / (Math.sqrt(vHat) + 1e-8);
                    }
                    
                    this.population[i] = this.problem.evaluate(this.ensureValid(newSolution));
                }
            }
            
            ensureValid(solution) {
                solution[0] = Math.max(40, Math.min(90, solution[0]));
                solution[1] = Math.max(20, Math.min(solution[0] - 5, solution[1]));
                solution[2] = Math.max(5, Math.min(solution[1] - 5, solution[2]));
                solution[3] = Math.max(5, Math.min(50, solution[3]));
                solution[4] = Math.max(solution[3] + 5, Math.min(95, solution[4]));
                return solution;
            }
            
            getParetoFront() {
                return getParetoFront(this.population);
            }
        }
        
        // ====================================================================
        // MGDA-ADAM ALGORITHM
        // ====================================================================
        
        class MGDAAdam {
            constructor(problem, popSize, generations) {
                this.problem = problem;
                this.popSize = popSize;
                this.generations = generations;
                this.population = [];
            }
            
            initialize() {
                this.population = [];
                for (let i = 0; i < this.popSize; i++) {
                    const solution = this.problem.randomSolution();
                    this.population.push(this.problem.evaluate(solution));
                }
            }
            
            evolve() {
                for (let i = 0; i < this.popSize; i++) {
                    const current = this.population[i].solution;
                    const grad1 = new Array(5);
                    const grad2 = new Array(5);
                    
                    // Compute gradients for both objectives
                    for (let j = 0; j < 5; j++) {
                        const delta = 0.5;
                        const perturbed = [...current];
                        perturbed[j] += delta;
                        
                        const fPlus = this.problem.evaluate(this.ensureValid(perturbed));
                        perturbed[j] = current[j] - delta;
                        const fMinus = this.problem.evaluate(this.ensureValid(perturbed));
                        
                        grad1[j] = (fPlus.objectives[0] - fMinus.objectives[0]) / (2 * delta);
                        grad2[j] = (fPlus.objectives[1] - fMinus.objectives[1]) / (2 * delta);
                    }
                    
                    // MGDA: find compromise direction (simplified: equal weighting)
                    const newSolution = [...current];
                    for (let j = 0; j < 5; j++) {
                        const compromiseGrad = (grad1[j] + grad2[j]) / 2;
                        newSolution[j] = current[j] - 0.3 * compromiseGrad;
                    }
                    
                    this.population[i] = this.problem.evaluate(this.ensureValid(newSolution));
                }
            }
            
            ensureValid(solution) {
                solution[0] = Math.max(40, Math.min(90, solution[0]));
                solution[1] = Math.max(20, Math.min(solution[0] - 5, solution[1]));
                solution[2] = Math.max(5, Math.min(solution[1] - 5, solution[2]));
                solution[3] = Math.max(5, Math.min(50, solution[3]));
                solution[4] = Math.max(solution[3] + 5, Math.min(95, solution[4]));
                return solution;
            }
            
            getParetoFront() {
                return getParetoFront(this.population);
            }
        }
        
        // ====================================================================
        // PARETO-ADAM ALGORITHM
        // ====================================================================
        
        class ParetoAdam {
            constructor(problem, popSize, generations) {
                this.problem = problem;
                this.popSize = popSize;
                this.generations = generations;
                this.population = [];
            }
            
            initialize() {
                this.population = [];
                for (let i = 0; i < this.popSize; i++) {
                    const solution = this.problem.randomSolution();
                    this.population.push(this.problem.evaluate(solution));
                }
            }
            
            evolve() {
                // Get current Pareto front
                const front = getParetoFront(this.population);
                
                for (let i = 0; i < this.popSize; i++) {
                    const current = this.population[i].solution;
                    
                    // Weight based on distance to Pareto front
                    let minDist = Infinity;
                    for (const member of front) {
                        const dist = Math.sqrt(
                            Math.pow(this.population[i].objectives[0] - member.objectives[0], 2) +
                            Math.pow(this.population[i].objectives[1] - member.objectives[1], 2)
                        );
                        minDist = Math.min(minDist, dist);
                    }
                    
                    const weight = 1 / (1 + minDist);
                    
                    // Gradient with Pareto-based weighting
                    const grad = new Array(5);
                    for (let j = 0; j < 5; j++) {
                        const delta = 0.5;
                        const perturbed = [...current];
                        perturbed[j] += delta;
                        
                        const fPlus = this.problem.evaluate(this.ensureValid(perturbed));
                        perturbed[j] = current[j] - delta;
                        const fMinus = this.problem.evaluate(this.ensureValid(perturbed));
                        
                        grad[j] = ((fPlus.objectives[0] + fPlus.objectives[1]) - 
                                  (fMinus.objectives[0] + fMinus.objectives[1])) / (2 * delta);
                    }
                    
                    const newSolution = [...current];
                    for (let j = 0; j < 5; j++) {
                        newSolution[j] = current[j] - 0.3 * weight * grad[j];
                    }
                    
                    this.population[i] = this.problem.evaluate(this.ensureValid(newSolution));
                }
            }
            
            ensureValid(solution) {
                solution[0] = Math.max(40, Math.min(90, solution[0]));
                solution[1] = Math.max(20, Math.min(solution[0] - 5, solution[1]));
                solution[2] = Math.max(5, Math.min(solution[1] - 5, solution[2]));
                solution[3] = Math.max(5, Math.min(50, solution[3]));
                solution[4] = Math.max(solution[3] + 5, Math.min(95, solution[4]));
                return solution;
            }
            
            getParetoFront() {
                return getParetoFront(this.population);
            }
        }
        
        // ====================================================================
        // VISUALIZATION
        // ====================================================================
        
        class HydrologyPlotter {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.flows = [];
                this.capacity = 100;
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }
            
            update(flows, capacity) {
                this.flows = flows;
                this.capacity = capacity;
                this.render();
            }
            
            render() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const padding = { left: 50, right: 10, top: 20, bottom: 30 };
                
                // Clear
                this.ctx.fillStyle = '#0a0e14';
                this.ctx.fillRect(0, 0, width, height);
                
                if (this.flows.length === 0) {
                    this.ctx.fillStyle = '#8b95a5';
                    this.ctx.font = '11px sans-serif';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('Run optimization to see hydrology', width/2, height/2);
                    return;
                }
                
                const plotWidth = width - padding.left - padding.right;
                const plotHeight = height - padding.top - padding.bottom;
                
                // Find max flow for scaling
                const maxFlow = Math.max(...this.flows, this.capacity / 12);
                const minFlow = 0;
                
                const mapX = (i) => padding.left + (i / this.flows.length) * plotWidth;
                const mapY = (val) => padding.top + plotHeight - ((val - minFlow) / (maxFlow - minFlow)) * plotHeight;
                
                // Draw axes
                this.ctx.strokeStyle = '#2a3441';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(padding.left, padding.top);
                this.ctx.lineTo(padding.left, height - padding.bottom);
                this.ctx.lineTo(width - padding.right, height - padding.bottom);
                this.ctx.stroke();
                
                // Draw capacity line (dotted)
                const avgMonthlyCapacity = this.capacity / 12;
                const capacityY = mapY(avgMonthlyCapacity);
                
                this.ctx.strokeStyle = '#ff006e';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(padding.left, capacityY);
                this.ctx.lineTo(width - padding.right, capacityY);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                
                // Fill areas above and below capacity
                this.ctx.globalAlpha = 0.3;
                
                for (let i = 0; i < this.flows.length - 1; i++) {
                    const x1 = mapX(i);
                    const x2 = mapX(i + 1);
                    const y1 = mapY(this.flows[i]);
                    const y2 = mapY(this.flows[i + 1]);
                    
                    if (this.flows[i] > avgMonthlyCapacity || this.flows[i + 1] > avgMonthlyCapacity) {
                        // Wet period - fill above capacity line
                        this.ctx.fillStyle = '#00d9ff';
                        this.ctx.beginPath();
                        this.ctx.moveTo(x1, capacityY);
                        this.ctx.lineTo(x1, y1);
                        this.ctx.lineTo(x2, y2);
                        this.ctx.lineTo(x2, capacityY);
                        this.ctx.closePath();
                        this.ctx.fill();
                    } else {
                        // Drought period - fill below capacity line
                        this.ctx.fillStyle = '#f59e0b';
                        this.ctx.beginPath();
                        this.ctx.moveTo(x1, capacityY);
                        this.ctx.lineTo(x1, y1);
                        this.ctx.lineTo(x2, y2);
                        this.ctx.lineTo(x2, capacityY);
                        this.ctx.closePath();
                        this.ctx.fill();
                    }
                }
                
                this.ctx.globalAlpha = 1.0;
                
                // Draw flow line
                this.ctx.strokeStyle = '#e6edf3';
                this.ctx.lineWidth = 1.5;
                this.ctx.beginPath();
                
                this.flows.forEach((flow, i) => {
                    const x = mapX(i);
                    const y = mapY(flow);
                    
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                });
                this.ctx.stroke();
                
                // Labels
                this.ctx.fillStyle = '#8b95a5';
                this.ctx.font = '10px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Time (months)', width/2, height - 5);
                
                this.ctx.save();
                this.ctx.translate(15, height/2);
                this.ctx.rotate(-Math.PI/2);
                this.ctx.fillText('Inflow', 0, 0);
                this.ctx.restore();
                
                // Legend
                this.ctx.textAlign = 'left';
                this.ctx.fillStyle = '#00d9ff';
                this.ctx.fillText('‚óè Wet Period', width - 150, 15);
                this.ctx.fillStyle = '#f59e0b';
                this.ctx.fillText('‚óè Drought', width - 150, 30);
                this.ctx.fillStyle = '#ff006e';
                this.ctx.fillText('--- Avg Capacity', width - 150, 45);
            }
        }
        
        class StoragePlotter {
            constructor(canvas, color) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.color = color;
                this.storage = [];
                this.capacity = 100;
                this.policy = null;
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }
            
            update(storage, capacity, policy) {
                this.storage = storage;
                this.capacity = capacity;
                this.policy = policy;
                this.render();
            }
            
            render() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const padding = { left: 50, right: 10, top: 30, bottom: 30 };
                
                // Clear
                this.ctx.fillStyle = '#0a0e14';
                this.ctx.fillRect(0, 0, width, height);
                
                if (this.storage.length === 0) {
                    this.ctx.fillStyle = '#8b95a5';
                    this.ctx.font = '11px sans-serif';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('No solution selected', width/2, height/2);
                    return;
                }
                
                const plotWidth = width - padding.left - padding.right;
                const plotHeight = height - padding.top - padding.bottom;
                
                const mapX = (i) => padding.left + (i / this.storage.length) * plotWidth;
                const mapY = (val) => padding.top + (1 - val / this.capacity) * plotHeight;
                
                // Draw axes
                this.ctx.strokeStyle = '#2a3441';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(padding.left, padding.top);
                this.ctx.lineTo(padding.left, height - padding.bottom);
                this.ctx.lineTo(width - padding.right, height - padding.bottom);
                this.ctx.stroke();
                
                // Draw threshold lines if policy is available
                if (this.policy) {
                    const thresholds = [
                        { val: this.policy.stage1Threshold, color: '#10b981', label: 'S1' },
                        { val: this.policy.stage2Threshold, color: '#f59e0b', label: 'S2' },
                        { val: this.policy.stage3Threshold, color: '#ff006e', label: 'S3' }
                    ];
                    
                    this.ctx.setLineDash([3, 3]);
                    this.ctx.lineWidth = 1;
                    thresholds.forEach(thresh => {
                        const y = mapY(this.capacity * thresh.val / 100);
                        this.ctx.strokeStyle = thresh.color;
                        this.ctx.beginPath();
                        this.ctx.moveTo(padding.left, y);
                        this.ctx.lineTo(width - padding.right, y);
                        this.ctx.stroke();
                        
                        this.ctx.fillStyle = thresh.color;
                        this.ctx.font = '9px sans-serif';
                        this.ctx.textAlign = 'right';
                        this.ctx.fillText(thresh.label, padding.left - 5, y + 3);
                    });
                    this.ctx.setLineDash([]);
                }
                
                // Draw storage line
                this.ctx.strokeStyle = this.color;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                this.storage.forEach((val, i) => {
                    const x = mapX(i);
                    const y = mapY(val);
                    
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                });
                this.ctx.stroke();
                
                // Labels
                this.ctx.fillStyle = '#8b95a5';
                this.ctx.font = '10px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Time (months)', width/2, height - 5);
                
                this.ctx.save();
                this.ctx.translate(15, height/2);
                this.ctx.rotate(-Math.PI/2);
                this.ctx.fillText('Storage', 0, 0);
                this.ctx.restore();
            }
        }
        
        class CombinedParetoPlotter {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.fronts = [[], [], [], []];
                this.colors = ['#00d9ff', '#ff006e', '#8b5cf6', '#10b981'];
                this.symbols = ['circle', 'square', 'triangle', 'diamond'];
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }
            
            update(fronts) {
                this.fronts = fronts;
                this.render();
            }
            
            drawSymbol(x, y, symbol, color, size = 5) {
                this.ctx.fillStyle = color;
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 2;
                
                switch(symbol) {
                    case 'circle':
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, size, 0, 2 * Math.PI);
                        this.ctx.fill();
                        break;
                    case 'square':
                        this.ctx.fillRect(x - size, y - size, size * 2, size * 2);
                        break;
                    case 'triangle':
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, y - size);
                        this.ctx.lineTo(x + size, y + size);
                        this.ctx.lineTo(x - size, y + size);
                        this.ctx.closePath();
                        this.ctx.fill();
                        break;
                    case 'diamond':
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, y - size);
                        this.ctx.lineTo(x + size, y);
                        this.ctx.lineTo(x, y + size);
                        this.ctx.lineTo(x - size, y);
                        this.ctx.closePath();
                        this.ctx.fill();
                        break;
                }
            }
            
            render() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                // Clear
                this.ctx.fillStyle = '#0a0e14';
                this.ctx.fillRect(0, 0, width, height);
                
                const allSolutions = this.fronts.flat();
                
                if (allSolutions.length === 0) {
                    this.ctx.fillStyle = '#8b95a5';
                    this.ctx.font = '11px sans-serif';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('Combined Pareto Fronts', width/2, height/2);
                    return;
                }
                
                const padding = { left: 60, right: 120, top: 40, bottom: 50 };
                const plotWidth = width - padding.left - padding.right;
                const plotHeight = height - padding.top - padding.bottom;
                
                // Get data ranges
                const stage2Values = allSolutions.map(s => s.stage2Days);
                const yieldValues = allSolutions.map(s => s.yieldPct);
                
                const minStage2 = Math.min(...stage2Values);
                const maxStage2 = Math.max(...stage2Values);
                const minYield = Math.min(...yieldValues);
                const maxYield = Math.max(...yieldValues);
                
                const stage2Range = (maxStage2 - minStage2) || 1;
                const yieldRange = (maxYield - minYield) || 1;
                
                const mapX = (val) => padding.left + ((val - minStage2) / stage2Range) * plotWidth;
                const mapY = (val) => padding.top + plotHeight - ((val - minYield) / yieldRange) * plotHeight;
                
                // Draw axes
                this.ctx.strokeStyle = '#2a3441';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(padding.left, padding.top);
                this.ctx.lineTo(padding.left, height - padding.bottom);
                this.ctx.lineTo(width - padding.right, height - padding.bottom);
                this.ctx.stroke();
                
                // Grid
                this.ctx.strokeStyle = '#1a2332';
                this.ctx.lineWidth = 0.5;
                for (let i = 0; i <= 5; i++) {
                    const y = padding.top + (plotHeight * i / 5);
                    this.ctx.beginPath();
                    this.ctx.moveTo(padding.left, y);
                    this.ctx.lineTo(width - padding.right, y);
                    this.ctx.stroke();
                }
                
                // Labels
                this.ctx.fillStyle = '#8b95a5';
                this.ctx.font = '11px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Stage 2 Days (Minimize)', width/2, height - 10);
                
                this.ctx.save();
                this.ctx.translate(20, height/2);
                this.ctx.rotate(-Math.PI/2);
                this.ctx.fillText('Yield % (Maximize)', 0, 0);
                this.ctx.restore();
                
                // Title
                this.ctx.font = '12px sans-serif';
                this.ctx.fillStyle = '#e6edf3';
                this.ctx.fillText('Combined Pareto Fronts', width/2, 20);
                
                // Draw each front with different symbols
                this.fronts.forEach((front, idx) => {
                    front.forEach(solution => {
                        const x = mapX(solution.stage2Days);
                        const y = mapY(solution.yieldPct);
                        this.drawSymbol(x, y, this.symbols[idx], this.colors[idx]);
                    });
                });
                
                // Legend
                const algoNames = ['NSGA-II', 'MO-Adam', 'MOEA/D', 'MGDA'];
                this.ctx.textAlign = 'left';
                this.ctx.font = '10px sans-serif';
                
                algoNames.forEach((name, idx) => {
                    const legendY = padding.top + idx * 25;
                    this.drawSymbol(width - padding.right + 15, legendY, this.symbols[idx], this.colors[idx]);
                    this.ctx.fillStyle = '#8b95a5';
                    this.ctx.fillText(name, width - padding.right + 25, legendY + 4);
                });
            }
        }
        
        class ParetoPlotter {
            constructor(canvas, algorithmName) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.algorithmName = algorithmName;
                this.paretoFront = [];
                this.selectedSolution = null;
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // Click to select solution
                canvas.addEventListener('click', (e) => this.handleClick(e));
            }
            
            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }
            
            update(paretoFront) {
                this.paretoFront = paretoFront;
                this.render();
            }
            
            handleClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Find closest point
                let minDist = Infinity;
                let closest = null;
                
                for (const solution of this.paretoFront) {
                    const px = this.mapX(solution.objectives[0]);
                    const py = this.mapY(-solution.objectives[1]); // Negate for yield
                    const dist = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
                    if (dist < 10 && dist < minDist) {
                        minDist = dist;
                        closest = solution;
                    }
                }
                
                if (closest) {
                    this.selectedSolution = closest;
                    this.render();
                    updateSolutionStats(closest);
                }
            }
            
            mapX(value) {
                const padding = 40;
                const width = this.canvas.width;
                if (this.paretoFront.length === 0) return padding;
                
                const values = this.paretoFront.map(s => s.objectives[0]);
                const min = Math.min(...values);
                const max = Math.max(...values);
                const range = max - min || 1;
                
                return padding + ((value - min) / range) * (width - 2 * padding);
            }
            
            mapY(value) {
                const padding = 40;
                const height = this.canvas.height;
                if (this.paretoFront.length === 0) return height - padding;
                
                const values = this.paretoFront.map(s => -s.objectives[1]);
                const min = Math.min(...values);
                const max = Math.max(...values);
                const range = max - min || 1;
                
                return height - padding - ((value - min) / range) * (height - 2 * padding);
            }
            
            render() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                // Clear
                this.ctx.fillStyle = '#0a0e14';
                this.ctx.fillRect(0, 0, width, height);
                
                if (this.paretoFront.length === 0) {
                    this.ctx.fillStyle = '#8b95a5';
                    this.ctx.font = '11px sans-serif';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('No solutions yet', width/2, height/2);
                    return;
                }
                
                const padding = { left: 50, right: 20, top: 30, bottom: 40 };
                const plotWidth = width - padding.left - padding.right;
                const plotHeight = height - padding.top - padding.bottom;
                
                // Get data ranges
                const stage2Values = this.paretoFront.map(s => s.stage2Days || s.objectives[0]);
                const yieldValues = this.paretoFront.map(s => s.yieldPct || -s.objectives[1]);
                
                const minStage2 = Math.min(...stage2Values);
                const maxStage2 = Math.max(...stage2Values);
                const minYield = Math.min(...yieldValues);
                const maxYield = Math.max(...yieldValues);
                
                // Add padding to ranges
                const stage2Range = (maxStage2 - minStage2) || 1;
                const yieldRange = (maxYield - minYield) || 1;
                
                const mapX = (val) => {
                    return padding.left + ((val - minStage2) / stage2Range) * plotWidth;
                };
                
                const mapY = (val) => {
                    return padding.top + plotHeight - ((val - minYield) / yieldRange) * plotHeight;
                };
                
                // Draw axes
                this.ctx.strokeStyle = '#2a3441';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(padding.left, padding.top);
                this.ctx.lineTo(padding.left, height - padding.bottom);
                this.ctx.lineTo(width - padding.right, height - padding.bottom);
                this.ctx.stroke();
                
                // Grid lines
                this.ctx.strokeStyle = '#1a2332';
                this.ctx.lineWidth = 0.5;
                for (let i = 0; i <= 5; i++) {
                    const y = padding.top + (plotHeight * i / 5);
                    this.ctx.beginPath();
                    this.ctx.moveTo(padding.left, y);
                    this.ctx.lineTo(width - padding.right, y);
                    this.ctx.stroke();
                }
                
                // Labels
                this.ctx.fillStyle = '#8b95a5';
                this.ctx.font = '10px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Stage 2 Days', width/2, height - 5);
                
                this.ctx.textAlign = 'right';
                this.ctx.fillText(minStage2.toFixed(0), padding.left - 5, height - padding.bottom + 15);
                this.ctx.fillText(maxStage2.toFixed(0), width - padding.right + 15, height - padding.bottom + 15);
                
                this.ctx.save();
                this.ctx.translate(15, height/2);
                this.ctx.rotate(-Math.PI/2);
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Yield (%)', 0, 0);
                this.ctx.restore();
                
                this.ctx.textAlign = 'left';
                this.ctx.fillText(minYield.toFixed(0), 5, height - padding.bottom);
                this.ctx.fillText(maxYield.toFixed(0), 5, padding.top + 10);
                
                // Sort by stage 2 days for line drawing
                const sorted = [...this.paretoFront].sort((a, b) => 
                    (a.stage2Days || a.objectives[0]) - (b.stage2Days || b.objectives[0])
                );
                
                // Draw Pareto front line
                this.ctx.strokeStyle = '#00d9ff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                sorted.forEach((solution, i) => {
                    const x = mapX(solution.stage2Days || solution.objectives[0]);
                    const y = mapY(solution.yieldPct || -solution.objectives[1]);
                    
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                });
                this.ctx.stroke();
                
                // Draw points
                this.paretoFront.forEach(solution => {
                    const x = mapX(solution.stage2Days || solution.objectives[0]);
                    const y = mapY(solution.yieldPct || -solution.objectives[1]);
                    
                    this.ctx.fillStyle = solution === this.selectedSolution ? '#ff006e' : '#00d9ff';
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, solution === this.selectedSolution ? 6 : 4, 0, 2 * Math.PI);
                    this.ctx.fill();
                });
            }
        }
        
        // ====================================================================
        // APPLICATION
        // ====================================================================
        
        const hydrologyPlotter = new HydrologyPlotter(document.getElementById('hydrologyCanvas'));
        const combinedParetoPlotter = new CombinedParetoPlotter(document.getElementById('combinedParetoCanvas'));
        
        const storagePlotters = [
            new StoragePlotter(document.getElementById('storageCanvas1'), '#00d9ff'),
            new StoragePlotter(document.getElementById('storageCanvas2'), '#ff006e'),
            new StoragePlotter(document.getElementById('storageCanvas3'), '#8b5cf6'),
            new StoragePlotter(document.getElementById('storageCanvas4'), '#10b981')
        ];
        
        const plotters = [
            new ParetoPlotter(document.getElementById('paretoCanvas1'), 'Algorithm 1'),
            new ParetoPlotter(document.getElementById('paretoCanvas2'), 'Algorithm 2'),
            new ParetoPlotter(document.getElementById('paretoCanvas3'), 'Algorithm 3'),
            new ParetoPlotter(document.getElementById('paretoCanvas4'), 'Algorithm 4')
        ];
        
        let algorithms = [];
        let isOptimizing = false;
        let currentGeneration = 0;
        let currentProblem = null;
        let optimizationMode = 'single'; // 'single' or 'compare'
        
        // Mode switching
        document.getElementById('mode-single').addEventListener('click', () => {
            optimizationMode = 'single';
            document.getElementById('mode-single').style.background = 'rgba(0, 217, 255, 0.2)';
            document.getElementById('mode-single').style.borderColor = 'var(--accent-primary)';
            document.getElementById('mode-compare').style.background = 'var(--bg-tertiary)';
            document.getElementById('mode-compare').style.borderColor = 'var(--border)';
            document.getElementById('single-algo-select').style.display = 'block';
            document.getElementById('multi-algo-select').style.display = 'none';
        });
        
        document.getElementById('mode-compare').addEventListener('click', () => {
            optimizationMode = 'compare';
            document.getElementById('mode-compare').style.background = 'rgba(0, 217, 255, 0.2)';
            document.getElementById('mode-compare').style.borderColor = 'var(--accent-primary)';
            document.getElementById('mode-single').style.background = 'var(--bg-tertiary)';
            document.getElementById('mode-single').style.borderColor = 'var(--border)';
            document.getElementById('single-algo-select').style.display = 'none';
            document.getElementById('multi-algo-select').style.display = 'block';
        });
        
        function updateSolutionStats(solution) {
            if (!solution) return;
            
            document.getElementById('sol-yield').textContent = solution.yieldPct.toFixed(1);
            document.getElementById('sol-stage2').textContent = solution.stage2Days;
            document.getElementById('sol-stage3').textContent = solution.stage3Days;
            document.getElementById('sol-storage').textContent = solution.avgStoragePct.toFixed(1);
            
            // Update optimized policy parameters
            if (solution.policy) {
                document.getElementById('sol-s1-thresh').textContent = solution.policy.stage1Threshold.toFixed(0);
                document.getElementById('sol-s1-cut').textContent = solution.policy.stage1Cutback.toFixed(0);
                document.getElementById('sol-s2-thresh').textContent = solution.policy.stage2Threshold.toFixed(0);
                document.getElementById('sol-s2-cut').textContent = solution.policy.stage2Cutback.toFixed(0);
                document.getElementById('sol-s3-thresh').textContent = solution.policy.stage3Threshold.toFixed(0);
            }
        }
        
        async function runOptimization() {
            if (isOptimizing) return;
            
            isOptimizing = true;
            document.getElementById('optimize-btn').disabled = true;
            document.getElementById('stop-btn').disabled = false;
            document.getElementById('progress-status').style.display = 'block';
            
            // Get parameters
            const params = {
                capacity: parseFloat(document.getElementById('capacity').value),
                simLength: parseInt(document.getElementById('sim-length').value),
                skew: parseFloat(document.getElementById('skew').value),
                municipal: parseFloat(document.getElementById('municipal').value),
                irrigation: parseFloat(document.getElementById('irrigation').value),
                restrictions: {
                    stage1: parseFloat(document.getElementById('stage1').value),
                    stage2: parseFloat(document.getElementById('stage2').value),
                    stage3: parseFloat(document.getElementById('stage3').value)
                }
            };
            
            const popSize = parseInt(document.getElementById('popsize').value);
            const generations = parseInt(document.getElementById('generations').value);
            
            // Create problem
            currentProblem = new ReservoirOptimizationProblem(params);
            
            // Update hydrology plot with generated flows
            hydrologyPlotter.update(currentProblem.flows, currentProblem.capacity);
            
            // Get selected algorithms
            const algoSelections = [
                document.getElementById('algo-1').value,
                document.getElementById('algo-2').value,
                document.getElementById('algo-3').value,
                document.getElementById('algo-4').value
            ];
            
            const algoNames = {
                'nsga2': 'NSGA-II',
                'moadam': 'MO-Adam',
                'moead': 'MOEA/D-Adam',
                'mgda': 'MGDA-Adam',
                'paretoadam': 'Pareto-Adam'
            };
            
            // Update labels
            for (let i = 0; i < 4; i++) {
                document.getElementById(`algo${i+1}-label`).textContent = algoNames[algoSelections[i]];
            }
            
            // Create algorithms
            algorithms = algoSelections.map(algo => {
                switch(algo) {
                    case 'nsga2': return new NSGAII(currentProblem, popSize, generations);
                    case 'moadam': return new MOAdam(currentProblem, popSize, generations);
                    case 'moead': return new MOEADAdam(currentProblem, popSize, generations);
                    case 'mgda': return new MGDAAdam(currentProblem, popSize, generations);
                    case 'paretoadam': return new ParetoAdam(currentProblem, popSize, generations);
                }
            });
            
            // Initialize
            algorithms.forEach(algo => algo.initialize());
            
            // Evolve
            for (let gen = 0; gen < generations && isOptimizing; gen++) {
                currentGeneration = gen;
                
                // Evolve all algorithms
                for (let i = 0; i < 4; i++) {
                    algorithms[i].evolve();
                    const front = algorithms[i].getParetoFront();
                    plotters[i].update(front);
                    
                    // Update storage plotter with best solution from this algorithm
                    if (front.length > 0) {
                        const bestYield = front.reduce((best, curr) => 
                            curr.yieldPct > best.yieldPct ? curr : best
                        );
                        storagePlotters[i].update(bestYield.storage, currentProblem.capacity, bestYield.policy);
                    }
                }
                
                // Update combined Pareto front
                const allFronts = algorithms.map(a => a.getParetoFront());
                combinedParetoPlotter.update(allFronts);
                
                // Update stats
                document.getElementById('generation').textContent = gen + 1;
                document.getElementById('progress-text').textContent = 
                    `${Math.round(((gen + 1) / generations) * 100)}%`;
                
                // Update best metrics from all algorithms
                const allSolutions = allFronts.flat();
                if (allSolutions.length > 0) {
                    const bestYield = Math.max(...allSolutions.map(s => s.yieldPct));
                    const minStage2 = Math.min(...allSolutions.map(s => s.stage2Days));
                    document.getElementById('best-yield').textContent = bestYield.toFixed(1) + '%';
                    document.getElementById('min-stage2').textContent = minStage2;
                    
                    const paretoCount = allSolutions.length;
                    document.getElementById('pareto-count').textContent = paretoCount;
                }
                
                // Yield to browser every few generations
                if (gen % 2 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }
            
            isOptimizing = false;
            document.getElementById('optimize-btn').disabled = false;
            document.getElementById('stop-btn').disabled = true;
        }
        
        // ====================================================================
        // UI EVENT HANDLERS
        // ====================================================================
        
        document.getElementById('capacity').addEventListener('input', (e) => {
            document.getElementById('capacity-value').textContent = e.target.value;
        });
        
        document.getElementById('sim-length').addEventListener('input', (e) => {
            document.getElementById('sim-length-value').textContent = e.target.value;
        });
        
        document.getElementById('skew').addEventListener('input', (e) => {
            document.getElementById('skew-value').textContent = parseFloat(e.target.value).toFixed(1);
        });
        
        document.getElementById('municipal').addEventListener('input', (e) => {
            document.getElementById('municipal-value').textContent = e.target.value;
        });
        
        document.getElementById('irrigation').addEventListener('input', (e) => {
            document.getElementById('irrigation-value').textContent = e.target.value;
        });
        
        document.getElementById('popsize').addEventListener('input', (e) => {
            document.getElementById('popsize-value').textContent = e.target.value;
        });
        
        document.getElementById('generations').addEventListener('input', (e) => {
            document.getElementById('generations-value').textContent = e.target.value;
        });
        
        document.getElementById('optimize-btn').addEventListener('click', () => {
            runOptimization();
        });
        
        document.getElementById('stop-btn').addEventListener('click', () => {
            isOptimizing = false;
        });
        
        // Initialize plots
        hydrologyPlotter.render();
        combinedParetoPlotter.render();
        plotters.forEach(p => p.render());
        storagePlotters.forEach(p => p.render());
    </script>
</body>
</html>
