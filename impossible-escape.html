<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Impossible Escape - Binary Parity Puzzle | FTA Analytics</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Merriweather:wght@300;400;700&display=swap');
        
        :root {
            --bg-primary: #0a0e27;
            --bg-secondary: #141b3d;
            --bg-tertiary: #1e2749;
            --accent-primary: #00d9ff;
            --accent-secondary: #ff006e;
            --accent-tertiary: #8338ec;
            --text-primary: #e8f1ff;
            --text-secondary: #a5b4cb;
            --text-dim: #6b7a99;
            --border-color: #2a3659;
            --success: #06ffa5;
            --warning: #ffbe0b;
            --error: #ff006e;
            --shadow-glow: 0 0 30px rgba(0, 217, 255, 0.3);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Merriweather', serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        .background-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(var(--border-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--border-color) 1px, transparent 1px);
            background-size: 50px 50px;
            opacity: 0.2;
            z-index: 0;
            pointer-events: none;
        }
        
        .container {
            position: relative;
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px 20px;
            z-index: 1;
        }
        
        header {
            text-align: center;
            margin-bottom: 60px;
            padding: 40px 0;
            border-bottom: 2px solid var(--border-color);
        }
        
        h1 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 3.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: glow-pulse 3s ease-in-out infinite;
        }
        
        @keyframes glow-pulse {
            0%, 100% { filter: drop-shadow(0 0 20px rgba(0, 217, 255, 0.5)); }
            50% { filter: drop-shadow(0 0 35px rgba(131, 56, 236, 0.7)); }
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: var(--text-secondary);
            font-weight: 300;
            letter-spacing: 1px;
        }
        
        .mode-selector {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 50px;
            flex-wrap: wrap;
        }
        
        .mode-btn {
            font-family: 'JetBrains Mono', monospace;
            padding: 15px 30px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            color: var(--text-primary);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }
        
        .mode-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 217, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }
        
        .mode-btn:hover::before {
            left: 100%;
        }
        
        .mode-btn:hover {
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-glow);
            transform: translateY(-2px);
        }
        
        .mode-btn.active {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
            border-color: var(--accent-primary);
            color: var(--bg-primary);
        }
        
        .mode-content {
            display: none;
            animation: fadeIn 0.5s ease;
        }
        
        .mode-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .section {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            padding: 40px;
            margin-bottom: 30px;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
        }
        
        h2 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2rem;
            color: var(--accent-primary);
            margin-bottom: 25px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        h3 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.3rem;
            color: var(--accent-secondary);
            margin: 30px 0 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        p {
            color: var(--text-secondary);
            margin-bottom: 15px;
            font-size: 1rem;
            line-height: 1.8;
        }
        
        .chess-container {
            display: flex;
            gap: 40px;
            margin: 30px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .board-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .board-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
            color: var(--accent-primary);
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 50px);
            grid-template-rows: repeat(8, 50px);
            gap: 2px;
            background: var(--border-color);
            padding: 2px;
            border: 3px solid var(--accent-primary);
            box-shadow: var(--shadow-glow);
            position: relative;
        }
        
        .square {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            font-weight: 600;
        }
        
        .square:hover {
            transform: scale(1.05);
            z-index: 10;
        }
        
        .square.light {
            background: var(--bg-tertiary);
        }
        
        .square.dark {
            background: var(--bg-secondary);
        }
        
        .square.magic {
            background: var(--accent-secondary) !important;
            animation: pulse-magic 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse-magic {
            0%, 100% { box-shadow: 0 0 15px var(--accent-secondary); }
            50% { box-shadow: 0 0 30px var(--accent-secondary); }
        }
        
        .square.flip-target {
            background: var(--success) !important;
            animation: pulse-flip 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse-flip {
            0%, 100% { box-shadow: 0 0 15px var(--success); }
            50% { box-shadow: 0 0 30px var(--success); }
        }
        
        .coin {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: var(--bg-primary);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            animation: coinAppear 0.3s ease;
        }
        
        @keyframes coinAppear {
            from { transform: scale(0) rotate(180deg); }
            to { transform: scale(1) rotate(0deg); }
        }
        
        .info-display {
            display: flex;
            flex-direction: column;
            gap: 15px;
            font-family: 'JetBrains Mono', monospace;
            padding: 20px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
        }
        
        .info-label {
            color: var(--text-dim);
            text-transform: uppercase;
            font-size: 0.85rem;
            letter-spacing: 1px;
        }
        
        .info-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--accent-primary);
        }
        
        .binary-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            color: var(--accent-primary);
            letter-spacing: 3px;
            text-align: center;
            padding: 15px;
            background: var(--bg-primary);
            border: 2px solid var(--accent-primary);
            border-radius: 5px;
            margin-top: 10px;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        
        .btn {
            font-family: 'JetBrains Mono', monospace;
            padding: 12px 25px;
            background: var(--bg-tertiary);
            border: 2px solid var(--accent-primary);
            color: var(--accent-primary);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .btn:hover {
            background: var(--accent-primary);
            color: var(--bg-primary);
            box-shadow: var(--shadow-glow);
            transform: translateY(-2px);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn.secondary {
            border-color: var(--accent-secondary);
            color: var(--accent-secondary);
        }
        
        .btn.secondary:hover {
            background: var(--accent-secondary);
            box-shadow: 0 0 30px rgba(255, 0, 110, 0.3);
        }
        
        .explanation {
            background: var(--bg-tertiary);
            padding: 25px;
            border-left: 4px solid var(--accent-primary);
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .explanation strong {
            color: var(--accent-primary);
        }
        
        .bit-pattern {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .bit-card {
            background: var(--bg-tertiary);
            padding: 20px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            text-align: center;
        }
        
        .bit-card h4 {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-primary);
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
        
        .mini-board {
            display: grid;
            grid-template-columns: repeat(8, 20px);
            grid-template-rows: repeat(8, 20px);
            gap: 1px;
            margin: 10px auto;
            width: fit-content;
        }
        
        .mini-square {
            width: 20px;
            height: 20px;
        }
        
        .mini-square.highlighted {
            background: var(--accent-primary);
        }
        
        .mini-square.light {
            background: var(--bg-secondary);
        }
        
        .mini-square.dark {
            background: var(--bg-primary);
        }
        
        .status-message {
            text-align: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: fadeIn 0.5s ease;
        }
        
        .status-message.success {
            background: var(--success);
            color: var(--bg-primary);
            box-shadow: 0 0 30px rgba(6, 255, 165, 0.5);
        }
        
        .status-message.failure {
            background: var(--error);
            color: var(--text-primary);
            box-shadow: 0 0 30px rgba(255, 0, 110, 0.5);
        }
        
        .status-message.info {
            background: var(--accent-primary);
            color: var(--bg-primary);
            box-shadow: var(--shadow-glow);
        }
        
        .challenge-instructions {
            background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-secondary));
            padding: 30px;
            border: 2px solid var(--accent-primary);
            border-radius: 8px;
            margin-bottom: 30px;
        }
        
        .challenge-instructions h3 {
            margin-top: 0;
        }
        
        .challenge-instructions ol {
            color: var(--text-secondary);
            padding-left: 25px;
        }
        
        .challenge-instructions li {
            margin-bottom: 10px;
            line-height: 1.8;
        }
        
        code {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-primary);
            padding: 2px 8px;
            border-radius: 3px;
            color: var(--accent-primary);
        }
        
        .theory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }
        
        .theory-card {
            background: var(--bg-tertiary);
            padding: 25px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .theory-card:hover {
            border-color: var(--accent-primary);
            transform: translateY(-5px);
            box-shadow: var(--shadow-glow);
        }
        
        .theory-card h4 {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-primary);
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .chessboard {
                grid-template-columns: repeat(8, 40px);
                grid-template-rows: repeat(8, 40px);
            }
            
            .square {
                width: 40px;
                height: 40px;
            }
            
            .coin {
                width: 28px;
                height: 28px;
                font-size: 0.7rem;
            }
            
            .section {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="background-grid"></div>
    
    <div class="container">
        <header>
            <h1>Impossible Escape</h1>
            <p class="subtitle">A Binary Parity Puzzle in Information Theory</p>
        </header>
        
        <div class="mode-selector">
            <button class="mode-btn active" data-mode="challenge">Challenge Mode</button>
            <button class="mode-btn" data-mode="demo">Interactive Demo</button>
            <button class="mode-btn" data-mode="learn">Learn the Solution</button>
            <button class="mode-btn" data-mode="theory">Information Theory</button>
        </div>
        
        <!-- Challenge Mode -->
        <div id="challenge-mode" class="mode-content active">
            <div class="section">
                <h2>The Challenge</h2>
                <div class="challenge-instructions">
                    <h3>Can You Escape?</h3>
                    <p>You and your friend are prisoners. The jailer offers you freedom through this challenge:</p>
                    <ol>
                        <li>The jailer places 64 coins randomly on a chessboard (heads or tails)</li>
                        <li>The jailer points to one "magic square" - the key to your freedom</li>
                        <li>You must flip <strong>exactly one coin</strong> to encode which square is magic</li>
                        <li>Your friend enters the room, sees only the coins (not which was flipped)</li>
                        <li>Your friend must identify the magic square to save you both</li>
                    </ol>
                    <p><strong>Your task:</strong> Click the square your friend should guess after seeing the board state.</p>
                </div>
                
                <div id="challenge-status"></div>
                
                <div class="chess-container">
                    <div class="board-wrapper">
                        <div class="board-label">Coin Configuration</div>
                        <div id="challenge-board" class="chessboard"></div>
                        <div class="info-display">
                            <div class="info-item">
                                <span class="info-label">Attempts:</span>
                                <span class="info-value" id="challenge-attempts">0</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Correct:</span>
                                <span class="info-value" id="challenge-correct">0</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="controls">
                    <button class="btn" id="challenge-new">New Challenge</button>
                    <button class="btn secondary" id="challenge-hint">Show Hint</button>
                    <button class="btn secondary" id="challenge-reveal">Reveal Answer</button>
                </div>
                
                <div id="challenge-explanation"></div>
            </div>
        </div>
        
        <!-- Demo Mode -->
        <div id="demo-mode" class="mode-content">
            <div class="section">
                <h2>Interactive Demonstration</h2>
                <p>Explore how the puzzle works. Click the left board to select the magic square, then see which coin you need to flip to encode this information.</p>
                
                <div class="chess-container">
                    <div class="board-wrapper">
                        <div class="board-label">1. Select Magic Square</div>
                        <div id="demo-target-board" class="chessboard"></div>
                        <div class="info-display">
                            <div class="info-item">
                                <span class="info-label">Magic Square:</span>
                                <span class="info-value" id="demo-target-value">--</span>
                            </div>
                            <div class="binary-display" id="demo-target-binary">------</div>
                        </div>
                    </div>
                    
                    <div class="board-wrapper">
                        <div class="board-label">2. Coin Configuration</div>
                        <div id="demo-coin-board" class="chessboard"></div>
                        <div class="info-display">
                            <div class="info-item">
                                <span class="info-label">Board Parity:</span>
                                <span class="info-value" id="demo-parity-value">------</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Flip Square:</span>
                                <span class="info-value" id="demo-flip-value">--</span>
                            </div>
                            <div class="binary-display" id="demo-flip-binary">------</div>
                        </div>
                    </div>
                </div>
                
                <div class="controls">
                    <button class="btn" id="demo-randomize">Randomize Coins</button>
                    <button class="btn secondary" id="demo-clear">Clear Board</button>
                </div>
                
                <div class="explanation">
                    <h3>How It Works</h3>
                    <p><strong>Board Parity:</strong> For each of the 6 bit positions (2‚Å∞ through 2‚Åµ), count the number of heads in squares where that bit is set. If odd, that bit is 1; if even, it's 0.</p>
                    <p><strong>XOR Operation:</strong> To change the board parity to match the target square, flip the coin at the position given by: <code>Target XOR Parity</code></p>
                    <p>This works because XOR identifies which bits need to flip. Each square changes specific parity bits when flipped.</p>
                </div>
            </div>
        </div>
        
        <!-- Learn Mode -->
        <div id="learn-mode" class="mode-content">
            <div class="section">
                <h2>Understanding the Solution</h2>
                
                <h3>The Key Insight: Binary Encoding</h3>
                <p>The chessboard has 64 squares, which requires exactly 6 bits to encode (2‚Å∂ = 64). Each square can be uniquely identified by a 6-bit binary number from 000000 (square 0) to 111111 (square 63).</p>
                
                <h3>Bit Patterns & Parity</h3>
                <p>We divide the board into 6 different overlapping patterns based on each bit position:</p>
                
                <div class="bit-pattern">
                    <div class="bit-card">
                        <h4>Bit 0 (2‚Å∞)</h4>
                        <div class="mini-board" id="learn-bit0"></div>
                        <p>Alternating columns</p>
                    </div>
                    <div class="bit-card">
                        <h4>Bit 1 (2¬π)</h4>
                        <div class="mini-board" id="learn-bit1"></div>
                        <p>2-column pattern</p>
                    </div>
                    <div class="bit-card">
                        <h4>Bit 2 (2¬≤)</h4>
                        <div class="mini-board" id="learn-bit2"></div>
                        <p>4-column pattern</p>
                    </div>
                    <div class="bit-card">
                        <h4>Bit 3 (2¬≥)</h4>
                        <div class="mini-board" id="learn-bit3"></div>
                        <p>Alternating rows</p>
                    </div>
                    <div class="bit-card">
                        <h4>Bit 4 (2‚Å¥)</h4>
                        <div class="mini-board" id="learn-bit4"></div>
                        <p>2-row pattern</p>
                    </div>
                    <div class="bit-card">
                        <h4>Bit 5 (2‚Åµ)</h4>
                        <div class="mini-board" id="learn-bit5"></div>
                        <p>4-row pattern</p>
                    </div>
                </div>
                
                <div class="explanation">
                    <h3>The Parity Trick</h3>
                    <p>For each bit pattern, count the number of heads in the highlighted squares:</p>
                    <ul>
                        <li>If <strong>odd</strong> number of heads ‚Üí that bit is <code>1</code></li>
                        <li>If <strong>even</strong> number of heads ‚Üí that bit is <code>0</code></li>
                    </ul>
                    <p>This gives us a 6-bit number that describes the board's "parity state".</p>
                </div>
                
                <div class="explanation">
                    <h3>The Solution</h3>
                    <p>To encode the magic square:</p>
                    <ol>
                        <li>Calculate the current board parity (6-bit number)</li>
                        <li>You want the parity to equal the magic square number</li>
                        <li>Compute: <code>flip_square = magic_square XOR board_parity</code></li>
                        <li>Flip the coin at <code>flip_square</code></li>
                    </ol>
                    <p><strong>Why this works:</strong> When you flip a coin at position N, you toggle the parity of all bit patterns that include position N. The XOR operation tells you exactly which square will transform the current parity into the target parity.</p>
                </div>
                
                <h3>Try It Yourself</h3>
                <p>Use the Interactive Demo mode to see this in action!</p>
            </div>
        </div>
        
        <!-- Theory Mode -->
        <div id="theory-mode" class="mode-content">
            <div class="section">
                <h2>Information Theory Connections</h2>
                
                <h3>Why This Puzzle Matters</h3>
                <p>This puzzle demonstrates fundamental concepts in information theory and error correction that underpin modern digital communications:</p>
                
                <div class="theory-grid">
                    <div class="theory-card">
                        <h4>Hamming Distance</h4>
                        <p>The puzzle uses the concept that any two board configurations differ by at least one coin flip. This relates to Hamming distance in coding theory - the minimum number of bit changes needed to transform one codeword to another.</p>
                    </div>
                    
                    <div class="theory-card">
                        <h4>Error Correcting Codes</h4>
                        <p>The solution is essentially a (64,6) error-correcting code. We're encoding 6 bits of information (the magic square) into a 64-bit string (the coin configuration) such that any single bit flip can be detected and interpreted.</p>
                    </div>
                    
                    <div class="theory-card">
                        <h4>Parity Bits</h4>
                        <p>Each of our 6 bit patterns acts as a parity bit for a subset of the board. This is the same principle used in RAID storage systems, where XOR-based parity enables data recovery from disk failures.</p>
                    </div>
                    
                    <div class="theory-card">
                        <h4>XOR Properties</h4>
                        <p>The XOR operation is self-inverse: (A ‚äï B) ‚äï B = A. This property makes it perfect for encoding/decoding and is used extensively in cryptography and data transmission.</p>
                    </div>
                    
                    <div class="theory-card">
                        <h4>Channel Capacity</h4>
                        <p>Claude Shannon's channel capacity theorem tells us the maximum rate of reliable communication. This puzzle achieves log‚ÇÇ(64) = 6 bits of information transmitted with a single bit change - optimal for this constraint.</p>
                    </div>
                    
                    <div class="theory-card">
                        <h4>Syndrome Decoding</h4>
                        <p>The board parity acts as a "syndrome" in coding theory. Your friend decodes by computing the syndrome of the received configuration, which directly reveals the encoded message.</p>
                    </div>
                </div>
                
                <div class="explanation">
                    <h3>Real-World Applications</h3>
                    <p><strong>Water Resources Engineering:</strong> Similar parity-based encoding is used in telemetry systems for remote monitoring of reservoir levels, flow rates, and sensor networks where data reliability is critical.</p>
                    <p><strong>SCADA Systems:</strong> Industrial control systems use error detection codes to ensure reliable transmission of control signals across noisy channels.</p>
                    <p><strong>Satellite Communications:</strong> Reed-Solomon codes (a generalization of these principles) enable reliable data transmission from spacecraft despite cosmic ray interference.</p>
                    <p><strong>Computer Memory:</strong> ECC (Error-Correcting Code) memory uses these principles to detect and correct bit flips caused by radiation or electrical interference.</p>
                </div>
                
                <div class="explanation">
                    <h3>Mathematical Foundations</h3>
                    <p>The puzzle leverages vector spaces over GF(2) (the Galois field with 2 elements). Each board configuration is a 64-dimensional vector, and parity checking is a linear transformation that projects this onto a 6-dimensional subspace.</p>
                    <p>The coin flip operation spans the entire space efficiently because the bit patterns form a basis. This ensures that from any starting configuration, we can reach any target parity state with exactly one flip.</p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Core game state
        const gameState = {
            challengeAttempts: 0,
            challengeCorrect: 0,
            magicSquare: null,
            coinBoard: new Array(64).fill(false),
            currentMode: 'challenge'
        };
        
        // Utility functions
        function getBitPattern(bit) {
            const pattern = [];
            for (let i = 0; i < 64; i++) {
                if (i & (1 << bit)) {
                    pattern.push(i);
                }
            }
            return pattern;
        }
        
        function calculateParity(coins) {
            let parity = 0;
            for (let i = 0; i < 64; i++) {
                if (coins[i]) {
                    parity ^= i;
                }
            }
            return parity;
        }
        
        function toBinary(num) {
            return num.toString(2).padStart(6, '0');
        }
        
        function randomizeCoins() {
            return Array(64).fill(false).map(() => Math.random() > 0.5);
        }
        
        // Board rendering
        function createBoard(containerId, clickHandler) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            for (let i = 0; i < 64; i++) {
                const square = document.createElement('div');
                square.className = 'square ' + ((Math.floor(i / 8) + (i % 8)) % 2 ? 'dark' : 'light');
                square.dataset.square = i;
                if (clickHandler) {
                    square.addEventListener('click', () => clickHandler(i));
                }
                container.appendChild(square);
            }
        }
        
        function updateSquare(containerId, square, state) {
            const container = document.getElementById(containerId);
            const squareEl = container.querySelector(`[data-square="${square}"]`);
            squareEl.innerHTML = '';
            
            if (state.coin) {
                const coin = document.createElement('div');
                coin.className = 'coin';
                coin.textContent = 'H';
                squareEl.appendChild(coin);
            }
            
            if (state.magic) {
                squareEl.classList.add('magic');
            } else {
                squareEl.classList.remove('magic');
            }
            
            if (state.flip) {
                squareEl.classList.add('flip-target');
            } else {
                squareEl.classList.remove('flip-target');
            }
        }
        
        // Challenge Mode
        function setupChallengeMode() {
            createBoard('challenge-board', handleChallengeGuess);
            newChallenge();
            
            document.getElementById('challenge-new').addEventListener('click', newChallenge);
            document.getElementById('challenge-hint').addEventListener('click', showHint);
            document.getElementById('challenge-reveal').addEventListener('click', revealAnswer);
        }
        
        function newChallenge() {
            gameState.magicSquare = Math.floor(Math.random() * 64);
            gameState.coinBoard = randomizeCoins();
            
            const parity = calculateParity(gameState.coinBoard);
            const flipSquare = gameState.magicSquare ^ parity;
            
            // Simulate the flip
            gameState.coinBoard[flipSquare] = !gameState.coinBoard[flipSquare];
            
            // Update display
            for (let i = 0; i < 64; i++) {
                updateSquare('challenge-board', i, { coin: gameState.coinBoard[i] });
            }
            
            document.getElementById('challenge-status').innerHTML = '';
            document.getElementById('challenge-explanation').innerHTML = '';
        }
        
        function handleChallengeGuess(square) {
            gameState.challengeAttempts++;
            document.getElementById('challenge-attempts').textContent = gameState.challengeAttempts;
            
            const statusEl = document.getElementById('challenge-status');
            
            if (square === gameState.magicSquare) {
                gameState.challengeCorrect++;
                document.getElementById('challenge-correct').textContent = gameState.challengeCorrect;
                
                updateSquare('challenge-board', square, { 
                    coin: gameState.coinBoard[square], 
                    magic: true 
                });
                
                statusEl.innerHTML = '<div class="status-message success">üéâ Freedom! You Escaped! üéâ</div>';
                
                setTimeout(newChallenge, 3000);
            } else {
                statusEl.innerHTML = '<div class="status-message failure">‚ùå Wrong Square - Executed! ‚ùå</div>';
                
                setTimeout(() => {
                    statusEl.innerHTML = '<div class="status-message info">Try again!</div>';
                    setTimeout(() => statusEl.innerHTML = '', 2000);
                }, 2000);
            }
        }
        
        function showHint() {
            const explanationEl = document.getElementById('challenge-explanation');
            const parity = calculateParity(gameState.coinBoard);
            
            explanationEl.innerHTML = `
                <div class="explanation">
                    <h3>Hint</h3>
                    <p><strong>Board Parity:</strong> ${toBinary(parity)} (decimal: ${parity})</p>
                    <p>The magic square's binary representation equals the board's parity.</p>
                    <p>Look for a square whose number matches this parity value!</p>
                </div>
            `;
        }
        
        function revealAnswer() {
            const explanationEl = document.getElementById('challenge-explanation');
            
            updateSquare('challenge-board', gameState.magicSquare, { 
                coin: gameState.coinBoard[gameState.magicSquare], 
                magic: true 
            });
            
            const parity = calculateParity(gameState.coinBoard);
            
            explanationEl.innerHTML = `
                <div class="explanation">
                    <h3>Solution</h3>
                    <p><strong>Magic Square:</strong> ${gameState.magicSquare} (binary: ${toBinary(gameState.magicSquare)})</p>
                    <p><strong>Board Parity:</strong> ${toBinary(parity)} (decimal: ${parity})</p>
                    <p>The magic square is always at position ${gameState.magicSquare}, which matches the board's parity!</p>
                </div>
            `;
            
            setTimeout(newChallenge, 5000);
        }
        
        // Demo Mode
        function setupDemoMode() {
            createBoard('demo-target-board', handleDemoTargetClick);
            createBoard('demo-coin-board', handleDemoCoinClick);
            
            gameState.demoTarget = null;
            gameState.coinBoard = randomizeCoins();
            
            updateDemoDisplay();
            
            document.getElementById('demo-randomize').addEventListener('click', () => {
                gameState.coinBoard = randomizeCoins();
                updateDemoDisplay();
            });
            
            document.getElementById('demo-clear').addEventListener('click', () => {
                gameState.coinBoard = new Array(64).fill(false);
                updateDemoDisplay();
            });
        }
        
        function handleDemoTargetClick(square) {
            gameState.demoTarget = square;
            updateDemoDisplay();
        }
        
        function handleDemoCoinClick(square) {
            gameState.coinBoard[square] = !gameState.coinBoard[square];
            updateDemoDisplay();
        }
        
        function updateDemoDisplay() {
            // Update target board
            for (let i = 0; i < 64; i++) {
                updateSquare('demo-target-board', i, { 
                    magic: i === gameState.demoTarget 
                });
            }
            
            // Update coin board
            const parity = calculateParity(gameState.coinBoard);
            const flipSquare = gameState.demoTarget !== null ? (gameState.demoTarget ^ parity) : null;
            
            for (let i = 0; i < 64; i++) {
                updateSquare('demo-coin-board', i, { 
                    coin: gameState.coinBoard[i],
                    flip: i === flipSquare
                });
            }
            
            // Update info displays
            document.getElementById('demo-target-value').textContent = 
                gameState.demoTarget !== null ? gameState.demoTarget : '--';
            document.getElementById('demo-target-binary').textContent = 
                gameState.demoTarget !== null ? toBinary(gameState.demoTarget) : '------';
            
            document.getElementById('demo-parity-value').textContent = toBinary(parity);
            document.getElementById('demo-flip-value').textContent = 
                flipSquare !== null ? flipSquare : '--';
            document.getElementById('demo-flip-binary').textContent = 
                flipSquare !== null ? toBinary(flipSquare) : '------';
        }
        
        // Learn Mode
        function setupLearnMode() {
            for (let bit = 0; bit < 6; bit++) {
                const container = document.getElementById(`learn-bit${bit}`);
                const pattern = getBitPattern(bit);
                
                for (let i = 0; i < 64; i++) {
                    const square = document.createElement('div');
                    square.className = 'mini-square ' + 
                        (pattern.includes(i) ? 'highlighted' : 
                        ((Math.floor(i / 8) + (i % 8)) % 2 ? 'dark' : 'light'));
                    container.appendChild(square);
                }
            }
        }
        
        // Mode switching
        function setupModeSwitching() {
            const buttons = document.querySelectorAll('.mode-btn');
            const contents = document.querySelectorAll('.mode-content');
            
            buttons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const mode = btn.dataset.mode;
                    
                    buttons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    contents.forEach(c => c.classList.remove('active'));
                    document.getElementById(`${mode}-mode`).classList.add('active');
                    
                    gameState.currentMode = mode;
                });
            });
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            setupModeSwitching();
            setupChallengeMode();
            setupDemoMode();
            setupLearnMode();
        });
    </script>
</body>
</html>