<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Fluid Mixing Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #fff;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 8px;
            z-index: 1000;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        input[type="number"] {
            width: 80px;
            padding: 5px;
            border: 1px solid #555;
            background: #2a2a2a;
            color: #fff;
            border-radius: 4px;
        }
        select {
            width: 150px;
            padding: 5px;
            border: 1px solid #555;
            background: #2a2a2a;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        #reset {
            background: #f44336;
            margin-left: 10px;
        }
        #reset:hover {
            background: #da190b;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="controls">
        <h2 style="margin-top: 0;">3D Fluid Mixing</h2>
        <div class="control-group">
            <label>Left Fluid Density (kg/m³):</label>
            <input type="number" id="density1" value="1000" min="500" max="2000" step="50">
        </div>
        <div class="control-group">
            <label>Right Fluid Density (kg/m³):</label>
            <input type="number" id="density2" value="1200" min="500" max="2000" step="50">
        </div>
        <div class="control-group">
            <label>Visualization Mode:</label>
            <select id="vizMode">
                <option value="particles">Particles</option>
                <option value="streamlines">Flow Paths</option>
            </select>
        </div>
        <div class="control-group">
            <button id="startBtn">Remove Barrier</button>
            <button id="reset">Reset</button>
        </div>
    </div>
    <div id="info">
        <strong>Controls:</strong><br>
        • Mouse: Rotate view<br>
        • Scroll: Zoom<br>
        • Right-click: Pan<br><br>
        <strong>Physics:</strong><br>
        Incompressible Navier-Stokes with density-driven buoyancy
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Simulation parameters
        const N = 48; // Grid resolution (48³ = 110,592 cells)
        const dt = 0.016; // Time step
        const viscosity = 0.0001;
        const diffusion = 0.0001;
        const gravity = -9.81;
        
        // Fluid simulation class
        class FluidSim3D {
            constructor(size) {
                this.size = size;
                this.n = size * size * size;
                
                // Velocity fields (staggered grid)
                this.u = new Float32Array(this.n); // x-velocity
                this.v = new Float32Array(this.n); // y-velocity
                this.w = new Float32Array(this.n); // z-velocity
                
                this.u0 = new Float32Array(this.n);
                this.v0 = new Float32Array(this.n);
                this.w0 = new Float32Array(this.n);
                
                // Scalar fields
                this.density = new Float32Array(this.n);
                this.density0 = new Float32Array(this.n);
                
                // Pressure
                this.p = new Float32Array(this.n);
                this.div = new Float32Array(this.n);
                
                this.barrierActive = true;
            }
            
            IX(i, j, k) {
                i = Math.max(0, Math.min(this.size - 1, i));
                j = Math.max(0, Math.min(this.size - 1, j));
                k = Math.max(0, Math.min(this.size - 1, k));
                return i + j * this.size + k * this.size * this.size;
            }
            
            initialize(density1, density2) {
                const mid = Math.floor(this.size / 2);
                
                for (let k = 0; k < this.size; k++) {
                    for (let j = 0; j < this.size; j++) {
                        for (let i = 0; i < this.size; i++) {
                            const idx = this.IX(i, j, k);
                            
                            // Left side: density1, Right side: density2
                            this.density[idx] = i < mid ? density1 : density2;
                            
                            // Zero initial velocity
                            this.u[idx] = 0;
                            this.v[idx] = 0;
                            this.w[idx] = 0;
                        }
                    }
                }
                
                this.barrierActive = true;
            }
            
            removeBarrier() {
                this.barrierActive = false;
            }
            
            step(dt) {
                // Diffuse velocity
                this.diffuse(1, this.u0, this.u, viscosity, dt);
                this.diffuse(2, this.v0, this.v, viscosity, dt);
                this.diffuse(3, this.w0, this.w, viscosity, dt);
                
                // Project to make incompressible
                this.project(this.u0, this.v0, this.w0, this.p, this.div);
                
                // Advect velocity
                this.advect(1, this.u, this.u0, this.u0, this.v0, this.w0, dt);
                this.advect(2, this.v, this.v0, this.u0, this.v0, this.w0, dt);
                this.advect(3, this.w, this.w0, this.u0, this.v0, this.w0, dt);
                
                // Add buoyancy force
                this.addBuoyancy(dt);
                
                // Project again
                this.project(this.u, this.v, this.w, this.p, this.div);
                
                // Diffuse density
                this.diffuse(0, this.density0, this.density, diffusion, dt);
                
                // Advect density
                this.advect(0, this.density, this.density0, this.u, this.v, this.w, dt);
            }
            
            addBuoyancy(dt) {
                // Calculate average density
                let avgDensity = 0;
                for (let i = 0; i < this.n; i++) {
                    avgDensity += this.density[i];
                }
                avgDensity /= this.n;
                
                // Add buoyancy force to y-velocity
                const buoyancyCoeff = 0.1; // Scaling factor
                for (let k = 1; k < this.size - 1; k++) {
                    for (let j = 1; j < this.size - 1; j++) {
                        for (let i = 1; i < this.size - 1; i++) {
                            const idx = this.IX(i, j, k);
                            const densityDiff = (this.density[idx] - avgDensity) / avgDensity;
                            this.v[idx] += buoyancyCoeff * gravity * densityDiff * dt;
                        }
                    }
                }
            }
            
            diffuse(b, x, x0, diff, dt) {
                const a = dt * diff * (this.size - 2) * (this.size - 2);
                this.linSolve(b, x, x0, a, 1 + 6 * a, 4);
            }
            
            linSolve(b, x, x0, a, c, iterations) {
                const cRecip = 1.0 / c;
                
                for (let iter = 0; iter < iterations; iter++) {
                    for (let k = 1; k < this.size - 1; k++) {
                        for (let j = 1; j < this.size - 1; j++) {
                            for (let i = 1; i < this.size - 1; i++) {
                                const idx = this.IX(i, j, k);
                                
                                x[idx] = (x0[idx] + a * (
                                    x[this.IX(i-1, j, k)] +
                                    x[this.IX(i+1, j, k)] +
                                    x[this.IX(i, j-1, k)] +
                                    x[this.IX(i, j+1, k)] +
                                    x[this.IX(i, j, k-1)] +
                                    x[this.IX(i, j, k+1)]
                                )) * cRecip;
                            }
                        }
                    }
                    this.setBoundary(b, x);
                }
            }
            
            project(u, v, w, p, div) {
                const h = 1.0 / this.size;
                
                // Calculate divergence
                for (let k = 1; k < this.size - 1; k++) {
                    for (let j = 1; j < this.size - 1; j++) {
                        for (let i = 1; i < this.size - 1; i++) {
                            const idx = this.IX(i, j, k);
                            
                            div[idx] = -0.5 * h * (
                                u[this.IX(i+1, j, k)] - u[this.IX(i-1, j, k)] +
                                v[this.IX(i, j+1, k)] - v[this.IX(i, j-1, k)] +
                                w[this.IX(i, j, k+1)] - w[this.IX(i, j, k-1)]
                            );
                            p[idx] = 0;
                        }
                    }
                }
                
                this.setBoundary(0, div);
                this.setBoundary(0, p);
                this.linSolve(0, p, div, 1, 6, 10);
                
                // Subtract pressure gradient
                for (let k = 1; k < this.size - 1; k++) {
                    for (let j = 1; j < this.size - 1; j++) {
                        for (let i = 1; i < this.size - 1; i++) {
                            const idx = this.IX(i, j, k);
                            
                            u[idx] -= 0.5 * (p[this.IX(i+1, j, k)] - p[this.IX(i-1, j, k)]) / h;
                            v[idx] -= 0.5 * (p[this.IX(i, j+1, k)] - p[this.IX(i, j-1, k)]) / h;
                            w[idx] -= 0.5 * (p[this.IX(i, j, k+1)] - p[this.IX(i, j, k-1)]) / h;
                        }
                    }
                }
                
                this.setBoundary(1, u);
                this.setBoundary(2, v);
                this.setBoundary(3, w);
            }
            
            advect(b, d, d0, u, v, w, dt) {
                const dt0 = dt * (this.size - 2);
                
                for (let k = 1; k < this.size - 1; k++) {
                    for (let j = 1; j < this.size - 1; j++) {
                        for (let i = 1; i < this.size - 1; i++) {
                            const idx = this.IX(i, j, k);
                            
                            // Backtrace
                            let x = i - dt0 * u[idx];
                            let y = j - dt0 * v[idx];
                            let z = k - dt0 * w[idx];
                            
                            // Clamp to grid
                            x = Math.max(0.5, Math.min(this.size - 1.5, x));
                            y = Math.max(0.5, Math.min(this.size - 1.5, y));
                            z = Math.max(0.5, Math.min(this.size - 1.5, z));
                            
                            const i0 = Math.floor(x);
                            const i1 = i0 + 1;
                            const j0 = Math.floor(y);
                            const j1 = j0 + 1;
                            const k0 = Math.floor(z);
                            const k1 = k0 + 1;
                            
                            const sx1 = x - i0;
                            const sx0 = 1 - sx1;
                            const sy1 = y - j0;
                            const sy0 = 1 - sy1;
                            const sz1 = z - k0;
                            const sz0 = 1 - sz1;
                            
                            // Trilinear interpolation
                            d[idx] = 
                                sx0 * (sy0 * (sz0 * d0[this.IX(i0, j0, k0)] + sz1 * d0[this.IX(i0, j0, k1)]) +
                                       sy1 * (sz0 * d0[this.IX(i0, j1, k0)] + sz1 * d0[this.IX(i0, j1, k1)])) +
                                sx1 * (sy0 * (sz0 * d0[this.IX(i1, j0, k0)] + sz1 * d0[this.IX(i1, j0, k1)]) +
                                       sy1 * (sz0 * d0[this.IX(i1, j1, k0)] + sz1 * d0[this.IX(i1, j1, k1)]));
                        }
                    }
                }
                
                this.setBoundary(b, d);
            }
            
            setBoundary(b, x) {
                const N = this.size - 1;
                
                for (let j = 1; j < N; j++) {
                    for (let i = 1; i < N; i++) {
                        x[this.IX(i, j, 0)] = b === 3 ? -x[this.IX(i, j, 1)] : x[this.IX(i, j, 1)];
                        x[this.IX(i, j, N)] = b === 3 ? -x[this.IX(i, j, N-1)] : x[this.IX(i, j, N-1)];
                    }
                }
                
                for (let k = 1; k < N; k++) {
                    for (let i = 1; i < N; i++) {
                        x[this.IX(i, 0, k)] = b === 2 ? -x[this.IX(i, 1, k)] : x[this.IX(i, 1, k)];
                        x[this.IX(i, N, k)] = b === 2 ? -x[this.IX(i, N-1, k)] : x[this.IX(i, N-1, k)];
                    }
                }
                
                for (let k = 1; k < N; k++) {
                    for (let j = 1; j < N; j++) {
                        x[this.IX(0, j, k)] = b === 1 ? -x[this.IX(1, j, k)] : x[this.IX(1, j, k)];
                        x[this.IX(N, j, k)] = b === 1 ? -x[this.IX(N-1, j, k)] : x[this.IX(N-1, j, k)];
                    }
                }
            }
        }

        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);

        camera.position.set(N * 0.8, N * 0.8, N * 1.2);
        camera.lookAt(N * 0.5, N * 0.5, N * 0.5);

        // Simple orbit controls
        let mouseDown = false;
        let mouseX = 0, mouseY = 0;
        let cameraTheta = Math.PI / 4;
        let cameraPhi = Math.PI / 4;
        let cameraRadius = N * 1.5;

        renderer.domElement.addEventListener('mousedown', (e) => {
            mouseDown = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        renderer.domElement.addEventListener('mouseup', () => mouseDown = false);

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (!mouseDown) return;
            
            const deltaX = e.clientX - mouseX;
            const deltaY = e.clientY - mouseY;
            
            cameraTheta += deltaX * 0.01;
            cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi + deltaY * 0.01));
            
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        renderer.domElement.addEventListener('wheel', (e) => {
            cameraRadius = Math.max(N * 0.5, Math.min(N * 3, cameraRadius + e.deltaY * 0.1));
        });

        // Particle system for visualization
        const particleCount = 8000;
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        const particleColors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            particlePositions[i * 3] = Math.random() * N;
            particlePositions[i * 3 + 1] = Math.random() * N;
            particlePositions[i * 3 + 2] = Math.random() * N;
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

        const particleMaterial = new THREE.PointsMaterial({
            size: 0.5,
            vertexColors: true,
            transparent: true,
            opacity: 0.8
        });

        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);

        // Streamline system
        const streamlineCount = 400;
        const streamlineLength = 50;
        const streamlines = [];
        const streamlineGroup = new THREE.Group();
        scene.add(streamlineGroup);
        streamlineGroup.visible = false;

        class Streamline {
            constructor(index) {
                this.index = index;
                this.points = [];
                this.age = 0;
                this.maxAge = streamlineLength;
                
                // Random starting position
                this.reset();
                
                // Create line
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.maxAge * 3);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.LineBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.7,
                    linewidth: 2
                });
                
                const colors = new Float32Array(this.maxAge * 3);
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                this.line = new THREE.Line(geometry, material);
                streamlineGroup.add(this.line);
            }
            
            reset() {
                // Distribute evenly through the volume
                this.x = Math.random() * (N - 4) + 2;
                this.y = Math.random() * (N - 4) + 2;
                this.z = Math.random() * (N - 4) + 2;
                this.points = [];
                this.age = 0;
            }
            
            getVelocityAt(fluid, x, y, z) {
                // Trilinear interpolation of velocity
                const i0 = Math.floor(x);
                const j0 = Math.floor(y);
                const k0 = Math.floor(z);
                const i1 = i0 + 1;
                const j1 = j0 + 1;
                const k1 = k0 + 1;
                
                // Clamp to valid range
                if (i0 < 1 || i1 >= N - 1 || j0 < 1 || j1 >= N - 1 || k0 < 1 || k1 >= N - 1) {
                    return [0, 0, 0];
                }
                
                const fx = x - i0;
                const fy = y - j0;
                const fz = z - k0;
                
                const fx1 = 1 - fx;
                const fy1 = 1 - fy;
                const fz1 = 1 - fz;
                
                // Get velocities at 8 corners
                const idx000 = fluid.IX(i0, j0, k0);
                const idx001 = fluid.IX(i0, j0, k1);
                const idx010 = fluid.IX(i0, j1, k0);
                const idx011 = fluid.IX(i0, j1, k1);
                const idx100 = fluid.IX(i1, j0, k0);
                const idx101 = fluid.IX(i1, j0, k1);
                const idx110 = fluid.IX(i1, j1, k0);
                const idx111 = fluid.IX(i1, j1, k1);
                
                // Interpolate u
                const u = fx1 * (fy1 * (fz1 * fluid.u[idx000] + fz * fluid.u[idx001]) +
                                 fy  * (fz1 * fluid.u[idx010] + fz * fluid.u[idx011])) +
                          fx  * (fy1 * (fz1 * fluid.u[idx100] + fz * fluid.u[idx101]) +
                                 fy  * (fz1 * fluid.u[idx110] + fz * fluid.u[idx111]));
                
                // Interpolate v
                const v = fx1 * (fy1 * (fz1 * fluid.v[idx000] + fz * fluid.v[idx001]) +
                                 fy  * (fz1 * fluid.v[idx010] + fz * fluid.v[idx011])) +
                          fx  * (fy1 * (fz1 * fluid.v[idx100] + fz * fluid.v[idx101]) +
                                 fy  * (fz1 * fluid.v[idx110] + fz * fluid.v[idx111]));
                
                // Interpolate w
                const w = fx1 * (fy1 * (fz1 * fluid.w[idx000] + fz * fluid.w[idx001]) +
                                 fy  * (fz1 * fluid.w[idx010] + fz * fluid.w[idx011])) +
                          fx  * (fy1 * (fz1 * fluid.w[idx100] + fz * fluid.w[idx101]) +
                                 fy  * (fz1 * fluid.w[idx110] + fz * fluid.w[idx111]));
                
                return [u, v, w];
            }
            
            update(fluid, dt) {
                // Check bounds
                if (this.x < 2 || this.x >= N - 2 || 
                    this.y < 2 || this.y >= N - 2 || 
                    this.z < 2 || this.z >= N - 2) {
                    this.reset();
                    return;
                }
                
                // RK4 integration for smooth particle tracing
                const [k1x, k1y, k1z] = this.getVelocityAt(fluid, this.x, this.y, this.z);
                
                const [k2x, k2y, k2z] = this.getVelocityAt(fluid, 
                    this.x + k1x * dt * 0.5,
                    this.y + k1y * dt * 0.5,
                    this.z + k1z * dt * 0.5
                );
                
                const [k3x, k3y, k3z] = this.getVelocityAt(fluid,
                    this.x + k2x * dt * 0.5,
                    this.y + k2y * dt * 0.5,
                    this.z + k2z * dt * 0.5
                );
                
                const [k4x, k4y, k4z] = this.getVelocityAt(fluid,
                    this.x + k3x * dt,
                    this.y + k3y * dt,
                    this.z + k3z * dt
                );
                
                // Update position with RK4
                const speedMult = 5.0; // Speed up visualization
                this.x += (k1x + 2*k2x + 2*k3x + k4x) / 6 * dt * speedMult;
                this.y += (k1y + 2*k2y + 2*k3y + k4y) / 6 * dt * speedMult;
                this.z += (k1z + 2*k2z + 2*k3z + k4z) / 6 * dt * speedMult;
                
                // Add current position to trail
                this.points.push([this.x, this.y, this.z]);
                
                // Limit trail length
                if (this.points.length > this.maxAge) {
                    this.points.shift();
                }
                
                this.age++;
                
                // Periodically reset to keep flow fresh
                if (this.age > streamlineLength * 3) {
                    this.reset();
                }
                
                // Update line geometry
                this.updateGeometry(fluid);
            }
            
            updateGeometry(fluid) {
                const positions = this.line.geometry.attributes.position.array;
                const colors = this.line.geometry.attributes.color.array;
                
                const density1 = parseFloat(document.getElementById('density1').value);
                const density2 = parseFloat(document.getElementById('density2').value);
                const minDens = Math.min(density1, density2);
                const maxDens = Math.max(density1, density2);
                
                const numPoints = this.points.length;
                
                for (let i = 0; i < this.maxAge; i++) {
                    if (i < numPoints) {
                        const [x, y, z] = this.points[i];
                        positions[i * 3] = x;
                        positions[i * 3 + 1] = y;
                        positions[i * 3 + 2] = z;
                        
                        // Get density at this point
                        const gi = Math.floor(x);
                        const gj = Math.floor(y);
                        const gk = Math.floor(z);
                        
                        if (gi >= 0 && gi < N && gj >= 0 && gj < N && gk >= 0 && gk < N) {
                            const idx = fluid.IX(gi, gj, gk);
                            const density = fluid.density[idx];
                            const [r, g, b] = getDensityColor(density, minDens, maxDens);
                            
                            // Fade from tail to head (older = dimmer)
                            const fade = Math.pow(i / numPoints, 0.7); // Power curve for smoother fade
                            colors[i * 3] = r * fade;
                            colors[i * 3 + 1] = g * fade;
                            colors[i * 3 + 2] = b * fade;
                        } else {
                            colors[i * 3] = 0.5;
                            colors[i * 3 + 1] = 0.5;
                            colors[i * 3 + 2] = 0.5;
                        }
                    } else {
                        // For unfilled points, copy the last valid point (creates continuous line)
                        if (numPoints > 0) {
                            const [x, y, z] = this.points[numPoints - 1];
                            positions[i * 3] = x;
                            positions[i * 3 + 1] = y;
                            positions[i * 3 + 2] = z;
                        } else {
                            positions[i * 3] = this.x;
                            positions[i * 3 + 1] = this.y;
                            positions[i * 3 + 2] = this.z;
                        }
                        colors[i * 3] = 0;
                        colors[i * 3 + 1] = 0;
                        colors[i * 3 + 2] = 0;
                    }
                }
                
                this.line.geometry.attributes.position.needsUpdate = true;
                this.line.geometry.attributes.color.needsUpdate = true;
                
                // Set draw range to only show valid points
                this.line.geometry.setDrawRange(0, Math.max(2, numPoints));
            }
        }

        // Initialize streamlines
        for (let i = 0; i < streamlineCount; i++) {
            streamlines.push(new Streamline());
        }

        // Bounding box
        const boxGeometry = new THREE.BoxGeometry(N, N, N);
        const edges = new THREE.EdgesGeometry(boxGeometry);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x444444 });
        const box = new THREE.LineSegments(edges, lineMaterial);
        box.position.set(N / 2, N / 2, N / 2);
        scene.add(box);

        // Fluid simulation
        const fluid = new FluidSim3D(N);
        let simRunning = false;

        function getDensityColor(density, minDens, maxDens) {
            const t = (density - minDens) / (maxDens - minDens);
            const r = t;
            const g = 0.5 + 0.5 * Math.sin(t * Math.PI);
            const b = 1 - t;
            return [r, g, b];
        }

        function updateParticles() {
            const positions = particles.geometry.attributes.position.array;
            const colors = particles.geometry.attributes.color.array;
            
            const density1 = parseFloat(document.getElementById('density1').value);
            const density2 = parseFloat(document.getElementById('density2').value);
            const minDens = Math.min(density1, density2);
            const maxDens = Math.max(density1, density2);

            for (let i = 0; i < particleCount; i++) {
                const x = Math.floor(positions[i * 3]);
                const y = Math.floor(positions[i * 3 + 1]);
                const z = Math.floor(positions[i * 3 + 2]);
                
                const idx = fluid.IX(x, y, z);
                const density = fluid.density[idx];
                
                const [r, g, b] = getDensityColor(density, minDens, maxDens);
                colors[i * 3] = r;
                colors[i * 3 + 1] = g;
                colors[i * 3 + 2] = b;
            }

            particles.geometry.attributes.color.needsUpdate = true;
        }

        function updateStreamlines() {
            for (let i = 0; i < streamlineCount; i++) {
                streamlines[i].update(fluid, dt);
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (simRunning) {
                fluid.step(dt);
                
                const vizMode = document.getElementById('vizMode').value;
                if (vizMode === 'particles') {
                    updateParticles();
                } else {
                    updateStreamlines();
                }
            }

            // Update camera position
            const centerX = N / 2;
            const centerY = N / 2;
            const centerZ = N / 2;
            
            camera.position.x = centerX + cameraRadius * Math.sin(cameraPhi) * Math.cos(cameraTheta);
            camera.position.y = centerY + cameraRadius * Math.cos(cameraPhi);
            camera.position.z = centerZ + cameraRadius * Math.sin(cameraPhi) * Math.sin(cameraTheta);
            camera.lookAt(centerX, centerY, centerZ);

            renderer.render(scene, camera);
        }

        // UI Controls
        document.getElementById('vizMode').addEventListener('change', (e) => {
            const mode = e.target.value;
            particles.visible = (mode === 'particles');
            streamlineGroup.visible = (mode === 'streamlines');
            
            // Reset streamlines when switching to them
            if (mode === 'streamlines') {
                streamlines.forEach(s => s.reset());
            }
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            if (!simRunning) {
                const density1 = parseFloat(document.getElementById('density1').value);
                const density2 = parseFloat(document.getElementById('density2').value);
                
                fluid.initialize(density1, density2);
                fluid.removeBarrier();
                
                const vizMode = document.getElementById('vizMode').value;
                if (vizMode === 'particles') {
                    updateParticles();
                } else {
                    streamlines.forEach(s => s.reset());
                }
                
                simRunning = true;
                document.getElementById('startBtn').disabled = true;
            }
        });

        document.getElementById('reset').addEventListener('click', () => {
            const density1 = parseFloat(document.getElementById('density1').value);
            const density2 = parseFloat(document.getElementById('density2').value);
            
            fluid.initialize(density1, density2);
            
            const vizMode = document.getElementById('vizMode').value;
            if (vizMode === 'particles') {
                updateParticles();
            } else {
                streamlines.forEach(s => s.reset());
            }
            
            simRunning = false;
            document.getElementById('startBtn').disabled = false;
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize
        const density1 = parseFloat(document.getElementById('density1').value);
        const density2 = parseFloat(document.getElementById('density2').value);
        fluid.initialize(density1, density2);
        updateParticles();

        animate();
    </script>
</body>
</html>
