<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimal Channel Networks | Drainage Basin Optimization</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600&family=IBM+Plex+Sans:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0e17;
            --bg-secondary: #141923;
            --bg-tertiary: #1a2332;
            --accent-primary: #00d9ff;
            --accent-secondary: #ff006e;
            --accent-tertiary: #8b5cf6;
            --accent-green: #10b981;
            --text-primary: #e0e6ed;
            --text-secondary: #8b95a5;
            --border: rgba(0, 217, 255, 0.2);
        }

        body {
            font-family: 'IBM Plex Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 217, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 217, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
            z-index: 0;
        }

        .container {
            position: relative;
            z-index: 1;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            padding: 2rem 3rem;
            border-bottom: 1px solid var(--border);
            background: rgba(10, 14, 23, 0.8);
            backdrop-filter: blur(10px);
        }

        h1 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 300;
            font-family: 'JetBrains Mono', monospace;
        }

        .main-content {
            flex: 1;
            display: flex;
            gap: 2rem;
            padding: 2rem 3rem;
            overflow: hidden;
        }

        .simulation-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .canvas-container {
            position: relative;
            flex: 1;
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-secondary);
            box-shadow: 0 8px 32px rgba(0, 217, 255, 0.1);
        }

        canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .visualization-modes {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .mode-btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            padding: 0.5rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-weight: 400;
        }

        .mode-btn:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
            transform: translateY(-2px);
        }

        .mode-btn.active {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
            font-weight: 600;
        }

        .controls-panel {
            width: 320px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 217, 255, 0.1);
        }

        .control-section {
            margin-bottom: 1.5rem;
        }

        .control-section h3 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--accent-primary);
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .control-group {
            margin-bottom: 1rem;
        }

        .control-group label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(0, 217, 255, 0.5);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px rgba(0, 217, 255, 0.5);
        }

        .value-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--accent-primary);
            float: right;
        }

        .btn {
            font-family: 'JetBrains Mono', monospace;
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
            margin-bottom: 0.5rem;
        }

        .btn:hover {
            border-color: var(--accent-primary);
            background: rgba(0, 217, 255, 0.1);
            transform: translateY(-2px);
        }

        .stats {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-secondary);
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            line-height: 1.6;
        }

        .stats-value {
            color: var(--accent-primary);
            font-weight: 600;
        }

        .info-box {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-secondary);
            padding: 1rem;
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 4px;
            line-height: 1.6;
            margin-bottom: 1rem;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .container > * {
            animation: fadeIn 0.6s ease-out backwards;
        }

        header {
            animation-delay: 0.1s;
        }

        .simulation-panel {
            animation-delay: 0.2s;
        }

        .controls-panel {
            animation-delay: 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Optimal Channel Networks</h1>
            <div class="subtitle">Hill Tunneling Optimization â€¢ Energy Minimization (E = Î£A^Î³L)</div>
        </header>

        <div class="main-content">
            <div class="simulation-panel">
                <div class="visualization-modes">
                    <button class="mode-btn active" data-mode="network">Channel Network</button>
                    <button class="mode-btn" data-mode="elevation">Elevation Field</button>
                    <button class="mode-btn" data-mode="flow">Flow Accumulation</button>
                    <button class="mode-btn" data-mode="energy">Energy Dissipation</button>
                    <button class="mode-btn" data-mode="slope">Slope Field</button>
                </div>
                <div class="canvas-container">
                    <canvas id="networkCanvas"></canvas>
                </div>
                <div class="canvas-container" style="height: 200px;">
                    <canvas id="energyPlot"></canvas>
                </div>
            </div>

            <div class="controls-panel">
                <div class="info-box">
                    ðŸ’¡ Three algorithms: HTO (multi-step tunneling + memory), SA (temperature-based acceptance), Gradient (compute all Î”E, pick best)
                </div>

                <div class="control-section">
                    <h3>Optimization Algorithm</h3>
                    <button class="btn" id="hto-mode" style="background: rgba(0, 217, 255, 0.2); border-color: var(--accent-primary);">Hill Tunneling (HTO)</button>
                    <button class="btn" id="sa-mode">Simulated Annealing (SA)</button>
                    <button class="btn" id="gradient-mode">Greedy Gradient</button>
                </div>

                <div class="control-section">
                    <h3>Network Parameters</h3>
                    <div class="stats">
                        <div>Grid Size: <span class="stats-value" id="grid-size-display">10Ã—10</span></div>
                        <div>Min Drainage: <span class="stats-value">1</span></div>
                        <div>Energy Exp (Î³): <span class="stats-value">1.0</span></div>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>Grid Size</h3>
                    <button class="btn" id="grid-10" style="background: rgba(0, 217, 255, 0.2); border-color: var(--accent-primary);">10Ã—10</button>
                    <button class="btn" id="grid-20">20Ã—20</button>
                </div>

                <div class="control-section">
                    <h3>Actions</h3>
                    <button class="btn" id="evolve-btn">Optimize Network (100 swaps)</button>
                    <button class="btn" id="reset-btn">Reset Network</button>
                    <button class="btn" id="auto-btn">Auto-Optimize</button>
                </div>

                <div class="control-section">
                    <h3>Network Metrics</h3>
                    <div class="stats">
                        <div>Total Length: <span class="stats-value" id="total-length">0</span></div>
                        <div>Channel Count: <span class="stats-value" id="channel-count">0</span></div>
                        <div>Bifurcation Ratio: <span class="stats-value" id="bifurcation">0.0</span></div>
                        <div>Total Energy: <span class="stats-value" id="total-energy">0.0</span></div>
                        <div>Max Flow: <span class="stats-value" id="max-flow">0</span></div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Algorithm Status</h3>
                    <div class="stats">
                        <div>Mode: <span class="stats-value" id="algo-mode">HTO</span></div>
                        <div>Status: <span class="stats-value" id="algo-status">Phase 1</span></div>
                        <div>Evaluations: <span class="stats-value" id="eval-count">0</span></div>
                        <div>Improvements: <span class="stats-value" id="success-count">0</span></div>
                        <div>Accept Rate: <span class="stats-value" id="accept-rate">0%</span></div>
                        <div id="success-lengths-row">Success Lengths: <span class="stats-value" id="success-lengths">0</span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Optimal Channel Network Simulation
        // Based on OCN theory (Rodriguez-Iturbe & Rinaldo)
        
        class ChannelNetwork {
            constructor(N) {
                this.N = N;
                this.size = N * N;
                
                // Network connectivity - each cell points to its downstream neighbor
                this.downstream = new Int32Array(this.size);
                
                // Flow accumulation (drainage area)
                this.flowAccum = new Float32Array(this.size);
                
                // Distance to outlet (network coordinate)
                this.distToOutlet = new Float32Array(this.size);
                
                // Energy dissipation
                this.energy = new Float32Array(this.size);
                
                // Track recently swapped links for visualization
                this.recentSwaps = new Set();
                
                // Optimization mode
                this.optimizationMode = 'hto'; // 'hto', 'sa', or 'gradient'
                
                // Hill Tunneling Optimization parameters (from thesis)
                this.alpha = 30; // Max changes before evaluation (tuned via meta-optimization)
                this.beta = 50;  // Max consecutive failures in phase 1
                this.omega = 500; // Max consecutive failures in phase 2 (10:1 ratio)
                
                this.phase = 1; // Start in uniform random phase
                this.successLengths = []; // List of successful change lengths
                
                // Simulated Annealing parameters (Johnson et al. 1989)
                this.temperature = 50; // Initial temperature
                this.initialTemperature = 50;
                this.saCoolingRate = 0.95; // Geometric cooling schedule
                this.saIterationsPerTemp = 100; // Changes before cooling
                this.saIterationsAtTemp = 0;
                
                // Shared parameters
                this.consecutiveFailures = 0;
                
                // Energy parameters
                this.gamma = 1.0;   // Energy exponent from thesis (was 0.5 in some OCN papers)
                this.minDrainageArea = 1;
                
                // Outlet
                this.outletX = 0; // Lower left corner
                this.outletY = N - 1;
                this.outletIdx = this.IX(this.outletX, this.outletY);
                
                // Stats
                this.totalEnergy = 0;
                this.evaluationCount = 0;
                this.improvementCount = 0;
                this.energyHistory = [];
                this.changesPerSuccess = [];
                
                this.buildInitialNetwork();
            }
            
            IX(i, j) {
                return i + this.N * j;
            }
            
            getCoords(idx) {
                return {
                    i: idx % this.N,
                    j: Math.floor(idx / this.N)
                };
            }
            
            buildInitialNetwork() {
                // Initialize: outlet points to itself, track which nodes are in the tree
                for (let idx = 0; idx < this.size; idx++) {
                    this.downstream[idx] = -1; // Unconnected
                }
                this.downstream[this.outletIdx] = this.outletIdx; // Outlet points to itself
                
                // Connect outlet to one random neighbor to start
                // A(3541,3482)=1 means 3482 flows into 3541
                const neighbors = this.getValidNeighbors(this.outletIdx);
                if (neighbors.length > 0) {
                    const firstNode = neighbors[Math.floor(Math.random() * neighbors.length)];
                    this.downstream[firstNode] = this.outletIdx;
                }
                
                // Track which nodes are already in the tree
                const inTree = new Set();
                inTree.add(this.outletIdx);
                for (let idx = 0; idx < this.size; idx++) {
                    if (this.downstream[idx] >= 0) {
                        inTree.add(idx);
                    }
                }
                
                // Build tree: repeatedly pick a random connected node and add an unconnected neighbor
                while (inTree.size < this.size) {
                    // Pick random node that's already in tree
                    const treeArray = Array.from(inTree);
                    const targetNode = treeArray[Math.floor(Math.random() * treeArray.length)];
                    
                    // Get valid neighbors
                    const neighbors = this.getValidNeighbors(targetNode);
                    
                    // Try random neighbor
                    if (neighbors.length > 0) {
                        const candidateNode = neighbors[Math.floor(Math.random() * neighbors.length)];
                        
                        // Check if candidate is valid:
                        // 1. Not already in tree (Check = Check + sum(sum(A(:,Next))))
                        // 2. Not the outlet
                        // 3. Not zero (invalid)
                        
                        if (!inTree.has(candidateNode) && 
                            candidateNode !== this.outletIdx && 
                            candidateNode >= 0) {
                            // Add to tree
                            this.downstream[candidateNode] = targetNode;
                            inTree.add(candidateNode);
                        }
                    }
                }
                
                // Additional randomization: 3600 random reconnections with loop checking
                // This is the "Additionally Randomize" section from Initializer.m
                for (let iter = 0; iter < 3600; iter++) {
                    // Pick random node (not outlet)
                    let node = Math.floor(Math.random() * this.size);
                    if (node === this.outletIdx) continue;
                    
                    const oldDown = this.downstream[node];
                    const neighbors = this.getValidNeighbors(node);
                    
                    if (neighbors.length > 0) {
                        const newDown = neighbors[Math.floor(Math.random() * neighbors.length)];
                        
                        // Check validity
                        if (newDown === oldDown || newDown === this.outletIdx) {
                            continue;
                        }
                        
                        // Try the change
                        this.downstream[node] = newDown;
                        
                        // Check for loop by walking downstream to outlet
                        let test = newDown;
                        let loopDetected = false;
                        const visited = new Set();
                        
                        while (test !== this.outletIdx && !visited.has(test)) {
                            visited.add(test);
                            
                            if (test === node) {
                                // Loop detected!
                                loopDetected = true;
                                break;
                            }
                            
                            test = this.downstream[test];
                            
                            if (test < 0) {
                                // Disconnected - shouldn't happen but safe to reject
                                loopDetected = true;
                                break;
                            }
                        }
                        
                        if (loopDetected) {
                            // Revert
                            this.downstream[node] = oldDown;
                        }
                        // Otherwise keep the change (Omega = 2, success)
                    }
                }
                
                this.computeFlowAccumulation();
                this.computeDistances();
                this.computeEnergy();
            }
            
            computeFlowAccumulation() {
                // Reset
                this.flowAccum.fill(1);
                
                // Process from furthest to nearest (reverse topological order)
                const sorted = this.topologicalSort();
                
                for (let i = sorted.length - 1; i >= 0; i--) {
                    const idx = sorted[i];
                    const down = this.downstream[idx];
                    
                    if (down !== idx) {
                        this.flowAccum[down] += this.flowAccum[idx];
                    }
                }
            }
            
            topologicalSort() {
                // BFS from outlet backwards to get processing order
                const visited = new Uint8Array(this.size);
                const queue = [this.outletIdx];
                const result = [];
                visited[this.outletIdx] = 1;
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    result.push(current);
                    
                    // Find all cells that flow into current
                    for (let idx = 0; idx < this.size; idx++) {
                        if (!visited[idx] && this.downstream[idx] === current) {
                            visited[idx] = 1;
                            queue.push(idx);
                        }
                    }
                }
                
                return result;
            }
            
            computeDistances() {
                // Network distance to outlet
                this.distToOutlet.fill(Infinity);
                this.distToOutlet[this.outletIdx] = 0;
                
                const sorted = this.topologicalSort();
                
                for (const idx of sorted) {
                    const down = this.downstream[idx];
                    if (down !== idx) {
                        const dist = this.getEuclideanDist(idx, down);
                        this.distToOutlet[idx] = this.distToOutlet[down] + dist;
                    }
                }
            }
            
            getEuclideanDist(idx1, idx2) {
                const c1 = this.getCoords(idx1);
                const c2 = this.getCoords(idx2);
                const dx = c1.i - c2.i;
                const dy = c1.j - c2.j;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            computeEnergy() {
                // Energy dissipation: E = sum_i (A_i^gamma * L_i)
                // where A_i is drainage area, L_i is link length
                // gamma typically 0.5 (from hydraulic geometry)
                
                this.totalEnergy = 0;
                
                for (let idx = 0; idx < this.size; idx++) {
                    const down = this.downstream[idx];
                    if (down !== idx) {
                        const length = this.getEuclideanDist(idx, down);
                        this.energy[idx] = Math.pow(this.flowAccum[idx], this.gamma) * length;
                        this.totalEnergy += this.energy[idx];
                    } else {
                        this.energy[idx] = 0;
                    }
                }
            }
            
            getValidNeighbors(idx) {
                // Get valid downstream neighbors (8-connected, excluding upstream)
                const { i, j } = this.getCoords(idx);
                const neighbors = [];
                
                for (let dj = -1; dj <= 1; dj++) {
                    for (let di = -1; di <= 1; di++) {
                        if (di === 0 && dj === 0) continue;
                        
                        const ni = i + di;
                        const nj = j + dj;
                        
                        if (ni >= 0 && ni < this.N && nj >= 0 && nj < this.N) {
                            const nidx = this.IX(ni, nj);
                            
                            // Don't create loops - neighbor must not drain into idx
                            if (!this.wouldCreateLoop(idx, nidx)) {
                                neighbors.push(nidx);
                            }
                        }
                    }
                }
                
                return neighbors;
            }
            
            wouldCreateLoop(source, newTarget) {
                // Check if routing source to newTarget would create a loop
                // by walking downstream from newTarget
                let current = newTarget;
                const visited = new Set();
                
                while (current !== this.outletIdx && !visited.has(current)) {
                    visited.add(current);
                    current = this.downstream[current];
                    
                    if (current === source) {
                        return true; // Loop detected
                    }
                }
                
                return false;
            }
            
            makeRandomChange() {
                // Select a random cell (not outlet) and give it a new downstream neighbor
                let idx = Math.floor(Math.random() * this.size);
                while (idx === this.outletIdx) {
                    idx = Math.floor(Math.random() * this.size);
                }
                
                const neighbors = this.getValidNeighbors(idx);
                if (neighbors.length === 0) return null;
                
                const oldDown = this.downstream[idx];
                const newDown = neighbors[Math.floor(Math.random() * neighbors.length)];
                
                if (newDown !== oldDown) {
                    this.downstream[idx] = newDown;
                    return { idx, oldDown, newDown };
                }
                return null;
            }
            
            revertChanges(changes) {
                // Revert a series of changes
                for (const change of changes) {
                    this.downstream[change.idx] = change.oldDown;
                }
            }
            
            hillTunnelingStep() {
                // Hill Tunneling Optimization algorithm from thesis
                
                // Phase 1 or Phase 2?
                let numChanges;
                if (this.phase === 1) {
                    // Uniform distribution [1, alpha]
                    numChanges = Math.floor(Math.random() * this.alpha) + 1;
                } else {
                    // Memory-based: pick from successful lengths list Â± [0,2]
                    if (this.successLengths.length === 0) {
                        return false; // No successful lengths yet
                    }
                    const baseLength = this.successLengths[Math.floor(Math.random() * this.successLengths.length)];
                    const perturbation = Math.floor(Math.random() * 5) - 2; // [-2, 2]
                    numChanges = Math.max(1, baseLength + perturbation);
                }
                
                // Store current configuration
                const savedDownstream = new Int32Array(this.downstream);
                const oldEnergy = this.totalEnergy;
                
                // Make numChanges random changes
                const changes = [];
                for (let i = 0; i < numChanges; i++) {
                    const change = this.makeRandomChange();
                    if (change) {
                        changes.push(change);
                    }
                }
                
                // Evaluate objective function
                this.computeFlowAccumulation();
                this.computeDistances();
                this.computeEnergy();
                
                const newEnergy = this.totalEnergy;
                this.evaluationCount++;
                
                if (newEnergy < oldEnergy) {
                    // Accept!
                    this.improvementCount++;
                    this.consecutiveFailures = 0;
                    
                    // Add to successful lengths
                    this.successLengths.push(numChanges);
                    
                    // Track energy history
                    this.energyHistory.push(newEnergy);
                    this.changesPerSuccess.push(numChanges);
                    
                    // Highlight changed links
                    for (const change of changes) {
                        this.recentSwaps.add(change.idx);
                    }
                    
                    // Keep only recent swaps highlighted (last 30)
                    if (this.recentSwaps.size > 30) {
                        const toDelete = Array.from(this.recentSwaps).slice(0, this.recentSwaps.size - 30);
                        toDelete.forEach(idx => this.recentSwaps.delete(idx));
                    }
                    
                    return true;
                } else {
                    // Reject - revert
                    this.downstream.set(savedDownstream);
                    this.computeFlowAccumulation();
                    this.computeDistances();
                    this.computeEnergy();
                    
                    this.consecutiveFailures++;
                    
                    // Check if we should switch phases
                    if (this.phase === 1 && this.consecutiveFailures >= this.beta) {
                        this.phase = 2;
                        this.consecutiveFailures = 0;
                    } else if (this.phase === 2 && this.consecutiveFailures >= this.omega) {
                        // Optimization complete
                        return false;
                    }
                    
                    return true;
                }
            }
            
            simulatedAnnealingStep() {
                // Simulated Annealing from Johnson et al. (1989)
                
                // Make a single random change
                let idx = Math.floor(Math.random() * this.size);
                while (idx === this.outletIdx) {
                    idx = Math.floor(Math.random() * this.size);
                }
                
                const neighbors = this.getValidNeighbors(idx);
                if (neighbors.length === 0) return true;
                
                const oldDown = this.downstream[idx];
                const newDown = neighbors[Math.floor(Math.random() * neighbors.length)];
                
                if (newDown === oldDown) return true;
                
                const oldEnergy = this.totalEnergy;
                
                // Make the change
                this.downstream[idx] = newDown;
                this.computeFlowAccumulation();
                this.computeDistances();
                this.computeEnergy();
                
                const newEnergy = this.totalEnergy;
                const deltaE = newEnergy - oldEnergy;
                
                this.evaluationCount++;
                this.saIterationsAtTemp++;
                
                // Metropolis criterion: accept if improves OR with probability exp(-Î”E/T)
                const acceptProbability = deltaE < 0 ? 1 : Math.exp(-deltaE / this.temperature);
                
                if (Math.random() < acceptProbability) {
                    // Accept
                    if (deltaE < 0) {
                        this.improvementCount++;
                        this.recentSwaps.add(idx);
                        
                        // Keep only recent swaps highlighted
                        if (this.recentSwaps.size > 30) {
                            const arr = Array.from(this.recentSwaps);
                            this.recentSwaps.delete(arr[0]);
                        }
                    }
                    
                    this.consecutiveFailures = 0;
                    this.energyHistory.push(newEnergy);
                } else {
                    // Reject - revert
                    this.downstream[idx] = oldDown;
                    this.computeFlowAccumulation();
                    this.computeDistances();
                    this.computeEnergy();
                    
                    this.consecutiveFailures++;
                }
                
                // Cool down temperature periodically
                if (this.saIterationsAtTemp >= this.saIterationsPerTemp) {
                    this.temperature *= this.saCoolingRate;
                    this.saIterationsAtTemp = 0;
                }
                
                // Stop if temperature too low or too many consecutive failures
                if (this.temperature < 0.001 || this.consecutiveFailures >= 1000) {
                    return false;
                }
                
                return true;
            }
            
            greedyGradientStep() {
                // "Adam-like" for discrete optimization:
                // Compute Î”E for ALL possible single swaps, pick the best
                
                let bestDeltaE = 0;
                let bestIdx = -1;
                let bestNewDown = -1;
                
                const currentEnergy = this.totalEnergy;
                
                // For each cell (except outlet)
                for (let idx = 0; idx < this.size; idx++) {
                    if (idx === this.outletIdx) continue;
                    
                    const currentDown = this.downstream[idx];
                    const neighbors = this.getValidNeighbors(idx);
                    
                    // Try each valid neighbor
                    for (const newDown of neighbors) {
                        if (newDown === currentDown) continue;
                        
                        // Temporarily make the swap
                        this.downstream[idx] = newDown;
                        this.computeFlowAccumulation();
                        this.computeDistances();
                        this.computeEnergy();
                        
                        const newEnergy = this.totalEnergy;
                        const deltaE = newEnergy - currentEnergy;
                        
                        this.evaluationCount++;
                        
                        // Is this the best improvement so far?
                        if (deltaE < bestDeltaE) {
                            bestDeltaE = deltaE;
                            bestIdx = idx;
                            bestNewDown = newDown;
                        }
                        
                        // Revert
                        this.downstream[idx] = currentDown;
                    }
                }
                
                // Restore original state
                this.computeFlowAccumulation();
                this.computeDistances();
                this.computeEnergy();
                
                // Apply the best swap if one was found
                if (bestIdx >= 0 && bestDeltaE < 0) {
                    this.downstream[bestIdx] = bestNewDown;
                    this.computeFlowAccumulation();
                    this.computeDistances();
                    this.computeEnergy();
                    
                    this.improvementCount++;
                    this.consecutiveFailures = 0;
                    this.recentSwaps.add(bestIdx);
                    
                    // Keep only recent swaps highlighted
                    if (this.recentSwaps.size > 30) {
                        const arr = Array.from(this.recentSwaps);
                        this.recentSwaps.delete(arr[0]);
                    }
                    
                    this.energyHistory.push(this.totalEnergy);
                    
                    return true;
                } else {
                    // No improving move found - at local minimum
                    this.consecutiveFailures++;
                    return this.consecutiveFailures < 10; // Stop after 10 failures
                }
            }
            
            optimizeNetwork(steps = 100) {
                for (let i = 0; i < steps; i++) {
                    let shouldContinue;
                    
                    switch(this.optimizationMode) {
                        case 'hto':
                            shouldContinue = this.hillTunnelingStep();
                            break;
                        case 'sa':
                            shouldContinue = this.simulatedAnnealingStep();
                            break;
                        case 'gradient':
                            shouldContinue = this.greedyGradientStep();
                            break;
                        default:
                            shouldContinue = this.hillTunnelingStep();
                    }
                    
                    if (!shouldContinue) {
                        break; // Optimization complete
                    }
                }
            }
            
            setOutlet(x, y) {
                const newOutletIdx = this.IX(
                    Math.floor(x * this.N),
                    Math.floor(y * this.N)
                );
                
                if (newOutletIdx !== this.outletIdx) {
                    this.outletX = Math.floor(x * this.N);
                    this.outletY = Math.floor(y * this.N);
                    this.outletIdx = newOutletIdx;
                    this.buildInitialNetwork();
                    this.recentSwaps.clear();
                    this.phase = 1;
                    this.successLengths = [];
                    this.consecutiveFailures = 0;
                    this.evaluationCount = 0;
                    this.improvementCount = 0;
                    this.energyHistory = [];
                    this.changesPerSuccess = [];
                }
            }
            
            setOptimizationMode(mode) {
                this.optimizationMode = mode;
                
                // Reset algorithm-specific state
                this.phase = 1;
                this.successLengths = [];
                this.temperature = this.initialTemperature;
                this.saIterationsAtTemp = 0;
                this.consecutiveFailures = 0;
                this.evaluationCount = 0;
                this.improvementCount = 0;
                this.energyHistory = [];
                this.changesPerSuccess = [];
                this.recentSwaps.clear();
            }
            
            reset() {
                this.buildInitialNetwork();
                this.recentSwaps.clear();
                this.phase = 1;
                this.successLengths = [];
                this.temperature = this.initialTemperature;
                this.saIterationsAtTemp = 0;
                this.consecutiveFailures = 0;
                this.evaluationCount = 0;
                this.improvementCount = 0;
                this.energyHistory = [];
                this.changesPerSuccess = [];
            }
            
            getNetworkStats() {
                let totalLength = 0;
                let maxFlow = 0;
                let channelCount = 0;
                
                for (let idx = 0; idx < this.size; idx++) {
                    if (this.flowAccum[idx] >= this.minDrainageArea) {
                        channelCount++;
                    }
                    
                    const down = this.downstream[idx];
                    if (down !== idx) {
                        totalLength += this.getEuclideanDist(idx, down);
                    }
                    
                    if (this.flowAccum[idx] > maxFlow) {
                        maxFlow = this.flowAccum[idx];
                    }
                }
                
                const drainageDensity = totalLength / this.size;
                
                // Estimate bifurcation ratio from network structure
                let junctions = 0;
                let totalBranches = 0;
                
                for (let idx = 0; idx < this.size; idx++) {
                    let tributaries = 0;
                    for (let i = 0; i < this.size; i++) {
                        if (this.downstream[i] === idx && i !== idx) {
                            tributaries++;
                        }
                    }
                    if (tributaries > 1) {
                        junctions++;
                        totalBranches += tributaries;
                    }
                }
                
                const bifurcationRatio = junctions > 0 ? totalBranches / junctions : 0;
                
                const acceptanceRate = this.evaluationCount > 0 ? 
                    (this.improvementCount / this.evaluationCount * 100).toFixed(1) : 0;
                
                let algorithmStatus = '';
                if (this.optimizationMode === 'hto') {
                    algorithmStatus = this.phase === 1 ? 'Phase 1 (Uniform)' : 'Phase 2 (Memory)';
                } else if (this.optimizationMode === 'sa') {
                    algorithmStatus = `T=${this.temperature.toFixed(2)}`;
                } else if (this.optimizationMode === 'gradient') {
                    algorithmStatus = 'Steepest Descent';
                }
                
                return {
                    totalLength: totalLength.toFixed(1),
                    channelCount,
                    drainageDensity,
                    bifurcationRatio,
                    totalEnergy: this.totalEnergy.toFixed(1),
                    maxFlow: Math.floor(maxFlow),
                    evaluationCount: this.evaluationCount,
                    improvementCount: this.improvementCount,
                    acceptanceRate,
                    algorithmStatus,
                    successLengthsCount: this.successLengths.length,
                    mode: this.optimizationMode
                };
            }
        }
        
        // Energy Plot Renderer
        class EnergyPlotter {
            constructor(canvas, network) {
                this.canvas = canvas;
                this.network = network;
                this.ctx = canvas.getContext('2d');
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }
            
            render() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const padding = 40;
                
                // Clear background
                this.ctx.fillStyle = '#141923';
                this.ctx.fillRect(0, 0, width, height);
                
                const history = this.network.energyHistory;
                if (history.length < 2) return;
                
                // Find min/max for scaling
                let minE = Math.min(...history);
                let maxE = Math.max(...history);
                const range = maxE - minE || 1;
                
                // Add some padding to the range
                minE -= range * 0.1;
                maxE += range * 0.1;
                const scaledRange = maxE - minE;
                
                const plotWidth = width - 2 * padding;
                const plotHeight = height - 2 * padding;
                
                // Draw axes
                this.ctx.strokeStyle = 'rgba(139, 149, 165, 0.3)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, padding);
                this.ctx.lineTo(padding, height - padding);
                this.ctx.lineTo(width - padding, height - padding);
                this.ctx.stroke();
                
                // Draw grid lines
                this.ctx.strokeStyle = 'rgba(139, 149, 165, 0.1)';
                for (let i = 0; i <= 5; i++) {
                    const y = padding + (plotHeight * i / 5);
                    this.ctx.beginPath();
                    this.ctx.moveTo(padding, y);
                    this.ctx.lineTo(width - padding, y);
                    this.ctx.stroke();
                }
                
                // Draw energy curve
                this.ctx.strokeStyle = '#00d9ff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                for (let i = 0; i < history.length; i++) {
                    const x = padding + (i / (history.length - 1)) * plotWidth;
                    const y = height - padding - ((history[i] - minE) / scaledRange) * plotHeight;
                    
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();
                
                // Add shadow effect
                this.ctx.strokeStyle = 'rgba(0, 217, 255, 0.3)';
                this.ctx.lineWidth = 4;
                this.ctx.stroke();
                
                // Labels
                this.ctx.fillStyle = '#8b95a5';
                this.ctx.font = '11px JetBrains Mono';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Successful Evaluations', width / 2, height - 5);
                
                this.ctx.save();
                this.ctx.translate(15, height / 2);
                this.ctx.rotate(-Math.PI / 2);
                this.ctx.fillText('Energy (E = Î£A^Î³L)', 0, 0);
                this.ctx.restore();
                
                // Y-axis labels
                this.ctx.textAlign = 'right';
                for (let i = 0; i <= 5; i++) {
                    const value = maxE - (scaledRange * i / 5);
                    const y = padding + (plotHeight * i / 5);
                    this.ctx.fillText(value.toFixed(0), padding - 5, y + 4);
                }
                
                // X-axis labels
                this.ctx.textAlign = 'center';
                const xLabels = [0, Math.floor(history.length / 2), history.length - 1];
                for (const label of xLabels) {
                    const x = padding + (label / (history.length - 1)) * plotWidth;
                    this.ctx.fillText(label.toString(), x, height - padding + 15);
                }
                
                // Current value indicator
                if (history.length > 0) {
                    const lastE = history[history.length - 1];
                    const x = width - padding;
                    const y = height - padding - ((lastE - minE) / scaledRange) * plotHeight;
                    
                    this.ctx.fillStyle = '#ff006e';
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 4, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
        }
        
        // Renderer
        class NetworkRenderer {
            constructor(canvas, network) {
                this.canvas = canvas;
                this.network = network;
                this.ctx = canvas.getContext('2d');
                this.mode = 'network';
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }
            
            render() {
                this.ctx.fillStyle = '#141923';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                switch(this.mode) {
                    case 'network':
                        this.renderNetwork();
                        break;
                    case 'elevation':
                        this.renderElevation();
                        break;
                    case 'flow':
                        this.renderFlowAccumulation();
                        break;
                    case 'energy':
                        this.renderEnergy();
                        break;
                    case 'slope':
                        this.renderSlope();
                        break;
                }
            }
            
            renderNetwork() {
                const N = this.network.N;
                const cellSize = Math.min(this.canvas.width, this.canvas.height) / N;
                
                // Draw background
                this.ctx.fillStyle = '#1a2332';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw all network links first
                for (let idx = 0; idx < this.network.size; idx++) {
                    const down = this.network.downstream[idx];
                    if (down === idx) continue; // Skip outlet
                    
                    const c1 = this.network.getCoords(idx);
                    const c2 = this.network.getCoords(down);
                    
                    const flow = this.network.flowAccum[idx];
                    const width = Math.max(0.5, Math.sqrt(flow) * 0.15);
                    
                    // Color by flow accumulation
                    const t = Math.min(1, Math.log(flow + 1) / Math.log(this.network.size));
                    const r = Math.floor(t * 100);
                    const g = Math.floor((0.7 + t * 0.3) * 217);
                    const b = Math.floor(200 + t * 55);
                    
                    // Check if this link was recently swapped
                    const isRecent = this.network.recentSwaps.has(idx);
                    
                    if (isRecent) {
                        // Highlight recent swaps in bright cyan
                        this.ctx.strokeStyle = '#00ffff';
                        this.ctx.lineWidth = width * 2;
                        this.ctx.shadowColor = '#00ffff';
                        this.ctx.shadowBlur = 10;
                    } else {
                        this.ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;
                        this.ctx.lineWidth = width;
                        this.ctx.shadowBlur = 0;
                    }
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo((c1.i + 0.5) * cellSize, (c1.j + 0.5) * cellSize);
                    this.ctx.lineTo((c2.i + 0.5) * cellSize, (c2.j + 0.5) * cellSize);
                    this.ctx.stroke();
                }
                
                this.ctx.shadowBlur = 0;
                
                // Draw all nodes as small dots
                for (let idx = 0; idx < this.network.size; idx++) {
                    if (idx === this.network.outletIdx) continue; // Skip outlet (drawn separately)
                    
                    const c = this.network.getCoords(idx);
                    
                    this.ctx.fillStyle = '#2a3441';
                    this.ctx.beginPath();
                    this.ctx.arc(
                        (c.i + 0.5) * cellSize,
                        (c.j + 0.5) * cellSize,
                        cellSize * 0.08,
                        0,
                        Math.PI * 2
                    );
                    this.ctx.fill();
                }
                
                // Draw arrows only for channels (above minDrainageArea threshold)
                for (let idx = 0; idx < this.network.size; idx++) {
                    const down = this.network.downstream[idx];
                    if (down === idx) continue;
                    
                    const flow = this.network.flowAccum[idx];
                    const isChannel = flow >= this.network.minDrainageArea;
                    const isRecent = this.network.recentSwaps.has(idx);
                    
                    if (isChannel && !isRecent) {
                        const c1 = this.network.getCoords(idx);
                        const c2 = this.network.getCoords(down);
                        
                        const angle = Math.atan2(c2.j - c1.j, c2.i - c1.i);
                        const mx = (c1.i + c2.i) / 2;
                        const my = (c1.j + c2.j) / 2;
                        const arrowSize = cellSize * 0.2;
                        
                        // Color by flow accumulation
                        const t = Math.min(1, Math.log(flow + 1) / Math.log(this.network.size));
                        const r = Math.floor(t * 100);
                        const g = Math.floor((0.7 + t * 0.3) * 217);
                        const b = Math.floor(200 + t * 55);
                        
                        this.ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;
                        this.ctx.lineWidth = Math.max(0.5, Math.sqrt(flow) * 0.15);
                        
                        this.ctx.save();
                        this.ctx.translate((mx + 0.5) * cellSize, (my + 0.5) * cellSize);
                        this.ctx.rotate(angle);
                        this.ctx.beginPath();
                        this.ctx.moveTo(-arrowSize, -arrowSize * 0.5);
                        this.ctx.lineTo(0, 0);
                        this.ctx.lineTo(-arrowSize, arrowSize * 0.5);
                        this.ctx.stroke();
                        this.ctx.restore();
                    }
                }
                
                // Draw nodes for junctions
                for (let idx = 0; idx < this.network.size; idx++) {
                    let tributaries = 0;
                    for (let i = 0; i < this.network.size; i++) {
                        if (this.network.downstream[i] === idx && i !== idx) {
                            tributaries++;
                        }
                    }
                    
                    if (tributaries > 1) {
                        const c = this.network.getCoords(idx);
                        this.ctx.fillStyle = 'rgba(0, 217, 255, 0.5)';
                        this.ctx.beginPath();
                        this.ctx.arc(
                            (c.i + 0.5) * cellSize,
                            (c.j + 0.5) * cellSize,
                            cellSize * 0.15,
                            0,
                            Math.PI * 2
                        );
                        this.ctx.fill();
                    }
                }
                
                // Draw outlet prominently
                this.ctx.fillStyle = '#ff006e';
                this.ctx.shadowColor = '#ff006e';
                this.ctx.shadowBlur = 15;
                this.ctx.beginPath();
                this.ctx.arc(
                    (this.network.outletX + 0.5) * cellSize,
                    (this.network.outletY + 0.5) * cellSize,
                    cellSize * 0.4,
                    0,
                    Math.PI * 2
                );
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            renderElevation() {
                // Show distance to outlet as proxy for elevation
                const N = this.network.N;
                const cellSize = Math.min(this.canvas.width, this.canvas.height) / N;
                
                let maxDist = 0;
                for (let i = 0; i < this.network.size; i++) {
                    if (this.network.distToOutlet[i] < Infinity && this.network.distToOutlet[i] > maxDist) {
                        maxDist = this.network.distToOutlet[i];
                    }
                }
                
                for (let j = 0; j < N; j++) {
                    for (let i = 0; i < N; i++) {
                        const idx = this.network.IX(i, j);
                        const dist = this.network.distToOutlet[idx];
                        const norm = dist < Infinity ? dist / maxDist : 0;
                        
                        const r = Math.floor(norm * 100);
                        const g = Math.floor(norm * 150 + 50);
                        const b = Math.floor(norm * 200 + 55);
                        
                        this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        this.ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                    }
                }
            }
            
            renderFlowAccumulation() {
                const N = this.network.N;
                const cellSize = Math.min(this.canvas.width, this.canvas.height) / N;
                
                let maxFlow = 0;
                for (let i = 0; i < this.network.size; i++) {
                    if (this.network.flowAccum[i] > maxFlow) maxFlow = this.network.flowAccum[i];
                }
                
                for (let j = 0; j < N; j++) {
                    for (let i = 0; i < N; i++) {
                        const idx = this.network.IX(i, j);
                        const norm = Math.log(this.network.flowAccum[idx] + 1) / Math.log(maxFlow + 1);
                        
                        const r = Math.floor(norm * 255);
                        const g = Math.floor(norm * 217);
                        const b = Math.floor(255);
                        
                        this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        this.ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                    }
                }
            }
            
            renderEnergy() {
                const N = this.network.N;
                const cellSize = Math.min(this.canvas.width, this.canvas.height) / N;
                
                let maxEnergy = 0;
                for (let i = 0; i < this.network.size; i++) {
                    if (this.network.energy[i] > maxEnergy) maxEnergy = this.network.energy[i];
                }
                
                for (let j = 0; j < N; j++) {
                    for (let i = 0; i < N; i++) {
                        const idx = this.network.IX(i, j);
                        const norm = Math.min(1, this.network.energy[idx] / maxEnergy);
                        
                        const r = Math.floor(norm * 255);
                        const g = Math.floor(norm * 100);
                        const b = Math.floor(norm * 110);
                        
                        this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        this.ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                    }
                }
            }
            
            renderSlope() {
                // Show energy per link
                const N = this.network.N;
                const cellSize = Math.min(this.canvas.width, this.canvas.height) / N;
                
                let maxEnergy = 0;
                for (let i = 0; i < this.network.size; i++) {
                    if (this.network.energy[i] > maxEnergy) maxEnergy = this.network.energy[i];
                }
                
                this.ctx.fillStyle = '#141923';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                for (let idx = 0; idx < this.network.size; idx++) {
                    const down = this.network.downstream[idx];
                    if (down === idx) continue;
                    
                    const norm = this.network.energy[idx] / (maxEnergy || 1);
                    const intensity = Math.floor(norm * 255);
                    
                    const c1 = this.network.getCoords(idx);
                    const c2 = this.network.getCoords(down);
                    
                    this.ctx.strokeStyle = `rgb(${intensity}, ${intensity}, ${intensity})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo((c1.i + 0.5) * cellSize, (c1.j + 0.5) * cellSize);
                    this.ctx.lineTo((c2.i + 0.5) * cellSize, (c2.j + 0.5) * cellSize);
                    this.ctx.stroke();
                }
            }
        }
        
        // Application
        const canvas = document.getElementById('networkCanvas');
        const energyCanvas = document.getElementById('energyPlot');
        const network = new ChannelNetwork(10); // 10Ã—10 grid as in thesis
        
        const renderer = new NetworkRenderer(canvas, network);
        const energyPlotter = new EnergyPlotter(energyCanvas, network);
        
        let isAutoOptimizing = false;
        let autoOptimizeInterval = null;
        
        function updateStats() {
            const stats = network.getNetworkStats();
            document.getElementById('total-length').textContent = stats.totalLength;
            document.getElementById('channel-count').textContent = stats.channelCount;
            document.getElementById('bifurcation').textContent = stats.bifurcationRatio.toFixed(2);
            document.getElementById('total-energy').textContent = stats.totalEnergy;
            document.getElementById('max-flow').textContent = stats.maxFlow;
            document.getElementById('eval-count').textContent = stats.evaluationCount;
            document.getElementById('success-count').textContent = stats.improvementCount;
            document.getElementById('accept-rate').textContent = stats.acceptanceRate + '%';
            document.getElementById('algo-status').textContent = stats.algorithmStatus;
            
            // Show/hide success lengths based on mode
            const successLengthsRow = document.getElementById('success-lengths-row');
            if (stats.mode === 'hto') {
                successLengthsRow.style.display = 'block';
                document.getElementById('success-lengths').textContent = stats.successLengthsCount;
            } else {
                successLengthsRow.style.display = 'none';
            }
            
            // Update mode display
            const modeNames = { hto: 'HTO', sa: 'SA', gradient: 'Gradient' };
            document.getElementById('algo-mode').textContent = modeNames[stats.mode];
        }
        
        function animate() {
            renderer.render();
            energyPlotter.render();
            updateStats();
            requestAnimationFrame(animate);
        }
        
        // Grid size selection
        document.getElementById('grid-10').addEventListener('click', (e) => {
            const newNetwork = new ChannelNetwork(10);
            Object.assign(network, newNetwork);
            document.querySelectorAll('#grid-10, #grid-20').forEach(btn => {
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.borderColor = 'var(--border)';
            });
            e.target.style.background = 'rgba(0, 217, 255, 0.2)';
            e.target.style.borderColor = 'var(--accent-primary)';
            document.getElementById('grid-size-display').textContent = '10Ã—10';
        });
        
        document.getElementById('grid-20').addEventListener('click', (e) => {
            const newNetwork = new ChannelNetwork(20);
            Object.assign(network, newNetwork);
            document.querySelectorAll('#grid-10, #grid-20').forEach(btn => {
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.borderColor = 'var(--border)';
            });
            e.target.style.background = 'rgba(0, 217, 255, 0.2)';
            e.target.style.borderColor = 'var(--accent-primary)';
            document.getElementById('grid-size-display').textContent = '20Ã—20';
        });
        
        // Algorithm mode selection
        document.getElementById('hto-mode').addEventListener('click', (e) => {
            network.setOptimizationMode('hto');
            document.querySelectorAll('#hto-mode, #sa-mode, #gradient-mode').forEach(btn => {
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.borderColor = 'var(--border)';
            });
            e.target.style.background = 'rgba(0, 217, 255, 0.2)';
            e.target.style.borderColor = 'var(--accent-primary)';
        });
        
        document.getElementById('sa-mode').addEventListener('click', (e) => {
            network.setOptimizationMode('sa');
            document.querySelectorAll('#hto-mode, #sa-mode, #gradient-mode').forEach(btn => {
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.borderColor = 'var(--border)';
            });
            e.target.style.background = 'rgba(0, 217, 255, 0.2)';
            e.target.style.borderColor = 'var(--accent-primary)';
        });
        
        document.getElementById('gradient-mode').addEventListener('click', (e) => {
            network.setOptimizationMode('gradient');
            document.querySelectorAll('#hto-mode, #sa-mode, #gradient-mode').forEach(btn => {
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.borderColor = 'var(--border)';
            });
            e.target.style.background = 'rgba(0, 217, 255, 0.2)';
            e.target.style.borderColor = 'var(--accent-primary)';
        });
        
        // Controls
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                renderer.mode = btn.dataset.mode;
            });
        });
        
        
        document.getElementById('evolve-btn').addEventListener('click', () => {
            network.optimizeNetwork(100);
        });
        
        document.getElementById('reset-btn').addEventListener('click', () => {
            network.reset();
        });
        
        document.getElementById('auto-btn').addEventListener('click', (e) => {
            isAutoOptimizing = !isAutoOptimizing;
            e.target.textContent = isAutoOptimizing ? 'Stop Auto-Optimize' : 'Auto-Optimize';
            
            if (isAutoOptimizing) {
                autoOptimizeInterval = setInterval(() => {
                    network.optimizeNetwork(10);
                }, 100);
            } else {
                clearInterval(autoOptimizeInterval);
            }
        });
        
        // Mouse interaction - set outlet
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            network.setOutlet(x, y);
        });
        
        animate();
    </script>
</body>
</html>
