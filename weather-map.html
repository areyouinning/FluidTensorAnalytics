<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local Weather Forecast</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            margin-top: 0;
            color: #333;
        }
        h2 {
            color: #334155;
            font-size: 20px;
            margin-top: 30px;
            margin-bottom: 15px;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 8px;
        }
        .location-input {
            margin-bottom: 20px;
        }
        button {
            background: #2563eb;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #1d4ed8;
        }
        button:disabled {
            background: #94a3b8;
            cursor: not-allowed;
        }
        .grid-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .map-wrapper {
            background: #fafafa;
            border-radius: 6px;
            padding: 10px;
            position: relative;
        }
        .map-wrapper h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            font-weight: 600;
            color: #334155;
        }
        .map-container {
            height: 600px;
            width: 100%;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        .legend {
            position: absolute;
            bottom: 30px;
            right: 10px;
            background: white;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.4);
            z-index: 1000;
            font-size: 12px;
        }
        .legend-title {
            font-weight: 600;
            margin-bottom: 5px;
            font-size: 11px;
            color: #333;
        }
        .legend-scale {
            display: flex;
            height: 15px;
            width: 150px;
            margin-bottom: 3px;
        }
        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #666;
        }
        .map-tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 12px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            pointer-events: none;
            font-size: 13px;
            font-weight: 500;
            color: #333;
            z-index: 1001;
            display: none;
            white-space: nowrap;
        }
        .map-tooltip.visible {
            display: block;
        }
        .controls {
            margin: 20px 0;
            padding: 15px;
            background: #f8fafc;
            border-radius: 6px;
        }
        .time-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        input[type="range"] {
            flex: 1;
            height: 8px;
        }
        .time-display {
            font-weight: 600;
            color: #1e40af;
            min-width: 200px;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 6px;
            font-size: 14px;
        }
        .status.loading {
            background: #dbeafe;
            color: #1e40af;
        }
        .status.error {
            background: #fee;
            color: #991b1b;
        }
        .status.success {
            background: #dcfce7;
            color: #166534;
        }
        .location-info {
            font-size: 14px;
            color: #64748b;
            margin-top: 5px;
        }
        .meteogram-section {
            margin-top: 30px;
            display: none;
        }
        .meteogram-container {
            background: #fafafa;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .plot-container {
            width: 100%;
            height: 250px;
            background: white;
            border-radius: 4px;
        }
        .meteogram-note {
            font-size: 13px;
            color: #64748b;
            margin-top: 10px;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Local Weather Forecast</h1>
        
        <div class="location-input">
            <button id="getLocationBtn" onclick="requestLocation()">Use My Location</button>
            <div class="location-info" id="locationInfo"></div>
        </div>

        <div id="status"></div>

        <div class="controls" id="controls" style="display: none;">
            <div><strong>Forecast Time Controls</strong></div>
            <div class="time-control">
                <button onclick="previousTime()">◀ Previous</button>
                <input type="range" id="timeSlider" min="0" max="0" value="0" onchange="updateTime()">
                <button onclick="nextTime()">Next ▶</button>
                <span class="time-display" id="timeDisplay"></span>
            </div>
        </div>

        <h2 id="mapsHeader" style="display: none;">Spatial Forecast Maps</h2>
        <div class="grid-container" id="mapsContainer" style="display: none;">
            <div class="map-wrapper">
                <h3>Temperature (°F)</h3>
                <div id="tempMap" class="map-container">
                    <div class="legend" id="tempLegend">
                        <div class="legend-title">Temperature (°F)</div>
                        <div class="legend-scale" id="tempScale"></div>
                        <div class="legend-labels">
                            <span id="tempMin">--</span>
                            <span id="tempMax">--</span>
                        </div>
                    </div>
                    <div class="map-tooltip" id="tempTooltip"></div>
                </div>
            </div>
            <div class="map-wrapper">
                <h3>Precipitation (in/hr)</h3>
                <div id="precipMap" class="map-container">
                    <div class="legend" id="precipLegend">
                        <div class="legend-title">Precipitation (in/hr)</div>
                        <div class="legend-scale" id="precipScale"></div>
                        <div class="legend-labels">
                            <span id="precipMin">--</span>
                            <span id="precipMax">--</span>
                        </div>
                    </div>
                    <div class="map-tooltip" id="precipTooltip"></div>
                </div>
            </div>
            <div class="map-wrapper">
                <h3>Wind Speed (mph)</h3>
                <div id="windMap" class="map-container">
                    <div class="legend" id="windLegend">
                        <div class="legend-title">Wind Speed (mph)</div>
                        <div class="legend-scale" id="windScale"></div>
                        <div class="legend-labels">
                            <span id="windMin">--</span>
                            <span id="windMax">--</span>
                        </div>
                    </div>
                    <div class="map-tooltip" id="windTooltip"></div>
                </div>
            </div>
            <div class="map-wrapper">
                <h3>Relative Humidity (%)</h3>
                <div id="humidityMap" class="map-container">
                    <div class="legend" id="humidityLegend">
                        <div class="legend-title">Relative Humidity (%)</div>
                        <div class="legend-scale" id="humidityScale"></div>
                        <div class="legend-labels">
                            <span id="humidityMin">--</span>
                            <span id="humidityMax">--</span>
                        </div>
                    </div>
                    <div class="map-tooltip" id="humidityTooltip"></div>
                </div>
            </div>
        </div>

        <div class="meteogram-section" id="meteogramSection">
            <h2>Point Forecast Time Series</h2>
            <div class="meteogram-note">
                Forecast for the center point of your selected location. Hover over plots for detailed values.
            </div>
            
            <div class="meteogram-container">
                <h3>Temperature & Dewpoint</h3>
                <div id="tempPlot" class="plot-container"></div>
            </div>

            <div class="meteogram-container">
                <h3>Wind Speed & Gusts</h3>
                <div id="windPlot" class="plot-container"></div>
            </div>

            <div class="meteogram-container">
                <h3>Precipitation & Humidity</h3>
                <div id="precipPlot" class="plot-container"></div>
            </div>

            <div class="meteogram-container">
                <h3>Sky Cover</h3>
                <div id="cloudPlot" class="plot-container"></div>
            </div>
        </div>
    </div>

    <script>
        let map, maps = {}, overlays = {}, rawData = {};
        let forecastData = null;
        let currentTimeIndex = 0;
        let userLocation = null;
        let centerPoint = null; // Store center point data for meteograms

        function showStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
        }

        function requestLocation() {
            if (!navigator.geolocation) {
                showStatus('Geolocation is not supported by your browser', 'error');
                return;
            }

            const btn = document.getElementById('getLocationBtn');
            btn.disabled = true;
            btn.textContent = 'Getting location...';

            navigator.geolocation.getCurrentPosition(
                position => {
                    userLocation = {
                        lat: position.coords.latitude,
                        lon: position.coords.longitude
                    };
                    
                    document.getElementById('locationInfo').textContent = 
                        `Location: ${userLocation.lat.toFixed(4)}°N, ${Math.abs(userLocation.lon).toFixed(4)}°W`;
                    
                    loadForecastData(userLocation.lat, userLocation.lon);
                    btn.textContent = 'Update Location';
                    btn.disabled = false;
                },
                error => {
                    showStatus('Unable to get your location', 'error');
                    btn.textContent = 'Use My Location';
                    btn.disabled = false;
                }
            );
        }

        async function loadForecastData(lat, lon) {
            showStatus('Loading forecast data...', 'loading');
            
            try {
                // Use mock data for demo
                forecastData = generateMockData(lat, lon);
                
                showStatus('Forecast data loaded successfully!', 'success');
                setTimeout(() => {
                    document.getElementById('status').style.display = 'none';
                }, 2000);
                
                initializeMaps();
                initializeMeteograms();
                updateDisplay();
                
            } catch (error) {
                showStatus(`Error loading forecast: ${error.message}`, 'error');
            }
        }

        function generateMockData(centerLat, centerLon) {
            const gridSize = 25;
            const numTimes = 48;
            
            const lats = [];
            const lons = [];
            for (let i = 0; i < gridSize; i++) {
                const row_lats = [];
                const row_lons = [];
                for (let j = 0; j < gridSize; j++) {
                    row_lats.push(centerLat + (i - 12) * 0.027);
                    row_lons.push(centerLon + (j - 12) * 0.027);
                }
                lats.push(row_lats);
                lons.push(row_lons);
            }
            
            const times = [];
            const now = new Date();
            for (let t = 0; t < numTimes; t++) {
                const time = new Date(now.getTime() + t * 3600000);
                times.push(time.toISOString());
            }
            
            const temperature = [];
            const precipitation = [];
            const windSpeed = [];
            const humidity = [];
            const cloudCover = [];
            const dewpoint = [];
            const windGust = [];
            
            for (let t = 0; t < numTimes; t++) {
                const tempGrid = [];
                const precipGrid = [];
                const windGrid = [];
                const humidGrid = [];
                const cloudGrid = [];
                const dewGrid = [];
                const gustGrid = [];
                
                const hourOfDay = (now.getHours() + t) % 24;
                const dayPhase = Math.sin((hourOfDay - 6) * Math.PI / 12);
                const baseTemp = 50 + 25 * dayPhase;
                const basePrecip = Math.max(0, Math.sin(t * Math.PI / 24) * 0.1);
                
                for (let i = 0; i < gridSize; i++) {
                    const tempRow = [];
                    const precipRow = [];
                    const windRow = [];
                    const humidRow = [];
                    const cloudRow = [];
                    const dewRow = [];
                    const gustRow = [];
                    
                    for (let j = 0; j < gridSize; j++) {
                        const noise = (Math.random() - 0.5) * 10;
                        const temp = baseTemp + noise;
                        tempRow.push(temp);
                        
                        const precipNoise = Math.random() * 0.05;
                        precipRow.push(basePrecip + precipNoise);
                        
                        const windNoise = (Math.random() - 0.5) * 5;
                        const wind = 10 + 5 * Math.sin(t * Math.PI / 12) + windNoise;
                        windRow.push(Math.max(0, wind));
                        
                        const rh = 40 + 30 * Math.sin(t * Math.PI / 24) + (Math.random() - 0.5) * 20;
                        humidRow.push(Math.max(10, Math.min(95, rh)));
                        
                        const clouds = 20 + 60 * Math.sin(t * Math.PI / 18) + (Math.random() - 0.5) * 30;
                        cloudRow.push(Math.max(0, Math.min(100, clouds)));
                        
                        // Calculate dewpoint from temp and RH
                        const rh_actual = Math.max(10, Math.min(95, rh)) / 100;
                        const dp = temp - ((100 - rh_actual * 100) / 5);
                        dewRow.push(dp);
                        
                        // Wind gust is 1.3-1.5x wind speed
                        const gust = wind * (1.3 + Math.random() * 0.2);
                        gustRow.push(Math.max(0, gust));
                    }
                    
                    tempGrid.push(tempRow);
                    precipGrid.push(precipRow);
                    windGrid.push(windRow);
                    humidGrid.push(humidRow);
                    cloudGrid.push(cloudRow);
                    dewGrid.push(dewRow);
                    gustGrid.push(gustRow);
                }
                
                temperature.push(tempGrid);
                precipitation.push(precipGrid);
                windSpeed.push(windGrid);
                humidity.push(humidGrid);
                cloudCover.push(cloudGrid);
                dewpoint.push(dewGrid);
                windGust.push(gustGrid);
            }
            
            return {
                lats,
                lons,
                times,
                temperature,
                precipitation,
                windSpeed,
                humidity,
                cloudCover,
                dewpoint,
                windGust
            };
        }

        function initializeMaps() {
            const variables = ['temp', 'precip', 'wind', 'humidity'];
            
            variables.forEach(variable => {
                const mapId = variable === 'temp' ? 'tempMap' : 
                             variable === 'precip' ? 'precipMap' :
                             variable === 'wind' ? 'windMap' : 'humidityMap';
                
                if (!maps[variable]) {
                    maps[variable] = L.map(mapId, {
                        zoomControl: true,
                        attributionControl: false
                    }).setView([userLocation.lat, userLocation.lon], 9);
                    
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        maxZoom: 19
                    }).addTo(maps[variable]);
                    
                    setupMapTooltip(variable, mapId);
                }
            });
            
            document.getElementById('controls').style.display = 'block';
            document.getElementById('mapsContainer').style.display = 'grid';
            document.getElementById('mapsHeader').style.display = 'block';
            
            // Force Leaflet to recalculate map sizes after display
            setTimeout(() => {
                variables.forEach(variable => {
                    if (maps[variable]) {
                        maps[variable].invalidateSize();
                    }
                });
            }, 100);
            
            const slider = document.getElementById('timeSlider');
            slider.max = forecastData.times.length - 1;
            slider.value = 0;
        }

        function initializeMeteograms() {
            // Extract center point data
            const centerY = Math.floor(forecastData.lats.length / 2);
            const centerX = Math.floor(forecastData.lats[0].length / 2);
            
            centerPoint = {
                times: forecastData.times,
                temperature: forecastData.temperature.map(grid => grid[centerY][centerX]),
                dewpoint: forecastData.dewpoint.map(grid => grid[centerY][centerX]),
                windSpeed: forecastData.windSpeed.map(grid => grid[centerY][centerX]),
                windGust: forecastData.windGust.map(grid => grid[centerY][centerX]),
                precipitation: forecastData.precipitation.map(grid => grid[centerY][centerX]),
                humidity: forecastData.humidity.map(grid => grid[centerY][centerX]),
                cloudCover: forecastData.cloudCover.map(grid => grid[centerY][centerX])
            };
            
            createMeteogramPlots();
            document.getElementById('meteogramSection').style.display = 'block';
        }

        function createMeteogramPlots() {
            const times = centerPoint.times.map(t => new Date(t));
            
            // Temperature & Dewpoint Plot
            const tempTrace = {
                x: times,
                y: centerPoint.temperature,
                name: 'Temperature',
                type: 'scatter',
                mode: 'lines+markers',
                line: { color: '#dc2626', width: 2 },
                marker: { size: 4 }
            };
            
            const dewTrace = {
                x: times,
                y: centerPoint.dewpoint,
                name: 'Dewpoint',
                type: 'scatter',
                mode: 'lines+markers',
                line: { color: '#2563eb', width: 2 },
                marker: { size: 4 }
            };
            
            const tempLayout = {
                margin: { l: 50, r: 20, t: 20, b: 40 },
                xaxis: { 
                    title: '',
                    showgrid: true,
                    gridcolor: '#e5e7eb'
                },
                yaxis: { 
                    title: 'Temperature (°F)',
                    showgrid: true,
                    gridcolor: '#e5e7eb'
                },
                legend: { orientation: 'h', y: 1.1 },
                hovermode: 'x unified',
                plot_bgcolor: '#fafafa',
                paper_bgcolor: 'white'
            };
            
            Plotly.newPlot('tempPlot', [tempTrace, dewTrace], tempLayout, {responsive: true});
            
            // Wind Speed & Gusts Plot
            const windTrace = {
                x: times,
                y: centerPoint.windSpeed,
                name: 'Wind Speed',
                type: 'scatter',
                mode: 'lines+markers',
                line: { color: '#059669', width: 2 },
                marker: { size: 4 }
            };
            
            const gustTrace = {
                x: times,
                y: centerPoint.windGust,
                name: 'Wind Gust',
                type: 'scatter',
                mode: 'lines',
                line: { color: '#ea580c', width: 1, dash: 'dash' }
            };
            
            const windLayout = {
                margin: { l: 50, r: 20, t: 20, b: 40 },
                xaxis: { 
                    title: '',
                    showgrid: true,
                    gridcolor: '#e5e7eb'
                },
                yaxis: { 
                    title: 'Wind Speed (mph)',
                    showgrid: true,
                    gridcolor: '#e5e7eb'
                },
                legend: { orientation: 'h', y: 1.1 },
                hovermode: 'x unified',
                plot_bgcolor: '#fafafa',
                paper_bgcolor: 'white'
            };
            
            Plotly.newPlot('windPlot', [windTrace, gustTrace], windLayout, {responsive: true});
            
            // Precipitation & Humidity Plot
            const precipTrace = {
                x: times,
                y: centerPoint.precipitation,
                name: 'Precipitation',
                type: 'bar',
                marker: { color: '#0284c7' },
                yaxis: 'y'
            };
            
            const humidTrace = {
                x: times,
                y: centerPoint.humidity,
                name: 'Humidity',
                type: 'scatter',
                mode: 'lines',
                line: { color: '#65a30d', width: 2 },
                yaxis: 'y2'
            };
            
            const precipLayout = {
                margin: { l: 50, r: 50, t: 20, b: 40 },
                xaxis: { 
                    title: '',
                    showgrid: true,
                    gridcolor: '#e5e7eb'
                },
                yaxis: { 
                    title: 'Precipitation (in/hr)',
                    showgrid: true,
                    gridcolor: '#e5e7eb',
                    rangemode: 'tozero'
                },
                yaxis2: {
                    title: 'Relative Humidity (%)',
                    overlaying: 'y',
                    side: 'right',
                    range: [0, 100]
                },
                legend: { orientation: 'h', y: 1.1 },
                hovermode: 'x unified',
                plot_bgcolor: '#fafafa',
                paper_bgcolor: 'white'
            };
            
            Plotly.newPlot('precipPlot', [precipTrace, humidTrace], precipLayout, {responsive: true});
            
            // Cloud Cover Plot
            const cloudTrace = {
                x: times,
                y: centerPoint.cloudCover,
                name: 'Sky Cover',
                type: 'scatter',
                mode: 'lines',
                fill: 'tozeroy',
                fillcolor: 'rgba(100, 116, 139, 0.3)',
                line: { color: '#64748b', width: 2 }
            };
            
            const cloudLayout = {
                margin: { l: 50, r: 20, t: 20, b: 40 },
                xaxis: { 
                    title: 'Forecast Time',
                    showgrid: true,
                    gridcolor: '#e5e7eb'
                },
                yaxis: { 
                    title: 'Sky Cover (%)',
                    showgrid: true,
                    gridcolor: '#e5e7eb',
                    range: [0, 100]
                },
                legend: { orientation: 'h', y: 1.1 },
                hovermode: 'x unified',
                plot_bgcolor: '#fafafa',
                paper_bgcolor: 'white'
            };
            
            Plotly.newPlot('cloudPlot', [cloudTrace], cloudLayout, {responsive: true});
        }

        function setupMapTooltip(variable, mapId) {
            const mapElement = document.getElementById(mapId);
            const tooltip = document.getElementById(variable + 'Tooltip');
            
            mapElement.addEventListener('mousemove', (e) => {
                if (!rawData[variable]) return;
                
                const rect = mapElement.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const mapBounds = maps[variable].getBounds();
                const mapSize = maps[variable].getSize();
                
                const lat = mapBounds.getNorth() - (mouseY / mapSize.y) * (mapBounds.getNorth() - mapBounds.getSouth());
                const lon = mapBounds.getWest() + (mouseX / mapSize.x) * (mapBounds.getEast() - mapBounds.getWest());
                
                const value = getValueAtLocation(rawData[variable], forecastData.lats, forecastData.lons, lat, lon);
                
                if (value !== null) {
                    const units = variable === 'temp' ? '°F' :
                                variable === 'precip' ? 'in/hr' :
                                variable === 'wind' ? 'mph' : '%';
                    
                    tooltip.textContent = `${value.toFixed(1)} ${units}`;
                    tooltip.style.left = mouseX + 10 + 'px';
                    tooltip.style.top = mouseY - 30 + 'px';
                    tooltip.classList.add('visible');
                } else {
                    tooltip.classList.remove('visible');
                }
            });
            
            mapElement.addEventListener('mouseleave', () => {
                tooltip.classList.remove('visible');
            });
        }

        function getValueAtLocation(data, lats, lons, targetLat, targetLon) {
            let minDist = Infinity;
            let value = null;
            
            for (let i = 0; i < data.length; i++) {
                for (let j = 0; j < data[i].length; j++) {
                    const dist = Math.sqrt(
                        Math.pow(lats[i][j] - targetLat, 2) + 
                        Math.pow(lons[i][j] - targetLon, 2)
                    );
                    if (dist < minDist) {
                        minDist = dist;
                        value = data[i][j];
                    }
                }
            }
            
            return value;
        }

        function updateTime() {
            const slider = document.getElementById('timeSlider');
            currentTimeIndex = parseInt(slider.value);
            updateDisplay();
        }

        function previousTime() {
            if (currentTimeIndex > 0) {
                currentTimeIndex--;
                document.getElementById('timeSlider').value = currentTimeIndex;
                updateDisplay();
            }
        }

        function nextTime() {
            if (currentTimeIndex < forecastData.times.length - 1) {
                currentTimeIndex++;
                document.getElementById('timeSlider').value = currentTimeIndex;
                updateDisplay();
            }
        }

        function updateDisplay() {
            const time = new Date(forecastData.times[currentTimeIndex]);
            document.getElementById('timeDisplay').textContent = 
                time.toLocaleString('en-US', { 
                    weekday: 'short',
                    month: 'short',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit'
                });
            
            updateMaps();
        }

        function interpolateToHighRes(data, lats, lons) {
            const factor = 4;
            const origRows = data.length;
            const origCols = data[0].length;
            const newRows = (origRows - 1) * factor + 1;
            const newCols = (origCols - 1) * factor + 1;
            
            const highResData = [];
            const highResLats = [];
            const highResLons = [];
            
            for (let i = 0; i < newRows; i++) {
                const highResRow = [];
                const latRow = [];
                const lonRow = [];
                
                for (let j = 0; j < newCols; j++) {
                    const origI = i / factor;
                    const origJ = j / factor;
                    
                    const i0 = Math.floor(origI);
                    const i1 = Math.min(i0 + 1, origRows - 1);
                    const j0 = Math.floor(origJ);
                    const j1 = Math.min(j0 + 1, origCols - 1);
                    
                    const wi = origI - i0;
                    const wj = origJ - j0;
                    
                    const val = (1 - wi) * (1 - wj) * data[i0][j0] +
                               (1 - wi) * wj * data[i0][j1] +
                               wi * (1 - wj) * data[i1][j0] +
                               wi * wj * data[i1][j1];
                    
                    const lat = (1 - wi) * (1 - wj) * lats[i0][j0] +
                               (1 - wi) * wj * lats[i0][j1] +
                               wi * (1 - wj) * lats[i1][j0] +
                               wi * wj * lats[i1][j1];
                    
                    const lon = (1 - wi) * (1 - wj) * lons[i0][j0] +
                               (1 - wi) * wj * lons[i0][j1] +
                               wi * (1 - wj) * lons[i1][j0] +
                               wi * wj * lons[i1][j1];
                    
                    highResRow.push(val);
                    latRow.push(lat);
                    lonRow.push(lon);
                }
                
                highResData.push(highResRow);
                highResLats.push(latRow);
                highResLons.push(lonRow);
            }
            
            return { data: highResData, lats: highResLats, lons: highResLons };
        }

        function createCanvasOverlay(data, lats, lons, variable, colorScale) {
            const canvas = document.createElement('canvas');
            const rows = data.length;
            const cols = data[0].length;
            canvas.width = cols;
            canvas.height = rows;
            const ctx = canvas.getContext('2d');
            
            const flatData = data.flat();
            const minVal = Math.min(...flatData);
            const maxVal = Math.max(...flatData);
            
            const imageData = ctx.createImageData(cols, rows);
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const value = data[i][j];
                    const normalized = (value - minVal) / (maxVal - minVal);
                    const [r, g, b] = getColor(normalized, colorScale);
                    
                    const idx = (i * cols + j) * 4;
                    imageData.data[idx] = r;
                    imageData.data[idx + 1] = g;
                    imageData.data[idx + 2] = b;
                    imageData.data[idx + 3] = 255;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            const bounds = [
                [Math.min(...lats.flat()), Math.min(...lons.flat())],
                [Math.max(...lats.flat()), Math.max(...lons.flat())]
            ];
            
            return { canvas, bounds, minVal, maxVal };
        }

        function createLegend(variable, colorScale, minVal, maxVal) {
            const scaleDiv = document.getElementById(variable + 'Scale');
            scaleDiv.innerHTML = '';
            
            const steps = 100;
            for (let i = 0; i < steps; i++) {
                const normalized = i / (steps - 1);
                const [r, g, b] = getColor(normalized, colorScale);
                const div = document.createElement('div');
                div.style.flex = '1';
                div.style.backgroundColor = `rgb(${r},${g},${b})`;
                scaleDiv.appendChild(div);
            }
            
            document.getElementById(variable + 'Min').textContent = minVal.toFixed(1);
            document.getElementById(variable + 'Max').textContent = maxVal.toFixed(1);
        }

        function getColor(normalized, colorScale) {
            const scales = {
                temp: [
                    [0, [49, 54, 149]],
                    [0.25, [69, 117, 180]],
                    [0.5, [255, 255, 191]],
                    [0.75, [254, 224, 144]],
                    [1, [215, 48, 39]]
                ],
                precip: [
                    [0, [247, 251, 255]],
                    [0.25, [198, 219, 239]],
                    [0.5, [107, 174, 214]],
                    [0.75, [49, 130, 189]],
                    [1, [8, 81, 156]]
                ],
                wind: [
                    [0, [247, 252, 245]],
                    [0.25, [199, 233, 192]],
                    [0.5, [127, 188, 65]],
                    [0.75, [49, 163, 84]],
                    [1, [0, 109, 44]]
                ],
                humidity: [
                    [0, [255, 255, 217]],
                    [0.25, [199, 233, 180]],
                    [0.5, [127, 205, 187]],
                    [0.75, [65, 182, 196]],
                    [1, [34, 94, 168]]
                ]
            };
            
            const scale = scales[colorScale] || scales.temp;
            
            let lower = scale[0];
            let upper = scale[scale.length - 1];
            
            for (let i = 0; i < scale.length - 1; i++) {
                if (normalized >= scale[i][0] && normalized <= scale[i+1][0]) {
                    lower = scale[i];
                    upper = scale[i+1];
                    break;
                }
            }
            
            const t = (normalized - lower[0]) / (upper[0] - lower[0]);
            return [
                Math.round(lower[1][0] + t * (upper[1][0] - lower[1][0])),
                Math.round(lower[1][1] + t * (upper[1][1] - lower[1][1])),
                Math.round(lower[1][2] + t * (upper[1][2] - lower[1][2]))
            ];
        }

        function updateMaps() {
            const t = currentTimeIndex;
            
            updateMapOverlay('temp', forecastData.temperature[t], 'temp');
            updateMapOverlay('precip', forecastData.precipitation[t], 'precip');
            updateMapOverlay('wind', forecastData.windSpeed[t], 'wind');
            updateMapOverlay('humidity', forecastData.humidity[t], 'humidity');
        }

        function updateMapOverlay(mapId, data, variable) {
            rawData[mapId] = data;
            
            if (overlays[mapId]) {
                maps[mapId].removeLayer(overlays[mapId]);
            }
            
            const highRes = interpolateToHighRes(
                data,
                forecastData.lats,
                forecastData.lons
            );
            
            const { canvas, bounds, minVal, maxVal } = createCanvasOverlay(
                highRes.data,
                highRes.lats,
                highRes.lons,
                variable,
                variable
            );
            
            createLegend(variable, variable, minVal, maxVal);
            
            overlays[mapId] = L.imageOverlay(canvas.toDataURL(), bounds, {
                opacity: 0.7,
                interactive: false
            }).addTo(maps[mapId]);
        }
    </script>
</body>
</html>
