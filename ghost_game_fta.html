<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ghost AI - Minimax Fixed - Fluid Tensor Analytics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; display: flex; align-items: center; justify-content: center; padding: 20px; }
        .game-container { background: white; border-radius: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); padding: 40px; max-width: 800px; width: 100%; }
        .header { text-align: center; margin-bottom: 30px; }
        h1 { color: #667eea; font-size: 2.5em; margin-bottom: 10px; }
        .subtitle { color: #666; font-size: 0.9em; }
        .dictionary-info { background: #f0f0f0; padding: 10px; border-radius: 8px; text-align: center; margin-bottom: 20px; font-size: 0.85em; color: #555; }
        .game-board { background: #f7f7f7; border-radius: 15px; padding: 30px; margin: 20px 0; text-align: center; }
        .current-word { font-size: 3em; font-weight: bold; color: #667eea; min-height: 80px; display: flex; align-items: center; justify-content: center; letter-spacing: 8px; font-family: 'Courier New', monospace; }
        .controls { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin: 20px 0; }
        .letter-btn { width: 50px; height: 50px; font-size: 1.2em; font-weight: bold; border: 2px solid #667eea; background: white; color: #667eea; border-radius: 10px; cursor: pointer; transition: all 0.2s; }
        .letter-btn:hover:not(:disabled) { background: #667eea; color: white; transform: scale(1.1); }
        .letter-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .status { padding: 15px; border-radius: 10px; margin: 20px 0; text-align: center; font-weight: 500; }
        .status.info { background: #e3f2fd; color: #1976d2; }
        .status.success { background: #e8f5e9; color: #388e3c; }
        .status.error { background: #ffebee; color: #c62828; }
        .action-buttons { display: flex; gap: 15px; justify-content: center; margin: 20px 0; }
        .btn { padding: 12px 30px; border: none; border-radius: 10px; font-size: 1em; font-weight: 600; cursor: pointer; transition: all 0.2s; }
        .btn-danger { background: #e53935; color: white; }
        .btn-danger:hover { background: #c62828; transform: translateY(-2px); }
        .btn-secondary { background: #757575; color: white; }
        .btn-secondary:hover { background: #616161; transform: translateY(-2px); }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin: 20px 0; }
        .stat-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 15px; text-align: center; }
        .stat-value { font-size: 2em; font-weight: bold; margin-bottom: 5px; }
        .stat-label { font-size: 0.9em; opacity: 0.9; }
        .ai-selector { display: flex; gap: 10px; justify-content: center; margin: 20px 0; flex-wrap: wrap; }
        .ai-option { padding: 10px 20px; border: 2px solid #667eea; background: white; color: #667eea; border-radius: 10px; cursor: pointer; transition: all 0.2s; font-size: 0.9em; }
        .ai-option.active { background: #667eea; color: white; }
        .ai-option:hover { transform: translateY(-2px); }
        .thinking-indicator { display: none; text-align: center; color: #667eea; font-style: italic; margin: 10px 0; font-size: 0.9em; }
        .thinking-indicator.active { display: block; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .thinking-indicator.active::after { content: '...'; animation: pulse 1.5s infinite; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 0.9em; }
        .footer a { color: #667eea; text-decoration: none; }
        .footer a:hover { text-decoration: underline; }
        .debug { font-size: 0.8em; color: #999; margin-top: 10px; font-family: monospace; }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <h1>ðŸ‘» GHOST</h1>
            <div class="subtitle">Minimax AI (Fixed)</div>
        </div>
        <div class="dictionary-info" id="dict-info">Demo Dictionary Loaded</div>
        <div class="ai-selector">
            <div class="ai-option" data-ai="minimax" data-depth="8">ðŸ§  Minimax D8</div>
            <div class="ai-option active" data-ai="minimax" data-depth="6">ðŸŽ¯ Minimax D6</div>
            <div class="ai-option" data-ai="minimax" data-depth="4">ðŸ’¡ Minimax D4</div>
            <div class="ai-option" data-ai="greedy">âš¡ Greedy</div>
            <div class="ai-option" data-ai="random">ðŸŽ² Random</div>
        </div>
        <div class="game-board">
            <div class="current-word" id="currentWord">_</div>
            <div class="thinking-indicator" id="thinking">AI is thinking</div>
            <div class="debug" id="debug"></div>
        </div>
        <div class="status info" id="status">Choose a letter to start!</div>
        <div class="controls" id="letterButtons"></div>
        <div class="action-buttons">
            <button class="btn btn-danger" onclick="challenge()" id="challengeBtn">Challenge AI</button>
            <button class="btn btn-secondary" onclick="newGame()" id="newGameBtn">New Game</button>
        </div>
        <div class="stats">
            <div class="stat-card"><div class="stat-value" id="winsValue">0</div><div class="stat-label">Your Wins</div></div>
            <div class="stat-card"><div class="stat-value" id="lossesValue">0</div><div class="stat-label">Your Losses</div></div>
            <div class="stat-card"><div class="stat-value" id="winRateValue">0%</div><div class="stat-label">Win Rate</div></div>
        </div>
        <div class="footer">
            <p>Created by <a href="https://fluidtensor.com" target="_blank">Fluid Tensor Analytics</a></p>
            <p style="margin-top: 5px; font-size: 0.8em;">Game Theory â€¢ Minimax â€¢ Alpha-Beta Pruning</p>
        </div>
    </div>
    <script>
// Demo Dictionary
class SimpleDictionary {
    constructor() {
        this.words = new Set([
            'GHOST', 'GHOSTS', 'GAME', 'GAMES', 'GAMER', 'WORD', 'WORDS', 'PLAY', 'PLAYS', 'PLAYER',
            'TEST', 'TESTS', 'CODE', 'CODES', 'CODER', 'DATA', 'TEAM', 'TEAMS',
            'WORK', 'WORKS', 'WORKER', 'TIME', 'TIMES', 'TIMER', 'HELP', 'HELPS', 'HELPER',
            'TYPE', 'TYPES', 'TYPED', 'TYPING', 'TYPER', 'TYPICAL',
            'MAKE', 'MAKES', 'MAKER', 'FIND', 'FINDS', 'FINDER', 'CALL', 'CALLS', 'CALLER',
            'HAND', 'HANDS', 'PART', 'PARTS', 'PLACE', 'PLACES', 'WORLD', 'WORLDS',
            'GREAT', 'GREATER', 'GREATEST', 'FIRST', 'THINK', 'THINKS', 'THINKER',
            'COULD', 'WATER', 'WATERS', 'ABOUT', 'AFTER', 'AGAIN', 'AGAINST',
            'ALMOST', 'ALWAYS', 'ANOTHER', 'ANSWER', 'ANSWERS', 'AROUND',
            'BECAUSE', 'BEFORE', 'BETTER', 'BETWEEN', 'BLACK', 'BLACKS',
            'BRING', 'BRINGS', 'BUILD', 'BUILDS', 'BUILDER', 'CHANGE', 'CHANGES',
            'CHILDREN', 'CHILD', 'CLOSE', 'CLOSES', 'CLOSER', 'COMMUNITY',
            'COMPANY', 'COMPANIES', 'COUNTRY', 'COUNTRIES', 'COURSE', 'COURSES',
            'CREATE', 'CREATES', 'CREATOR', 'DIFFERENT', 'EARLY', 'EARLIER',
            'EDUCATION', 'EVERY', 'EXAMPLE', 'EXAMPLES', 'EXPERIENCE'
        ]);
        this.prefixTree = {};
        for (const word of this.words) {
            let node = this.prefixTree;
            for (const char of word) {
                if (!node[char]) node[char] = {};
                node = node[char];
            }
            node['$'] = true;
        }
    }
    check(word) { return this.words.has(word.toUpperCase()); }
    children(prefix) {
        let node = this.prefixTree;
        for (const char of prefix.toUpperCase()) {
            if (!node[char]) return [];
            node = node[char];
        }
        return Object.keys(node).filter(k => k !== '$');
    }
}

// Game State
let currentWord = '', gameActive = true, playerTurn = true;
let stats = { wins: 0, losses: 0, games: 0 };
let aiMode = 'minimax', searchDepth = 6;
const dictionary = new SimpleDictionary();
const minimaxCache = new Map();

// Dictionary functions
function getValidContinuations(prefix) { return dictionary.children(prefix); }
function isCompleteWord(str) { return str.length >= 4 && dictionary.check(str); }

// CORRECTED Minimax AI
function minimax(prefix, depth, isMaximizing, alpha = -Infinity, beta = Infinity) {
    const cacheKey = `${prefix}|${depth}|${isMaximizing}`;
    if (minimaxCache.has(cacheKey)) return minimaxCache.get(cacheKey);
    
    const validLetters = getValidContinuations(prefix);
    
    // Terminal: no valid moves
    if (validLetters.length === 0) {
        const result = { score: isMaximizing ? -1000 : 1000, letter: null };
        minimaxCache.set(cacheKey, result);
        return result;
    }
    
    // Base case: depth limit
    if (depth === 0) {
        // Heuristic: more options = better position
        const result = { 
            score: isMaximizing ? validLetters.length : -validLetters.length, 
            letter: null 
        };
        minimaxCache.set(cacheKey, result);
        return result;
    }
    
    if (isMaximizing) {
        let maxEval = { score: -Infinity, letter: null };
        
        for (const letter of validLetters) {
            const newPrefix = prefix + letter;
            
            // Skip moves that complete words (immediate loss)
            if (isCompleteWord(newPrefix)) {
                continue;
            }
            
            const evaluation = minimax(newPrefix, depth - 1, false, alpha, beta);
            
            if (evaluation.score > maxEval.score) {
                maxEval = { score: evaluation.score, letter: letter };
            }
            
            alpha = Math.max(alpha, evaluation.score);
            if (beta <= alpha) break;
        }
        
        // If ALL moves complete words, pick the least bad one
        if (maxEval.score === -Infinity) {
            maxEval = { score: -1000, letter: validLetters[0] };
        }
        
        minimaxCache.set(cacheKey, maxEval);
        return maxEval;
    } else {
        let minEval = { score: Infinity, letter: null };
        
        for (const letter of validLetters) {
            const newPrefix = prefix + letter;
            
            // Skip moves that complete words (opponent won't make them)
            if (isCompleteWord(newPrefix)) {
                continue;
            }
            
            const evaluation = minimax(newPrefix, depth - 1, true, alpha, beta);
            
            if (evaluation.score < minEval.score) {
                minEval = { score: evaluation.score, letter: letter };
            }
            
            beta = Math.min(beta, evaluation.score);
            if (beta <= alpha) break;
        }
        
        if (minEval.score === Infinity) {
            minEval = { score: 1000, letter: validLetters[0] };
        }
        
        minimaxCache.set(cacheKey, minEval);
        return minEval;
    }
}

function aiChooseLetter() {
    if (!gameActive) return;
    document.getElementById('thinking').className = 'thinking-indicator active';
    
    setTimeout(() => {
        let letter, score;
        
        if (minimaxCache.size > 10000) minimaxCache.clear();
        
        switch(aiMode) {
            case 'minimax':
                const result = minimax(currentWord, searchDepth, true);
                letter = result.letter;
                score = result.score;
                document.getElementById('debug').textContent = 
                    `Minimax depth ${searchDepth}: chose ${letter} (score: ${score})`;
                break;
            case 'greedy':
                letter = greedyAI();
                document.getElementById('debug').textContent = 'Greedy AI';
                break;
            case 'random':
                letter = randomAI();
                document.getElementById('debug').textContent = 'Random AI';
                break;
        }
        
        document.getElementById('thinking').className = 'thinking-indicator';
        
        if (letter) {
            addLetter(letter, false);
        } else {
            endGame(true);
        }
    }, 300);
}

function greedyAI() {
    const validLetters = getValidContinuations(currentWord);
    if (!validLetters.length) return null;
    const safeLetters = validLetters.filter(l => !isCompleteWord(currentWord + l));
    if (safeLetters.length) {
        const scores = safeLetters.map(l => ({
            letter: l,
            score: getValidContinuations(currentWord + l).length
        }));
        scores.sort((a, b) => a.score - b.score);
        return scores[0].letter;
    }
    return validLetters[Math.floor(Math.random() * validLetters.length)];
}

function randomAI() {
    const validLetters = getValidContinuations(currentWord);
    return validLetters.length ? validLetters[Math.floor(Math.random() * validLetters.length)] : null;
}

function initializeButtons() {
    const container = document.getElementById('letterButtons');
    container.innerHTML = '';
    for (let i = 0; i < 26; i++) {
        const letter = String.fromCharCode(65 + i);
        const btn = document.createElement('button');
        btn.className = 'letter-btn';
        btn.textContent = letter;
        btn.onclick = () => playerChooseLetter(letter);
        btn.id = `btn-${letter}`;
        container.appendChild(btn);
    }
    updateButtonStates();
}

function updateButtonStates() {
    const validLetters = getValidContinuations(currentWord);
    for (let i = 0; i < 26; i++) {
        const letter = String.fromCharCode(65 + i);
        const btn = document.getElementById(`btn-${letter}`);
        if (btn) btn.disabled = !validLetters.includes(letter) || !gameActive || !playerTurn;
    }
}

function playerChooseLetter(letter) {
    if (!gameActive || !playerTurn || !getValidContinuations(currentWord).includes(letter)) return;
    addLetter(letter, true);
}

function addLetter(letter, isPlayer) {
    currentWord += letter;
    document.getElementById('currentWord').textContent = currentWord;
    
    if (isCompleteWord(currentWord)) {
        endGame(!isPlayer);
        return;
    }
    
    if (!getValidContinuations(currentWord).length) {
        endGame(isPlayer);
        return;
    }
    
    playerTurn = !playerTurn;
    updateButtonStates();
    
    if (isPlayer) {
        setStatus("AI's turn...", 'info');
        aiChooseLetter();
    } else {
        setStatus('Your turn!', 'info');
    }
}

function challenge() {
    if (!gameActive || playerTurn) {
        setStatus("Challenge only on AI's turn!", 'error');
        return;
    }
    
    function findWord(prefix, depth) {
        if (depth === 0) return null;
        if (isCompleteWord(prefix)) return prefix;
        const letters = getValidContinuations(prefix);
        for (const letter of letters) {
            const result = findWord(prefix + letter, depth - 1);
            if (result) return result;
        }
        return null;
    }
    
    const foundWord = findWord(currentWord, 10);
    
    if (foundWord) {
        setStatus(`Challenge failed! AI had: ${foundWord}`, 'error');
        endGame(false);
    } else {
        setStatus('Challenge successful!', 'success');
        endGame(true);
    }
}

function endGame(playerWon) {
    gameActive = false;
    stats.games++;
    if (playerWon) {
        stats.wins++;
        setStatus(`You won! ðŸŽ‰ Word: ${currentWord}`, 'success');
    } else {
        stats.losses++;
        setStatus(`AI won! ðŸ˜” Word: ${currentWord}`, 'error');
    }
    updateStats();
    updateButtonStates();
}

function newGame() {
    currentWord = '';
    gameActive = true;
    playerTurn = true;
    minimaxCache.clear();
    document.getElementById('currentWord').textContent = '_';
    document.getElementById('debug').textContent = '';
    setStatus('Choose a letter!', 'info');
    updateButtonStates();
}

function setStatus(message, type = 'info') {
    const statusEl = document.getElementById('status');
    statusEl.textContent = message;
    statusEl.className = `status ${type}`;
}

function updateStats() {
    document.getElementById('winsValue').textContent = stats.wins;
    document.getElementById('lossesValue').textContent = stats.losses;
    const winRate = stats.games > 0 ? (stats.wins / stats.games * 100).toFixed(1) : 0;
    document.getElementById('winRateValue').textContent = winRate + '%';
}

document.querySelectorAll('.ai-option').forEach(option => {
    option.addEventListener('click', function() {
        document.querySelectorAll('.ai-option').forEach(o => o.classList.remove('active'));
        this.classList.add('active');
        aiMode = this.dataset.ai;
        searchDepth = parseInt(this.dataset.depth) || 6;
        minimaxCache.clear();
        newGame();
    });
});

initializeButtons();
    </script>
</body>
</html>
