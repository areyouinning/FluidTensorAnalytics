<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Disc Flight Simulator | Fluid Tensor Analytics</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep: #0a0d12;
            --bg-card: #111820;
            --bg-elevated: #1a2230;
            --bg-input: #0d1117;
            --text-primary: #e8edf5;
            --text-secondary: #8a9bb0;
            --text-dim: #5a6a7a;
            --accent-cyan: #00d4ff;
            --accent-orange: #ff6b35;
            --accent-green: #58d68d;
            --accent-yellow: #f4d03f;
            --accent-red: #e74c3c;
            --border-subtle: rgba(255,255,255,0.08);
            --glow-cyan: rgba(0, 212, 255, 0.12);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Outfit', sans-serif;
            background: var(--bg-deep);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            opacity: 0.025;
            pointer-events: none;
            z-index: 9999;
        }
        
        header {
            padding: 1.25rem 2rem;
            border-bottom: 1px solid var(--border-subtle);
            background: rgba(10, 13, 18, 0.95);
            backdrop-filter: blur(12px);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .header-inner {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--accent-cyan);
            text-decoration: none;
            letter-spacing: 0.05em;
        }
        
        .logo span { color: var(--text-secondary); }
        
        nav a {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.8rem;
            margin-left: 1.5rem;
            transition: color 0.2s;
        }
        
        nav a:hover { color: var(--text-primary); }
        
        .simulator-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 2rem;
            display: grid;
            grid-template-columns: 340px 1fr;
            gap: 2rem;
            min-height: calc(100vh - 70px);
        }
        
        @media (max-width: 1100px) {
            .simulator-container {
                grid-template-columns: 1fr;
            }
        }
        
        .control-panel {
            background: var(--bg-card);
            border-radius: 16px;
            border: 1px solid var(--border-subtle);
            padding: 1.5rem;
            height: fit-content;
            position: sticky;
            top: 90px;
        }
        
        .panel-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--accent-cyan);
            letter-spacing: 0.15em;
            text-transform: uppercase;
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-subtle);
        }
        
        .control-group {
            margin-bottom: 1.5rem;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 0.5rem;
        }
        
        .control-label label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 400;
        }
        
        .control-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--accent-orange);
            min-width: 70px;
            text-align: right;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: var(--bg-elevated);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent-cyan);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 212, 255, 0.3);
            transition: transform 0.15s, box-shadow 0.15s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
            box-shadow: 0 2px 12px rgba(0, 212, 255, 0.5);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--accent-cyan);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .toggle-group {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .toggle-btn {
            flex: 1;
            padding: 0.6rem 0.75rem;
            border: 1px solid var(--border-subtle);
            background: var(--bg-input);
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        
        .toggle-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        .toggle-btn.active {
            background: var(--accent-cyan);
            color: var(--bg-deep);
            border-color: var(--accent-cyan);
            font-weight: 600;
        }
        
        .toggle-btn.active.rhfh {
            background: var(--accent-orange);
            border-color: var(--accent-orange);
        }
        
        .run-btn {
            width: 100%;
            padding: 1rem;
            margin-top: 1.5rem;
            background: linear-gradient(135deg, var(--accent-cyan), #0099cc);
            border: none;
            color: var(--bg-deep);
            font-family: 'Outfit', sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 16px rgba(0, 212, 255, 0.2);
        }
        
        .run-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 24px rgba(0, 212, 255, 0.3);
        }
        
        .run-btn:active {
            transform: translateY(0);
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        
        .canvas-container {
            background: var(--bg-card);
            border-radius: 16px;
            border: 1px solid var(--border-subtle);
            padding: 1.5rem;
            position: relative;
        }
        
        canvas {
            width: 100%;
            border-radius: 8px;
            background: var(--bg-elevated);
            display: block;
        }
        
        .time-slider-container {
            background: var(--bg-card);
            border-radius: 16px;
            border: 1px solid var(--border-subtle);
            padding: 1.5rem;
            display: none;
        }
        
        .time-slider-container.active {
            display: block;
        }
        
        .time-slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .time-slider-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--accent-cyan);
            letter-spacing: 0.15em;
            text-transform: uppercase;
        }
        
        .time-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--accent-orange);
        }
        
        .time-slider-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        
        .play-btn {
            padding: 0.5rem 1.5rem;
            background: var(--accent-green);
            border: none;
            color: var(--bg-deep);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 80px;
        }
        
        .play-btn:hover {
            transform: scale(1.05);
        }
        
        #timeSlider {
            flex: 1;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }
        
        .stat-card {
            background: var(--bg-elevated);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border-subtle);
        }
        
        .stat-label {
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .stat-value {
            font-size: 1.6rem;
            color: var(--text-primary);
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .stat-unit {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-left: 0.25rem;
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
        }
        
        .chart-card {
            background: var(--bg-card);
            border-radius: 16px;
            border: 1px solid var(--border-subtle);
            padding: 1.5rem;
        }
        
        .chart-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--accent-cyan);
            letter-spacing: 0.15em;
            text-transform: uppercase;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <header>
        <div class="header-inner">
            <a href="#" class="logo">FLUID<span>_</span>TENSOR<span>_</span>ANALYTICS</a>
            <nav>
                <a href="#">Home</a>
                <a href="#">Simulations</a>
                <a href="#">About</a>
            </nav>
        </div>
    </header>

    <div class="simulator-container">
        <aside class="control-panel">
            <div class="panel-title">Flight Parameters</div>
            
            <div class="control-group">
                <div class="control-label">
                    <label>Release Velocity</label>
                    <span class="control-value" id="velocityValue">25.0 m/s</span>
                </div>
                <input type="range" id="velocity" min="10" max="35" step="0.5" value="25">
            </div>
            
            <div class="control-group">
                <div class="control-label">
                    <label>Release Angle</label>
                    <span class="control-value" id="angleValue">10.0°</span>
                </div>
                <input type="range" id="angle" min="-5" max="25" step="1" value="10">
            </div>
            
            <div class="control-group">
                <div class="control-label">
                    <label>Nose Angle</label>
                    <span class="control-value" id="noseValue">-2.0°</span>
                </div>
                <input type="range" id="nose" min="-10" max="5" step="0.5" value="-2">
            </div>
            
            <div class="control-group">
                <div class="control-label">
                    <label>Spin Rate</label>
                    <span class="control-value" id="spinValue">150 rpm</span>
                </div>
                <input type="range" id="spin" min="50" max="300" step="10" value="150">
            </div>
            
            <div class="control-group">
                <div class="control-label">
                    <label>Wind Speed</label>
                    <span class="control-value" id="windValue">0.0 m/s</span>
                </div>
                <input type="range" id="wind" min="0" max="10" step="0.5" value="0">
            </div>
            
            <div class="control-group">
                <div class="control-label">
                    <label>Throwing Style</label>
                </div>
                <div class="toggle-group">
                    <button class="toggle-btn active" id="rhbh">RHBH</button>
                    <button class="toggle-btn rhfh" id="rhfh">RHFH</button>
                </div>
            </div>
            
            <button class="run-btn" id="runBtn">Run Simulation</button>
        </aside>

        <main class="main-content">
            <div class="canvas-container">
                <canvas id="mainCanvas"></canvas>
            </div>
            
            <div class="time-slider-container" id="timeSliderContainer">
                <div class="time-slider-header">
                    <span class="time-slider-title">Flight Replay</span>
                    <span class="time-display" id="timeDisplay">0.00 s</span>
                </div>
                <div class="time-slider-controls">
                    <button class="play-btn" id="playBtn">Play</button>
                    <input type="range" id="timeSlider" min="0" max="100" value="0">
                </div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Distance</div>
                    <div class="stat-value" id="statDistance">—<span class="stat-unit">m</span></div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Max Height</div>
                    <div class="stat-value" id="statMaxHeight">—<span class="stat-unit">m</span></div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Flight Time</div>
                    <div class="stat-value" id="statFlightTime">—<span class="stat-unit">s</span></div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Final Roll</div>
                    <div class="stat-value" id="statFinalRoll">—<span class="stat-unit">°</span></div>
                </div>
            </div>
            
            <div class="charts-container">
                <div class="chart-card">
                    <div class="chart-title">Flight Path (Top View)</div>
                    <canvas id="trajectoryChart"></canvas>
                </div>
                <div class="chart-card">
                    <div class="chart-title">Roll Angle vs Time</div>
                    <canvas id="rollChart"></canvas>
                </div>
            </div>
        </main>
    </div>

    <script>
    // ============================================================
    // GLOBALS & INITIALIZATION
    // ============================================================
    
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const trajectoryCanvas = document.getElementById('trajectoryChart');
    const trajCtx = trajectoryCanvas.getContext('2d');
    const rollCanvas = document.getElementById('rollChart');
    const rollCtx = rollCanvas.getContext('2d');
    
    let dpr = window.devicePixelRatio || 1;
    
    function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        
        const trajRect = trajectoryCanvas.getBoundingClientRect();
        trajectoryCanvas.width = trajRect.width * dpr;
        trajectoryCanvas.height = trajRect.height * dpr;
        
        const rollRect = rollCanvas.getBoundingClientRect();
        rollCanvas.width = rollRect.width * dpr;
        rollCanvas.height = rollRect.height * dpr;
    }
    
    resizeCanvas();
    window.addEventListener('resize', () => {
        resizeCanvas();
        if (history) {
            drawFrame(currentFrame);
            drawTrajectoryChart();
            drawRollChart();
        }
    });
    
    // Parameters
    let params = {
        velocity: 25,
        angle: 10,
        nose: -2,
        spin: 150,
        wind: 0,
        throwType: 'RHBH'
    };
    
    let history = null;
    let currentFrame = 0;
    let isPlaying = false;
    let playInterval = null;
    
    // ============================================================
    // UI CONTROLS
    // ============================================================
    
    document.getElementById('velocity').addEventListener('input', e => {
        params.velocity = parseFloat(e.target.value);
        document.getElementById('velocityValue').textContent = params.velocity.toFixed(1) + ' m/s';
    });
    
    document.getElementById('angle').addEventListener('input', e => {
        params.angle = parseFloat(e.target.value);
        document.getElementById('angleValue').textContent = params.angle.toFixed(1) + '°';
    });
    
    document.getElementById('nose').addEventListener('input', e => {
        params.nose = parseFloat(e.target.value);
        document.getElementById('noseValue').textContent = params.nose.toFixed(1) + '°';
    });
    
    document.getElementById('spin').addEventListener('input', e => {
        params.spin = parseFloat(e.target.value);
        document.getElementById('spinValue').textContent = params.spin.toFixed(0) + ' rpm';
    });
    
    document.getElementById('wind').addEventListener('input', e => {
        params.wind = parseFloat(e.target.value);
        document.getElementById('windValue').textContent = params.wind.toFixed(1) + ' m/s';
    });
    
    document.getElementById('rhbh').addEventListener('click', () => {
        params.throwType = 'RHBH';
        document.getElementById('rhbh').classList.add('active');
        document.getElementById('rhfh').classList.remove('active');
    });
    
    document.getElementById('rhfh').addEventListener('click', () => {
        params.throwType = 'RHFH';
        document.getElementById('rhfh').classList.add('active');
        document.getElementById('rhbh').classList.remove('active');
    });
    
    document.getElementById('runBtn').addEventListener('click', runSimulation);
    
    // Time slider controls
    const timeSlider = document.getElementById('timeSlider');
    const playBtn = document.getElementById('playBtn');
    
    timeSlider.addEventListener('input', e => {
        if (history) {
            currentFrame = parseInt(e.target.value);
            drawFrame(currentFrame);
            highlightChartPosition(currentFrame);
            updateTimeDisplay();
        }
    });
    
    playBtn.addEventListener('click', () => {
        if (!history) return;
        
        if (isPlaying) {
            stopPlayback();
        } else {
            startPlayback();
        }
    });
    
    function startPlayback() {
        isPlaying = true;
        playBtn.textContent = 'Pause';
        
        playInterval = setInterval(() => {
            if (currentFrame >= history.pos.length - 1) {
                currentFrame = 0;
            } else {
                currentFrame++;
            }
            timeSlider.value = currentFrame;
            drawFrame(currentFrame);
            highlightChartPosition(currentFrame);
            updateTimeDisplay();
        }, 50); // 20 fps
    }
    
    function stopPlayback() {
        isPlaying = false;
        playBtn.textContent = 'Play';
        if (playInterval) {
            clearInterval(playInterval);
            playInterval = null;
        }
    }
    
    function updateTimeDisplay() {
        if (history) {
            const time = history.time[currentFrame];
            document.getElementById('timeDisplay').textContent = time.toFixed(2) + ' s';
        }
    }
    
    // ============================================================
    // PHYSICS SIMULATION
    // ============================================================
    
    function runSimulation() {
        stopPlayback();
        
        const v0 = params.velocity;
        const theta = params.angle * Math.PI / 180;
        const alpha = params.nose * Math.PI / 180;
        const omega = params.spin * 2 * Math.PI / 60; // rpm to rad/s
        const windSpeed = params.wind;
        const isRHBH = params.throwType === 'RHBH';
        
        const m = 0.175; // kg
        const A = 0.0573; // m^2
        const rho = 1.225; // kg/m^3
        const g = 9.81; // m/s^2
        const Cd = 0.3;
        const Cl_alpha = 1.5;
        
        // Initial conditions
        let pos = [0, 0, 1.5];
        let vel = [
            v0 * Math.cos(theta),
            0,
            v0 * Math.sin(theta)
        ];
        let roll = 0;
        
        const dt = 0.01;
        const maxTime = 10;
        
        history = {
            pos: [],
            vel: [],
            roll: [],
            time: []
        };
        
        for (let t = 0; t < maxTime; t += dt) {
            // Store current state first
            history.pos.push([...pos]);
            history.vel.push([...vel]);
            history.roll.push(roll);
            history.time.push(t);
            
            // Check if disc has hit ground (stop before next step)
            if (pos[2] <= 0) break;
            
            const vMag = Math.sqrt(vel[0]*vel[0] + vel[1]*vel[1] + vel[2]*vel[2]);
            if (vMag < 0.1 || isNaN(vMag)) break;
            
            const vDir = [vel[0]/vMag, vel[1]/vMag, vel[2]/vMag];
            
            // Drag
            const Fd = 0.5 * rho * A * Cd * vMag * vMag;
            const drag = [-Fd * vDir[0] / m, -Fd * vDir[1] / m, -Fd * vDir[2] / m];
            
            // Lift
            const aoa = alpha + Math.atan2(vel[2], Math.sqrt(vel[0]*vel[0] + vel[1]*vel[1]));
            const Cl = Cl_alpha * aoa;
            const Fl = 0.5 * rho * A * Cl * vMag * vMag;
            const liftDir = [-Math.sin(theta), 0, Math.cos(theta)];
            const lift = [Fl * liftDir[0] / m, Fl * liftDir[1] / m, Fl * liftDir[2] / m];
            
            // Magnus (gyroscopic precession)
            const spinDir = isRHBH ? -1 : 1;
            const magnus_y = spinDir * 0.15 * vMag * omega;
            const rollRate = spinDir * 0.8 * (1 - Math.exp(-t * 0.5));
            
            // Wind
            const windForce = [windSpeed * 0.3, 0, 0];
            
            // Update
            vel[0] += (drag[0] + lift[0] + windForce[0]) * dt;
            vel[1] += magnus_y * dt;
            vel[2] += (drag[2] + lift[2] - g) * dt;
            
            // Check for NaN
            if (isNaN(vel[0]) || isNaN(vel[1]) || isNaN(vel[2])) break;
            
            pos[0] += vel[0] * dt;
            pos[1] += vel[1] * dt;
            pos[2] += vel[2] * dt;
            
            // Clamp height to ground
            if (pos[2] < 0) pos[2] = 0;
            
            roll += rollRate * dt;
        }
        
        // Setup time slider
        timeSlider.max = history.pos.length - 1;
        timeSlider.value = 0;
        currentFrame = 0;
        document.getElementById('timeSliderContainer').classList.add('active');
        
        // Draw results
        drawFrame(0);
        drawTrajectoryChart();
        drawRollChart();
        updateStats();
        updateTimeDisplay();
    }
    
    // ============================================================
    // VISUALIZATION
    // ============================================================
    
    function drawFrame(frameIdx) {
        if (!history || frameIdx >= history.pos.length) return;
        
        const W = canvas.width / dpr;
        const H = canvas.height / dpr;
        
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, W, H);
        
        // Background
        ctx.fillStyle = '#1a2230';
        ctx.fillRect(0, 0, W, H);
        
        // Ground
        ctx.fillStyle = '#0d1117';
        ctx.fillRect(0, H * 0.65, W, H * 0.35);
        
        // Grid
        ctx.strokeStyle = '#2a3444';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 10; i++) {
            const y = H * 0.65 + i * (H * 0.35 / 10);
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(W, y);
            ctx.stroke();
        }
        
        // Draw trail
        const scale = 8;
        const offsetY = H * 0.5;
        
        ctx.strokeStyle = 'rgba(0, 212, 255, 0.3)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i <= frameIdx; i++) {
            const p = history.pos[i];
            const x = 50 + p[0] * scale;
            const y = offsetY - p[2] * scale;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
        
        // Current disc position
        const pos = history.pos[frameIdx];
        const x = 50 + pos[0] * scale;
        const y = offsetY - pos[2] * scale;
        const roll = history.roll[frameIdx];
        
        // Draw disc
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(roll);
        
        // Disc body
        const discRadius = 15;
        ctx.fillStyle = '#00d4ff';
        ctx.beginPath();
        ctx.ellipse(0, 0, discRadius, discRadius * 0.3, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Disc rim
        ctx.strokeStyle = '#0099cc';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Spin indicator
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(discRadius * 0.6, 0, 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
        
        // Velocity vector
        const vel = history.vel[frameIdx];
        const velMag = Math.sqrt(vel[0]*vel[0] + vel[1]*vel[1] + vel[2]*vel[2]);
        const velScale = 3;
        ctx.strokeStyle = '#58d68d';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + vel[0] * velScale, y - vel[2] * velScale);
        ctx.stroke();
        
        // Info overlay
        ctx.fillStyle = '#e8edf5';
        ctx.font = '12px JetBrains Mono';
        ctx.fillText(`Frame: ${frameIdx + 1}/${history.pos.length}`, 20, 30);
        ctx.fillText(`Pos: (${pos[0].toFixed(1)}, ${pos[1].toFixed(1)}, ${pos[2].toFixed(1)}) m`, 20, 50);
        ctx.fillText(`Vel: ${velMag.toFixed(1)} m/s`, 20, 70);
        ctx.fillText(`Roll: ${(roll * 180 / Math.PI).toFixed(1)}°`, 20, 90);
    }
    
    function drawTrajectoryChart() {
        if (!history) return;
        
        const W = trajectoryCanvas.width / dpr;
        const H = trajectoryCanvas.height / dpr;
        
        trajCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        trajCtx.clearRect(0, 0, W, H);
        
        const padding = 30;
        const plotW = W - padding * 2;
        const plotH = H - padding * 2;
        
        let maxX = 0, maxY = 0;
        for (const p of history.pos) {
            maxX = Math.max(maxX, Math.abs(p[0]));
            maxY = Math.max(maxY, Math.abs(p[1]));
        }
        
        const scaleX = plotW / (maxX * 1.2);
        const scaleY = plotH / (maxY * 2.4);
        
        // Grid
        trajCtx.strokeStyle = '#2a3444';
        trajCtx.lineWidth = 1;
        trajCtx.beginPath();
        trajCtx.moveTo(padding, H/2);
        trajCtx.lineTo(W - padding, H/2);
        trajCtx.moveTo(padding, padding);
        trajCtx.lineTo(padding, H - padding);
        trajCtx.stroke();
        
        // Labels
        trajCtx.fillStyle = '#5a6a7a';
        trajCtx.font = '10px JetBrains Mono';
        trajCtx.textAlign = 'center';
        trajCtx.fillText('Distance (m)', W/2, H - 8);
        trajCtx.save();
        trajCtx.translate(12, H/2);
        trajCtx.rotate(-Math.PI/2);
        trajCtx.fillText('Lateral (m)', 0, 0);
        trajCtx.restore();
        
        // Path
        trajCtx.beginPath();
        trajCtx.strokeStyle = '#00d4ff';
        trajCtx.lineWidth = 2;
        
        for (let i = 0; i < history.pos.length; i++) {
            const p = history.pos[i];
            const x = padding + p[0] * scaleX;
            const y = H/2 - p[1] * scaleY;
            if (i === 0) trajCtx.moveTo(x, y);
            else trajCtx.lineTo(x, y);
        }
        trajCtx.stroke();
        
        // Landing
        const last = history.pos[history.pos.length - 1];
        trajCtx.fillStyle = '#ff6b35';
        trajCtx.beginPath();
        trajCtx.arc(padding + last[0] * scaleX, H/2 - last[1] * scaleY, 5, 0, Math.PI * 2);
        trajCtx.fill();
        
        trajectoryCanvas.chartData = { padding, scaleX, scaleY, H };
    }
    
    function drawRollChart() {
        if (!history) return;
        
        const W = rollCanvas.width / dpr;
        const H = rollCanvas.height / dpr;
        
        rollCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        rollCtx.clearRect(0, 0, W, H);
        
        const padding = 30;
        const plotW = W - padding * 2;
        const plotH = H - padding * 2;
        
        const maxT = history.time[history.time.length - 1];
        let maxRoll = 0;
        for (const r of history.roll) {
            maxRoll = Math.max(maxRoll, Math.abs(r));
        }
        maxRoll = Math.max(maxRoll * 180 / Math.PI, 30) * 1.2;
        
        const scaleX = plotW / maxT;
        const scaleY = plotH / (maxRoll * 2);
        
        // Grid
        rollCtx.strokeStyle = '#2a3444';
        rollCtx.lineWidth = 1;
        rollCtx.beginPath();
        rollCtx.moveTo(padding, H/2);
        rollCtx.lineTo(W - padding, H/2);
        rollCtx.stroke();
        
        // Labels
        rollCtx.fillStyle = '#5a6a7a';
        rollCtx.font = '10px JetBrains Mono';
        rollCtx.textAlign = 'center';
        rollCtx.fillText('Time (s)', W/2, H - 8);
        
        // Roll curve
        rollCtx.beginPath();
        rollCtx.strokeStyle = '#f4d03f';
        rollCtx.lineWidth = 2;
        
        for (let i = 0; i < history.time.length; i++) {
            const t = history.time[i];
            const rollDeg = history.roll[i] * 180 / Math.PI;
            const x = padding + t * scaleX;
            const y = H/2 - rollDeg * scaleY;
            if (i === 0) rollCtx.moveTo(x, y);
            else rollCtx.lineTo(x, y);
        }
        rollCtx.stroke();
        
        rollCanvas.chartData = { padding, scaleX, scaleY, H };
    }
    
    function highlightChartPosition(frameIdx) {
        drawTrajectoryChart();
        drawRollChart();
        
        if (!history) return;
        
        // Trajectory highlight
        const td = trajectoryCanvas.chartData;
        if (td) {
            const p = history.pos[frameIdx];
            const x = td.padding + p[0] * td.scaleX;
            const y = td.H/2 - p[1] * td.scaleY;
            trajCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            trajCtx.fillStyle = '#fff';
            trajCtx.beginPath();
            trajCtx.arc(x, y, 4, 0, Math.PI * 2);
            trajCtx.fill();
        }
        
        // Roll highlight
        const rd = rollCanvas.chartData;
        if (rd) {
            const t = history.time[frameIdx];
            const rollDeg = history.roll[frameIdx] * 180 / Math.PI;
            const x = rd.padding + t * rd.scaleX;
            const y = rd.H/2 - rollDeg * rd.scaleY;
            rollCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            rollCtx.fillStyle = '#fff';
            rollCtx.beginPath();
            rollCtx.arc(x, y, 4, 0, Math.PI * 2);
            rollCtx.fill();
        }
    }
    
    function updateStats() {
        if (!history) return;
        
        const lastPos = history.pos[history.pos.length - 1];
        const distance = Math.sqrt(lastPos[0]*lastPos[0] + lastPos[1]*lastPos[1]);
        let maxHeight = 0;
        for (const p of history.pos) {
            maxHeight = Math.max(maxHeight, p[2]);
        }
        const flightTime = history.time[history.time.length - 1];
        const finalRoll = history.roll[history.roll.length - 1] * 180 / Math.PI;
        
        document.getElementById('statDistance').innerHTML = distance.toFixed(1) + '<span class="stat-unit">m</span>';
        document.getElementById('statMaxHeight').innerHTML = maxHeight.toFixed(1) + '<span class="stat-unit">m</span>';
        document.getElementById('statFlightTime').innerHTML = flightTime.toFixed(2) + '<span class="stat-unit">s</span>';
        document.getElementById('statFinalRoll').innerHTML = finalRoll.toFixed(1) + '<span class="stat-unit">°</span>';
    }
    
    // Initial state
    ctx.fillStyle = '#1a2230';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#5a6a7a';
    ctx.font = '14px Outfit';
    ctx.textAlign = 'center';
    ctx.fillText('Click "Run Simulation" to begin', canvas.width / dpr / 2, canvas.height / dpr / 2);
    </script>
</body>
</html>
