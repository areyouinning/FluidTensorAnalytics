<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Disc Flight Simulator | Fluid Tensor Analytics</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep: #0a0d12;
            --bg-card: #111820;
            --bg-elevated: #1a2230;
            --bg-input: #0d1117;
            --text-primary: #e8edf5;
            --text-secondary: #8a9bb0;
            --text-dim: #5a6a7a;
            --accent-cyan: #00d4ff;
            --accent-orange: #ff6b35;
            --accent-green: #58d68d;
            --accent-yellow: #f4d03f;
            --accent-red: #e74c3c;
            --border-subtle: rgba(255,255,255,0.08);
            --glow-cyan: rgba(0, 212, 255, 0.12);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Outfit', sans-serif;
            background: var(--bg-deep);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            opacity: 0.025;
            pointer-events: none;
            z-index: 9999;
        }
        
        header {
            padding: 1.25rem 2rem;
            border-bottom: 1px solid var(--border-subtle);
            background: rgba(10, 13, 18, 0.95);
            backdrop-filter: blur(12px);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .header-inner {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--accent-cyan);
            text-decoration: none;
            letter-spacing: 0.05em;
        }
        
        .logo span { color: var(--text-secondary); }
        
        nav a {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.8rem;
            margin-left: 1.5rem;
            transition: color 0.2s;
        }
        
        nav a:hover { color: var(--text-primary); }
        
        .simulator-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 2rem;
            display: grid;
            grid-template-columns: 340px 1fr;
            gap: 2rem;
            min-height: calc(100vh - 70px);
        }
        
        @media (max-width: 1100px) {
            .simulator-container {
                grid-template-columns: 1fr;
            }
        }
        
        .control-panel {
            background: var(--bg-card);
            border-radius: 16px;
            border: 1px solid var(--border-subtle);
            padding: 1.5rem;
            height: fit-content;
            position: sticky;
            top: 90px;
        }
        
        .panel-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--accent-cyan);
            letter-spacing: 0.15em;
            text-transform: uppercase;
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-subtle);
        }
        
        .control-group {
            margin-bottom: 1.5rem;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 0.5rem;
        }
        
        .control-label label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 400;
        }
        
        .control-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--accent-orange);
            min-width: 70px;
            text-align: right;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: var(--bg-elevated);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent-cyan);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 212, 255, 0.3);
            transition: transform 0.15s, box-shadow 0.15s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
            box-shadow: 0 2px 12px rgba(0, 212, 255, 0.5);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--accent-cyan);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .toggle-group {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .toggle-btn {
            flex: 1;
            padding: 0.6rem 0.75rem;
            border: 1px solid var(--border-subtle);
            background: var(--bg-input);
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        
        .toggle-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        .toggle-btn.active {
            background: var(--accent-cyan);
            color: var(--bg-deep);
            border-color: var(--accent-cyan);
            font-weight: 600;
        }
        
        .toggle-btn.active.rhfh {
            background: var(--accent-orange);
            border-color: var(--accent-orange);
        }
        
        .run-btn {
            width: 100%;
            padding: 1rem;
            margin-top: 1.5rem;
            background: linear-gradient(135deg, var(--accent-cyan), #0099cc);
            border: none;
            color: var(--bg-deep);
            font-family: 'Outfit', sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 16px rgba(0, 212, 255, 0.2);
        }
        
        .run-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 24px rgba(0, 212, 255, 0.3);
        }
        
        .run-btn:active {
            transform: translateY(0);
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        
        .canvas-container {
            background: var(--bg-card);
            border-radius: 16px;
            border: 1px solid var(--border-subtle);
            padding: 1.5rem;
            position: relative;
        }
        
        canvas {
            width: 100%;
            border-radius: 8px;
            background: var(--bg-elevated);
            display: block;
        }
        
        .time-slider-container {
            background: var(--bg-card);
            border-radius: 16px;
            border: 1px solid var(--border-subtle);
            padding: 1.5rem;
            display: none;
        }
        
        .time-slider-container.active {
            display: block;
        }
        
        .time-slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .time-slider-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--accent-cyan);
            letter-spacing: 0.15em;
            text-transform: uppercase;
        }
        
        .time-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--accent-orange);
        }
        
        .time-slider-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        
        .play-btn {
            padding: 0.5rem 1.5rem;
            background: var(--accent-green);
            border: none;
            color: var(--bg-deep);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 80px;
        }
        
        .play-btn:hover {
            transform: scale(1.05);
        }
        
        #timeSlider {
            flex: 1;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }
        
        .stat-card {
            background: var(--bg-elevated);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border-subtle);
        }
        
        .stat-label {
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .stat-value {
            font-size: 1.6rem;
            color: var(--text-primary);
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .stat-unit {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-left: 0.25rem;
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
        }
        
        .chart-card {
            background: var(--bg-card);
            border-radius: 16px;
            border: 1px solid var(--border-subtle);
            padding: 1.5rem;
        }
        
        .chart-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--accent-cyan);
            letter-spacing: 0.15em;
            text-transform: uppercase;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <header>
        <div class="header-inner">
            <a href="#" class="logo">FLUID<span>_</span>TENSOR<span>_</span>ANALYTICS</a>
            <nav>
                <a href="#">Home</a>
                <a href="#">Simulations</a>
                <a href="#">About</a>
            </nav>
        </div>
    </header>

    <div class="simulator-container">
        <aside class="control-panel">
            <div class="panel-title">Flight Parameters</div>
            
            <div class="control-group">
                <div class="control-label">
                    <label>Release Velocity</label>
                    <span class="control-value" id="velocityValue">25.0 m/s</span>
                </div>
                <input type="range" id="velocity" min="10" max="35" step="0.5" value="25">
            </div>
            
            <div class="control-group">
                <div class="control-label">
                    <label>Release Angle</label>
                    <span class="control-value" id="angleValue">10.0°</span>
                </div>
                <input type="range" id="angle" min="-5" max="25" step="1" value="10">
                <div style="font-size: 0.7rem; color: var(--text-dim); margin-top: 0.25rem;">
                    Initial trajectory angle (up/down from horizontal)
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-label">
                    <label>Hyzer Angle</label>
                    <span class="control-value" id="hyzerValue">0.0°</span>
                </div>
                <input type="range" id="hyzer" min="-30" max="30" step="1" value="0">
                <div style="font-size: 0.7rem; color: var(--text-dim); margin-top: 0.25rem;">
                    Disc tilt at release: (-) Hyzer / (+) Anhyzer
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-label">
                    <label>Nose Angle</label>
                    <span class="control-value" id="noseValue">-2.0°</span>
                </div>
                <input type="range" id="nose" min="-10" max="5" step="0.5" value="-2">
                <div style="font-size: 0.7rem; color: var(--text-dim); margin-top: 0.25rem;">
                    Front edge tilt: (-) nose down / (+) nose up. -2° is ideal.
                </div>
            </div>
            
            <div style="margin-top: 1.5rem; padding: 1rem; background: var(--bg-elevated); border-radius: 8px; border: 1px solid var(--border-subtle);">
                <div style="font-size: 0.85rem; font-weight: 600; color: var(--text-primary); margin-bottom: 0.75rem;">
                    Angle Guide
                </div>
                <div style="font-size: 0.75rem; color: var(--text-secondary); line-height: 1.6;">
                    <div style="margin-bottom: 0.5rem;">
                        <strong style="color: var(--accent-cyan);">Release Angle:</strong> Direction of throw (up/down)
                        <br>10° = upward trajectory, 0° = flat, -5° = downward
                    </div>
                    <div style="margin-bottom: 0.5rem;">
                        <strong style="color: var(--accent-green);">Hyzer Angle:</strong> Left/right tilt of disc
                        <br>-20° = hyzer (RHBH tilted right), +20° = anhyzer (tilted left)
                    </div>
                    <div>
                        <strong style="color: var(--accent-yellow);">Nose Angle:</strong> Pitch of disc relative to flight
                        <br>-2° = nose down (good), 0° = flat, +5° = nose up (bad)
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-label">
                    <label>Disc Stability</label>
                    <span class="control-value" id="stabilityValue">0.0</span>
                </div>
                <input type="range" id="stability" min="-3" max="3" step="0.5" value="0">
                <div style="font-size: 0.7rem; color: var(--text-dim); margin-top: 0.25rem;">
                    Negative = Understable, Positive = Overstable
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-label">
                    <label>Spin Rate</label>
                    <span class="control-value" id="spinValue">150 rpm</span>
                </div>
                <input type="range" id="spin" min="50" max="300" step="10" value="150">
            </div>
            
            <div class="control-group">
                <div class="control-label">
                    <label>Wind Speed</label>
                    <span class="control-value" id="windValue">0.0 m/s</span>
                </div>
                <input type="range" id="wind" min="0" max="10" step="0.5" value="0">
            </div>
            
            <div class="control-group">
                <div class="control-label">
                    <label>Throwing Style</label>
                </div>
                <div class="toggle-group">
                    <button class="toggle-btn active" id="rhbh">RHBH</button>
                    <button class="toggle-btn rhfh" id="rhfh">RHFH</button>
                </div>
            </div>
            
            <button class="run-btn" id="runBtn">Run Simulation</button>
        </aside>

        <main class="main-content">
            <div class="canvas-container">
                <div class="chart-title">View from Behind - Wingtip Vortices</div>
                <canvas id="behindCanvas"></canvas>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-top: 1.5rem;">
                <div class="canvas-container">
                    <div class="chart-title">Top View (XY Plane)</div>
                    <canvas id="topCanvas"></canvas>
                </div>
                
                <div class="canvas-container">
                    <div class="chart-title">Side View (XZ Plane)</div>
                    <canvas id="sideCanvas"></canvas>
                </div>
            </div>
            
            <div class="time-slider-container" id="timeSliderContainer">
                <div class="time-slider-header">
                    <span class="time-slider-title">Flight Replay</span>
                    <span class="time-display" id="timeDisplay">0.00 s</span>
                </div>
                <div class="time-slider-controls">
                    <button class="play-btn" id="playBtn">Play</button>
                    <input type="range" id="timeSlider" min="0" max="100" value="0">
                </div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Distance</div>
                    <div class="stat-value" id="statDistance">—<span class="stat-unit">m</span></div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Max Height</div>
                    <div class="stat-value" id="statMaxHeight">—<span class="stat-unit">m</span></div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Flight Time</div>
                    <div class="stat-value" id="statFlightTime">—<span class="stat-unit">s</span></div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Final Roll</div>
                    <div class="stat-value" id="statFinalRoll">—<span class="stat-unit">°</span></div>
                </div>
            </div>
            
            <div class="charts-container">
                <div class="chart-card">
                    <div class="chart-title">Flight Path (Top View)</div>
                    <canvas id="trajectoryChart"></canvas>
                </div>
                <div class="chart-card">
                    <div class="chart-title">Roll Angle vs Time</div>
                    <canvas id="rollChart"></canvas>
                </div>
            </div>
        </main>
    </div>

    <script>
    // ============================================================
    // GLOBALS & INITIALIZATION
    // ============================================================
    
    const behindCanvas = document.getElementById('behindCanvas');
    const behindCtx = behindCanvas.getContext('2d');
    const topCanvas = document.getElementById('topCanvas');
    const topCtx = topCanvas.getContext('2d');
    const sideCanvas = document.getElementById('sideCanvas');
    const sideCtx = sideCanvas.getContext('2d');
    const trajectoryCanvas = document.getElementById('trajectoryChart');
    const trajCtx = trajectoryCanvas.getContext('2d');
    const rollCanvas = document.getElementById('rollChart');
    const rollCtx = rollCanvas.getContext('2d');
    
    let dpr = window.devicePixelRatio || 1;
    
    function resizeCanvas() {
        const behindRect = behindCanvas.getBoundingClientRect();
        behindCanvas.width = behindRect.width * dpr;
        behindCanvas.height = behindRect.height * dpr;
        
        const topRect = topCanvas.getBoundingClientRect();
        topCanvas.width = topRect.width * dpr;
        topCanvas.height = topRect.height * dpr;
        
        const sideRect = sideCanvas.getBoundingClientRect();
        sideCanvas.width = sideRect.width * dpr;
        sideCanvas.height = sideRect.height * dpr;
        
        const trajRect = trajectoryCanvas.getBoundingClientRect();
        trajectoryCanvas.width = trajRect.width * dpr;
        trajectoryCanvas.height = trajRect.height * dpr;
        
        const rollRect = rollCanvas.getBoundingClientRect();
        rollCanvas.width = rollRect.width * dpr;
        rollCanvas.height = rollRect.height * dpr;
    }
    
    resizeCanvas();
    window.addEventListener('resize', () => {
        resizeCanvas();
        if (history) {
            drawBehindView(currentFrame);
            drawTopView(currentFrame);
            drawSideView(currentFrame);
            drawTrajectoryChart();
            drawRollChart();
        }
    });
    
    // Run initial simulation automatically
    setTimeout(() => {
        runSimulation();
    }, 500);
    
    // Parameters
    let params = {
        velocity: 25,
        angle: 10,
        hyzer: 0,
        nose: -2,
        stability: 0,
        spin: 150,
        wind: 0,
        throwType: 'RHBH'
    };
    
    let history = null;
    let currentFrame = 0;
    let isPlaying = false;
    let playInterval = null;
    
    // ============================================================
    // UI CONTROLS
    // ============================================================
    
    document.getElementById('velocity').addEventListener('input', e => {
        params.velocity = parseFloat(e.target.value);
        document.getElementById('velocityValue').textContent = params.velocity.toFixed(1) + ' m/s';
    });
    
    document.getElementById('angle').addEventListener('input', e => {
        params.angle = parseFloat(e.target.value);
        document.getElementById('angleValue').textContent = params.angle.toFixed(1) + '°';
    });
    
    document.getElementById('hyzer').addEventListener('input', e => {
        params.hyzer = parseFloat(e.target.value);
        document.getElementById('hyzerValue').textContent = params.hyzer.toFixed(1) + '°';
    });
    
    document.getElementById('nose').addEventListener('input', e => {
        params.nose = parseFloat(e.target.value);
        document.getElementById('noseValue').textContent = params.nose.toFixed(1) + '°';
    });
    
    document.getElementById('stability').addEventListener('input', e => {
        params.stability = parseFloat(e.target.value);
        document.getElementById('stabilityValue').textContent = params.stability.toFixed(1);
    });
    
    document.getElementById('spin').addEventListener('input', e => {
        params.spin = parseFloat(e.target.value);
        document.getElementById('spinValue').textContent = params.spin.toFixed(0) + ' rpm';
    });
    
    document.getElementById('wind').addEventListener('input', e => {
        params.wind = parseFloat(e.target.value);
        document.getElementById('windValue').textContent = params.wind.toFixed(1) + ' m/s';
    });
    
    document.getElementById('rhbh').addEventListener('click', () => {
        params.throwType = 'RHBH';
        document.getElementById('rhbh').classList.add('active');
        document.getElementById('rhfh').classList.remove('active');
    });
    
    document.getElementById('rhfh').addEventListener('click', () => {
        params.throwType = 'RHFH';
        document.getElementById('rhfh').classList.add('active');
        document.getElementById('rhbh').classList.remove('active');
    });
    
    document.getElementById('runBtn').addEventListener('click', runSimulation);
    
    // Time slider controls
    const timeSlider = document.getElementById('timeSlider');
    const playBtn = document.getElementById('playBtn');
    
    timeSlider.addEventListener('input', e => {
        if (history) {
            currentFrame = parseInt(e.target.value);
            drawBehindView(currentFrame);
            drawTopView(currentFrame);
            drawSideView(currentFrame);
            highlightChartPosition(currentFrame);
            updateTimeDisplay();
        }
    });
    
    playBtn.addEventListener('click', () => {
        if (!history) return;
        
        if (isPlaying) {
            stopPlayback();
        } else {
            startPlayback();
        }
    });
    
    function startPlayback() {
        isPlaying = true;
        playBtn.textContent = 'Pause';
        
        playInterval = setInterval(() => {
            if (currentFrame >= history.pos.length - 1) {
                currentFrame = 0;
            } else {
                currentFrame++;
            }
            timeSlider.value = currentFrame;
            drawBehindView(currentFrame);
            drawTopView(currentFrame);
            drawSideView(currentFrame);
            highlightChartPosition(currentFrame);
            updateTimeDisplay();
        }, 50); // 20 fps
    }
    
    function stopPlayback() {
        isPlaying = false;
        playBtn.textContent = 'Play';
        if (playInterval) {
            clearInterval(playInterval);
            playInterval = null;
        }
    }
    
    function updateTimeDisplay() {
        if (history) {
            const time = history.time[currentFrame];
            document.getElementById('timeDisplay').textContent = time.toFixed(2) + ' s';
        }
    }
    
    // ============================================================
    // PHYSICS SIMULATION
    // ============================================================
    
    function runSimulation() {
        stopPlayback();
        
        // Release parameters
        const v0 = params.velocity;
        const theta = params.angle * Math.PI / 180;  // Release angle (up/down)
        const hyzer = params.hyzer * Math.PI / 180;  // Hyzer angle (left/right tilt)
        const alpha = params.nose * Math.PI / 180;   // Nose angle
        const r = params.spin * 2 * Math.PI / 60;    // Spin rate (rad/s)
        const windSpeed = params.wind;
        const stability = params.stability;          // Disc stability (-3 to +3)
        const isRHBH = params.throwType === 'RHBH';
        
        // Physical constants from Immonen (2021) Section 2.1
        const m = 0.175;      // Disc mass (kg)
        const rho_a = 1.225;  // Air density (kg/m³)
        const g = 9.81;       // Gravitational acceleration (m/s²)
        const d = 0.21;       // Disc diameter (m)
        
        // Aerodynamic areas
        const AX = Math.PI * (d/2) * (d/2);
        const AZ = AX;
        
        // Base aerodynamic coefficients
        const cd_base = 0.32;
        const cl_base = 0.18;
        
        // Moment of inertia
        const IX = 0.0018;  // kg⋅m² about spin axis
        
        // Initial state
        let pos = [0, 0, 1.5];  // [x, y, z] position (m)
        
        // Initial velocity with hyzer angle component
        let vel = [
            v0 * Math.cos(theta) * Math.cos(hyzer),  // Forward
            v0 * Math.cos(theta) * Math.sin(hyzer),  // Lateral (from hyzer)
            v0 * Math.sin(theta)                      // Vertical
        ];
        
        // Initial disc orientation
        // phi = roll about X-axis (spin-induced roll)
        // psi = tilt about Y-axis (hyzer angle)
        let phi = 0;           // Roll angle (develops during flight)
        let psi = hyzer;       // Initial hyzer/anhyzer tilt
        
        const dt = 0.01;
        const maxTime = 15;
        
        history = {
            pos: [],
            vel: [],
            roll: [],
            time: []
        };
        
        for (let t = 0; t < maxTime; t += dt) {
            // Store current state
            history.pos.push([...pos]);
            history.vel.push([...vel]);
            history.roll.push(phi);
            history.time.push(t);
            
            // Check if disc has hit ground
            if (pos[2] <= 0) break;
            
            // Calculate velocity magnitude
            const vMag = Math.sqrt(vel[0]*vel[0] + vel[1]*vel[1] + vel[2]*vel[2]);
            if (vMag < 0.1 || isNaN(vMag)) break;
            
            // Dynamic angle of attack (affected by nose angle and flight path)
            const flight_path_angle = Math.atan2(vel[2], Math.sqrt(vel[0]*vel[0] + vel[1]*vel[1]));
            const effective_aoa = alpha - flight_path_angle;
            
            // Modify coefficients based on angle of attack and disc tilt
            const cd = cd_base * (1 + 0.3 * Math.abs(effective_aoa) + 0.2 * Math.abs(psi));
            const cl = cl_base * (1 + 2.0 * effective_aoa); // Lift increases with positive AoA
            
            // Drag force
            const Fd = 0.5 * rho_a * vMag * vMag * cd * AZ;
            const drag_x = -Fd * (vel[0] / vMag) / m;
            const drag_y = -Fd * (vel[1] / vMag) / m;
            const drag_z = -Fd * (vel[2] / vMag) / m;
            
            // Lift force (perpendicular to velocity, affected by disc tilt)
            const Fl = 0.5 * rho_a * vMag * vMag * cl * AX;
            const vel_xz_mag = Math.sqrt(vel[0]*vel[0] + vel[2]*vel[2]);
            let lift_x = 0, lift_y = 0, lift_z = 0;
            
            if (vel_xz_mag > 0.01) {
                // Lift direction modified by disc tilt (psi)
                lift_x = -Fl * (vel[2] / vel_xz_mag) * Math.cos(psi) / m;
                lift_y = Fl * Math.sin(psi) / m;  // Lateral component from tilt
                lift_z = Fl * (vel[0] / vel_xz_mag) * Math.cos(psi) / m;
            }
            
            // Magnus effect (depends on spin and velocity)
            const spinDirection = isRHBH ? 1 : -1;
            const magnus_coeff = 0.0015;
            const F_magnus = spinDirection * magnus_coeff * r * vMag * rho_a * AX;
            const magnus_y = F_magnus / m;
            
            // High-speed turn vs low-speed fade (disc stability)
            // Understable discs (stability < 0) turn more at high speed
            // Overstable discs (stability > 0) fade more at low speed
            const speed_factor = vMag / v0;  // Current speed relative to release
            
            // Turn effect (high speed) - happens early in flight
            // Negative stability = more turn (banks right for RHBH)
            // Turn strength decreases as disc slows
            const turn_threshold = 0.7; // Turn active above 70% of initial speed
            let turn_y = 0;
            if (speed_factor > turn_threshold) {
                const turn_intensity = (speed_factor - turn_threshold) / (1 - turn_threshold);
                const turn_coeff = -stability * 0.003 * turn_intensity * turn_intensity;
                turn_y = turn_coeff * r * vMag / m;
            }
            
            // Fade effect (low speed) - happens late in flight
            // Positive stability = more fade (banks left for RHBH)
            // Fade strength increases as disc slows
            const fade_threshold = 0.6; // Fade active below 60% of initial speed
            let fade_y = 0;
            if (speed_factor < fade_threshold) {
                const fade_intensity = (fade_threshold - speed_factor) / fade_threshold;
                // Base fade increases with stability, all discs fade some amount
                const base_fade = 0.5; // Even neutral discs have slight fade
                const fade_coeff = (base_fade + stability) * 0.002 * fade_intensity;
                fade_y = spinDirection * fade_coeff * r * vMag / m;
            }
            
            // Gyroscopic precession (roll development)
            // Hyzer flips: understable disc on hyzer angle will flip to flat then anhyzer
            // Flex shots: overstable disc on anhyzer will flex back
            const precession_rate = spinDirection * 0.5 * Math.exp(-t * 0.4);
            
            // Stability affects how disc orientation changes during flight
            // Understable: fights to flatten out faster (hyzer flip behavior)
            // Overstable: resists flattening, maintains tilt
            const tilt_change_rate = -stability * 0.25 * Math.sin(psi) * speed_factor;
            
            // Hyzer flip: understable disc actively flips the angle
            if (stability < -0.5 && psi < -0.1 && speed_factor > 0.6) {
                // Flip up effect - understable disc wants to flip to anhyzer
                const flip_rate = -stability * 0.4 * speed_factor;
                tilt_rate = flip_rate;
            } 
            // Flex shot: overstable disc fights back against anhyzer
            else if (stability > 0.5 && psi > 0.1 && speed_factor > 0.5) {
                // Flex back effect - overstable disc wants to flatten/hyzer
                const flex_rate = -stability * 0.35 * speed_factor;
                tilt_rate = flex_rate;
            }
            else {
                tilt_rate = tilt_change_rate;
            }
            
            // Wind effect
            const wind_x = windSpeed * 0.15;
            
            // Update velocities
            vel[0] += (drag_x + lift_x + wind_x) * dt;
            vel[1] += (drag_y + lift_y + magnus_y + turn_y + fade_y) * dt;
            vel[2] += (drag_z + lift_z - g) * dt;
            
            // Check for NaN
            if (isNaN(vel[0]) || isNaN(vel[1]) || isNaN(vel[2])) break;
            
            // Update position
            pos[0] += vel[0] * dt;
            pos[1] += vel[1] * dt;
            pos[2] += vel[2] * dt;
            
            // Clamp to ground
            if (pos[2] < 0) pos[2] = 0;
            
            // Update disc orientation
            phi += precession_rate * dt;
            psi += tilt_rate * dt;
            
            // Limit tilt angles
            psi = Math.max(-Math.PI/2, Math.min(Math.PI/2, psi));
        }
        
        // Setup time slider
        timeSlider.max = history.pos.length - 1;
        timeSlider.value = 0;
        currentFrame = 0;
        document.getElementById('timeSliderContainer').classList.add('active');
        
        // Draw results
        drawBehindView(0);
        drawTopView(0);
        drawSideView(0);
        drawTrajectoryChart();
        drawRollChart();
        updateStats();
        updateTimeDisplay();
        
        // Auto-start playback
        setTimeout(() => startPlayback(), 500);
    }
    
    // ============================================================
    // VISUALIZATION
    // ============================================================
    
    function drawBehindView(frameIdx) {
        if (!history || frameIdx >= history.pos.length) return;
        
        const W = behindCanvas.width / dpr;
        const H = behindCanvas.height / dpr;
        
        behindCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        behindCtx.clearRect(0, 0, W, H);
        
        // Dark background
        behindCtx.fillStyle = '#0a0d12';
        behindCtx.fillRect(0, 0, W, H);
        
        // Title
        behindCtx.fillStyle = '#e8edf5';
        behindCtx.font = '16px Outfit';
        behindCtx.textAlign = 'center';
        behindCtx.fillText('Disc Flight - View from Behind', W/2, 35);
        
        const pos = history.pos[frameIdx];
        const vel = history.vel[frameIdx];
        const roll = history.roll[frameIdx];
        const time = history.time[frameIdx];
        
        const vMag = Math.sqrt(vel[0]*vel[0] + vel[1]*vel[1] + vel[2]*vel[2]);
        
        // Disc center position
        const centerX = W / 2;
        const centerY = H * 0.55;
        const discRadius = 60;
        
        // Velocity indicator (V∞)
        behindCtx.fillStyle = '#e8edf5';
        behindCtx.font = '18px JetBrains Mono';
        behindCtx.textAlign = 'center';
        behindCtx.fillText('V∞', centerX, 80);
        
        // Velocity vector arrows
        const arrowY = 100;
        const arrowSpacing = 35;
        behindCtx.strokeStyle = '#8a9bb0';
        behindCtx.lineWidth = 2;
        for (let i = 0; i < 6; i++) {
            const x = centerX - arrowSpacing * 2.5 + i * arrowSpacing;
            behindCtx.beginPath();
            behindCtx.moveTo(x - 12, arrowY);
            behindCtx.lineTo(x + 12, arrowY);
            behindCtx.stroke();
            drawArrowHead(behindCtx, x + 12, arrowY, 0, 6, '#8a9bb0');
        }
        
        // Draw advancing (left) vortex
        const numVortexRings = 8;
        for (let i = 0; i < numVortexRings; i++) {
            const age = i * 0.15;
            const vortexX = centerX - discRadius * 1.2 - i * 25;
            const vortexY = centerY + Math.sin(time * 4 + i * 0.8) * 15;
            const vortexRadius = 12 + i * 4;
            const alpha = (1 - age) * 0.6;
            
            // Multiple spiral rings
            for (let j = 0; j < 3; j++) {
                const offset = j * 0.3;
                behindCtx.strokeStyle = `rgba(231, 76, 60, ${alpha * (1 - j * 0.3)})`;
                behindCtx.lineWidth = 2;
                behindCtx.beginPath();
                behindCtx.arc(vortexX, vortexY + offset * 5, vortexRadius + offset * 3, 
                             time * 2 + i * 0.5, time * 2 + i * 0.5 + Math.PI * 1.7);
                behindCtx.stroke();
            }
        }
        
        // Draw trailing (right) vortex
        for (let i = 0; i < numVortexRings; i++) {
            const age = i * 0.15;
            const vortexX = centerX + discRadius * 1.2 + i * 25;
            const vortexY = centerY - Math.sin(time * 4 + i * 0.8) * 15;
            const vortexRadius = 12 + i * 4;
            const alpha = (1 - age) * 0.6;
            
            // Multiple spiral rings
            for (let j = 0; j < 3; j++) {
                const offset = j * 0.3;
                behindCtx.strokeStyle = `rgba(88, 214, 141, ${alpha * (1 - j * 0.3)})`;
                behindCtx.lineWidth = 2;
                behindCtx.beginPath();
                behindCtx.arc(vortexX, vortexY - offset * 5, vortexRadius + offset * 3,
                             -time * 2 - i * 0.5, -time * 2 - i * 0.5 - Math.PI * 1.7);
                behindCtx.stroke();
            }
        }
        
        // Draw disc (ellipse from behind)
        behindCtx.save();
        behindCtx.translate(centerX, centerY);
        behindCtx.rotate(roll * 0.2);
        
        // Disc body
        behindCtx.fillStyle = '#3498db';
        behindCtx.strokeStyle = '#2980b9';
        behindCtx.lineWidth = 4;
        behindCtx.beginPath();
        behindCtx.ellipse(0, 0, discRadius, discRadius * 0.25, 0, 0, Math.PI * 2);
        behindCtx.fill();
        behindCtx.stroke();
        
        // Center hub with rotation indicator
        behindCtx.fillStyle = '#f4d03f';
        behindCtx.font = '14px JetBrains Mono';
        behindCtx.textAlign = 'center';
        behindCtx.textBaseline = 'middle';
        behindCtx.fillText('ω', 0, 0);
        
        behindCtx.restore();
        
        // Vortex labels
        behindCtx.font = '12px Outfit';
        behindCtx.fillStyle = '#e74c3c';
        behindCtx.textAlign = 'center';
        behindCtx.fillText('advancing', centerX - discRadius * 2, centerY + 90);
        behindCtx.fillText('edge vortex', centerX - discRadius * 2, centerY + 105);
        
        behindCtx.fillStyle = '#58d68d';
        behindCtx.fillText('trailing', centerX + discRadius * 2, centerY + 90);
        behindCtx.fillText('edge vortex', centerX + discRadius * 2, centerY + 105);
        
        // Ground line
        behindCtx.strokeStyle = '#5a6a7a';
        behindCtx.lineWidth = 1;
        behindCtx.setLineDash([5, 5]);
        behindCtx.beginPath();
        behindCtx.moveTo(50, H - 60);
        behindCtx.lineTo(W - 50, H - 60);
        behindCtx.stroke();
        behindCtx.setLineDash([]);
        
        // APEX indicator (right side)
        if (Math.abs(vel[2]) < 1.0 && pos[2] > 3) {
            behindCtx.fillStyle = '#f4d03f';
            behindCtx.font = 'bold 20px Outfit';
            behindCtx.textAlign = 'right';
            behindCtx.fillText('APEX', W - 40, 80);
        }
        
        // Info panel (left side)
        behindCtx.fillStyle = 'rgba(17, 24, 32, 0.8)';
        behindCtx.fillRect(10, 70, 140, 85);
        
        behindCtx.fillStyle = '#e8edf5';
        behindCtx.font = '11px JetBrains Mono';
        behindCtx.textAlign = 'left';
        behindCtx.fillText(`Time: ${time.toFixed(2)}s`, 20, 90);
        behindCtx.fillText(`Height: ${pos[2].toFixed(1)}m`, 20, 105);
        behindCtx.fillText(`Speed: ${vMag.toFixed(1)} m/s`, 20, 120);
        behindCtx.fillText(`α: ${(params.nose).toFixed(1)}°`, 20, 135);
        behindCtx.fillText(`Roll: ${(roll * 180 / Math.PI).toFixed(1)}°`, 20, 150);
        
        // Bottom caption
        behindCtx.fillStyle = '#8a9bb0';
        behindCtx.font = '12px Outfit';
        behindCtx.textAlign = 'center';
        const apexNote = Math.abs(vel[2]) < 1.0 && pos[2] > 3 ? 
                        'Apex: α ≈ 0 → Transitioning' : 
                        'Wingtip vortices shed due to lift generation';
        behindCtx.fillText(apexNote, W/2, H - 30);
    }
    
    function drawTopView(frameIdx) {
        if (!history || frameIdx >= history.pos.length) return;
        
        const W = topCanvas.width / dpr;
        const H = topCanvas.height / dpr;
        
        topCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        topCtx.clearRect(0, 0, W, H);
        
        // Background
        topCtx.fillStyle = '#0a0d12';
        topCtx.fillRect(0, 0, W, H);
        
        // Find max extents for scaling
        let maxX = 0, maxY = 0;
        for (let i = 0; i < history.pos.length; i++) {
            maxX = Math.max(maxX, Math.abs(history.pos[i][0]));
            maxY = Math.max(maxY, Math.abs(history.pos[i][1]));
        }
        const scale = Math.min((W - 80) / (2 * maxX), (H - 80) / (2 * maxY));
        const originX = 40;
        const originY = H / 2;
        
        // Draw full trajectory
        topCtx.strokeStyle = 'rgba(0, 212, 255, 0.3)';
        topCtx.lineWidth = 2;
        topCtx.beginPath();
        for (let i = 0; i < history.pos.length; i++) {
            const x = originX + history.pos[i][0] * scale;
            const y = originY - history.pos[i][1] * scale;
            if (i === 0) topCtx.moveTo(x, y);
            else topCtx.lineTo(x, y);
        }
        topCtx.stroke();
        
        // Highlight current position
        topCtx.strokeStyle = '#00d4ff';
        topCtx.lineWidth = 3;
        topCtx.beginPath();
        for (let i = 0; i <= Math.min(frameIdx, history.pos.length - 1); i++) {
            const x = originX + history.pos[i][0] * scale;
            const y = originY - history.pos[i][1] * scale;
            if (i === 0) topCtx.moveTo(x, y);
            else topCtx.lineTo(x, y);
        }
        topCtx.stroke();
        
        // Current disc position
        const pos = history.pos[frameIdx];
        const x = originX + pos[0] * scale;
        const y = originY - pos[1] * scale;
        
        topCtx.fillStyle = '#3498db';
        topCtx.beginPath();
        topCtx.arc(x, y, 6, 0, Math.PI * 2);
        topCtx.fill();
        
        // Axes
        topCtx.strokeStyle = '#5a6a7a';
        topCtx.lineWidth = 1;
        topCtx.setLineDash([3, 3]);
        topCtx.beginPath();
        topCtx.moveTo(originX, 20);
        topCtx.lineTo(originX, H - 20);
        topCtx.stroke();
        topCtx.setLineDash([]);
        
        // Labels
        topCtx.fillStyle = '#8a9bb0';
        topCtx.font = '11px JetBrains Mono';
        topCtx.textAlign = 'center';
        topCtx.fillText('Forward (X) →', W / 2, H - 10);
        topCtx.save();
        topCtx.translate(15, H / 2);
        topCtx.rotate(-Math.PI / 2);
        topCtx.fillText('← Lateral (Y)', 0, 0);
        topCtx.restore();
        
        // Distance marker
        topCtx.fillText(`${pos[0].toFixed(1)}m`, x, y - 15);
    }
    
    function drawSideView(frameIdx) {
        if (!history || frameIdx >= history.pos.length) return;
        
        const W = sideCanvas.width / dpr;
        const H = sideCanvas.height / dpr;
        
        sideCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        sideCtx.clearRect(0, 0, W, H);
        
        // Background
        sideCtx.fillStyle = '#0a0d12';
        sideCtx.fillRect(0, 0, W, H);
        
        // Find max extents
        let maxX = 0, maxZ = 0;
        for (let i = 0; i < history.pos.length; i++) {
            maxX = Math.max(maxX, history.pos[i][0]);
            maxZ = Math.max(maxZ, history.pos[i][2]);
        }
        const scale = Math.min((W - 80) / maxX, (H - 80) / maxZ);
        const originX = 40;
        const originY = H - 40;
        
        // Draw ground
        sideCtx.strokeStyle = '#5a6a7a';
        sideCtx.lineWidth = 2;
        sideCtx.beginPath();
        sideCtx.moveTo(originX, originY);
        sideCtx.lineTo(W - 20, originY);
        sideCtx.stroke();
        
        // Draw full trajectory
        sideCtx.strokeStyle = 'rgba(0, 212, 255, 0.3)';
        sideCtx.lineWidth = 2;
        sideCtx.beginPath();
        for (let i = 0; i < history.pos.length; i++) {
            const x = originX + history.pos[i][0] * scale;
            const y = originY - history.pos[i][2] * scale;
            if (i === 0) sideCtx.moveTo(x, y);
            else sideCtx.lineTo(x, y);
        }
        sideCtx.stroke();
        
        // Highlight current position
        sideCtx.strokeStyle = '#00d4ff';
        sideCtx.lineWidth = 3;
        sideCtx.beginPath();
        for (let i = 0; i <= Math.min(frameIdx, history.pos.length - 1); i++) {
            const x = originX + history.pos[i][0] * scale;
            const y = originY - history.pos[i][2] * scale;
            if (i === 0) sideCtx.moveTo(x, y);
            else sideCtx.lineTo(x, y);
        }
        sideCtx.stroke();
        
        // Current disc position
        const pos = history.pos[frameIdx];
        const x = originX + pos[0] * scale;
        const y = originY - pos[2] * scale;
        
        sideCtx.fillStyle = '#3498db';
        sideCtx.beginPath();
        sideCtx.arc(x, y, 6, 0, Math.PI * 2);
        sideCtx.fill();
        
        // Labels
        sideCtx.fillStyle = '#8a9bb0';
        sideCtx.font = '11px JetBrains Mono';
        sideCtx.textAlign = 'center';
        sideCtx.fillText('Distance (X) →', W / 2, H - 10);
        sideCtx.save();
        sideCtx.translate(15, H / 2);
        sideCtx.rotate(-Math.PI / 2);
        sideCtx.fillText('Height (Z) ↑', 0, 0);
        sideCtx.restore();
        
        // Height marker
        sideCtx.fillText(`${pos[2].toFixed(1)}m`, x, y - 15);
    }
    
    function drawArrowHead(ctx, x, y, angle, size, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x - size * Math.cos(angle - Math.PI/6), y - size * Math.sin(angle - Math.PI/6));
        ctx.lineTo(x - size * Math.cos(angle + Math.PI/6), y - size * Math.sin(angle + Math.PI/6));
        ctx.closePath();
        ctx.fill();
    }
    
    function drawFrame(frameIdx) {
        if (!history || frameIdx >= history.pos.length) return;
        
        const W = behindCanvas.width / dpr;
        const H = behindCanvas.height / dpr;
        
        behindCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        behindCtx.clearRect(0, 0, W, H);
        
        // Background
        behindCtx.fillStyle = '#1a2230';
        behindCtx.fillRect(0, 0, W, H);
        
        // Title
        behindCtx.fillStyle = '#00d4ff';
        behindCtx.font = 'bold 16px JetBrains Mono';
        behindCtx.textAlign = 'center';
        behindCtx.fillText('Free Body Diagram', W/2, 30);
        
        const pos = history.pos[frameIdx];
        const vel = history.vel[frameIdx];
        const roll = history.roll[frameIdx];
        const time = history.time[frameIdx];
        
        // Physical constants (from simulation)
        const m = 0.175;
        const rho_a = 1.225;
        const g = 9.81;
        const d = 0.21;
        const AX = Math.PI * (d/2) * (d/2);
        const cd = 0.32;
        const cl = 0.18;
        
        // Calculate forces
        const vMag = Math.sqrt(vel[0]*vel[0] + vel[1]*vel[1] + vel[2]*vel[2]);
        
        // Drag force
        const Fd = 0.5 * rho_a * vMag * vMag * cd * AX;
        
        // Lift force
        const Fl = 0.5 * rho_a * vMag * vMag * cl * AX;
        
        // Weight
        const W_force = m * g;
        
        // Magnus force (lateral)
        const isRHBH = params.throwType === 'RHBH';
        const r = params.spin * 2 * Math.PI / 60;
        const spinDirection = isRHBH ? 1 : -1;
        const magnus_coeff = 0.0015;
        const F_magnus = Math.abs(spinDirection * magnus_coeff * r * vMag * rho_a * AX);
        
        // Center of diagram
        const centerX = W / 2;
        const centerY = H / 2;
        const discRadius = 40;
        
        // Draw coordinate system axes
        const axisLen = 60;
        
        // X-axis (forward, along flight path)
        behindCtx.strokeStyle = '#ff6b35';
        behindCtx.lineWidth = 2;
        behindCtx.beginPath();
        behindCtx.moveTo(centerX, centerY);
        behindCtx.lineTo(centerX + axisLen, centerY);
        behindCtx.stroke();
        drawArrowHead(behindCtx, centerX + axisLen, centerY, 0, 8, '#ff6b35');
        behindCtx.fillStyle = '#ff6b35';
        behindCtx.font = '14px JetBrains Mono';
        behindCtx.textAlign = 'left';
        behindCtx.fillText('X (fwd)', centerX + axisLen + 10, centerY + 5);
        
        // Y-axis (lateral)
        behindCtx.strokeStyle = '#58d68d';
        behindCtx.lineWidth = 2;
        behindCtx.beginPath();
        behindCtx.moveTo(centerX, centerY);
        behindCtx.lineTo(centerX, centerY - axisLen);
        behindCtx.stroke();
        drawArrowHead(behindCtx, centerX, centerY - axisLen, -Math.PI/2, 8, '#58d68d');
        behindCtx.fillStyle = '#58d68d';
        behindCtx.textAlign = 'center';
        behindCtx.fillText('Y (lat)', centerX, centerY - axisLen - 10);
        
        // Z-axis (vertical)
        behindCtx.strokeStyle = '#f4d03f';
        behindCtx.lineWidth = 2;
        behindCtx.beginPath();
        behindCtx.moveTo(centerX, centerY);
        behindCtx.lineTo(centerX - axisLen * 0.5, centerY + axisLen * 0.866);
        behindCtx.stroke();
        drawArrowHead(behindCtx, centerX - axisLen * 0.5, centerY + axisLen * 0.866, Math.PI * 2/3, 8, '#f4d03f');
        behindCtx.fillStyle = '#f4d03f';
        behindCtx.textAlign = 'right';
        behindCtx.fillText('Z (up)', centerX - axisLen * 0.5 - 10, centerY + axisLen * 0.866);
        
        // Draw disc (side view)
        behindCtx.save();
        behindCtx.translate(centerX, centerY);
        behindCtx.rotate(roll * 0.3); // Show roll angle (reduced for visibility)
        
        behindCtx.fillStyle = '#00d4ff';
        behindCtx.strokeStyle = '#0099cc';
        behindCtx.lineWidth = 3;
        behindCtx.beginPath();
        behindCtx.ellipse(0, 0, discRadius, discRadius * 0.25, 0, 0, Math.PI * 2);
        behindCtx.fill();
        behindCtx.stroke();
        
        // Center of mass
        behindCtx.fillStyle = '#fff';
        behindCtx.beginPath();
        behindCtx.arc(0, 0, 3, 0, Math.PI * 2);
        behindCtx.fill();
        
        behindCtx.restore();
        
        // Force scale factor (for visualization)
        const forceScale = 50;
        
        // Draw Drag force (opposite to velocity direction)
        const vel_xz_mag = Math.sqrt(vel[0]*vel[0] + vel[2]*vel[2]);
        if (vel_xz_mag > 0.1) {
            const drag_angle = Math.atan2(-vel[2], -vel[0]);
            const drag_len = Math.min(Fd * forceScale, 80);
            
            behindCtx.strokeStyle = '#e74c3c';
            behindCtx.lineWidth = 3;
            behindCtx.beginPath();
            behindCtx.moveTo(centerX, centerY);
            behindCtx.lineTo(centerX + drag_len * Math.cos(drag_angle), 
                           centerY + drag_len * Math.sin(drag_angle));
            behindCtx.stroke();
            drawArrowHead(behindCtx, 
                         centerX + drag_len * Math.cos(drag_angle),
                         centerY + drag_len * Math.sin(drag_angle),
                         drag_angle, 10, '#e74c3c');
            
            behindCtx.fillStyle = '#e74c3c';
            behindCtx.font = '12px JetBrains Mono';
            behindCtx.textAlign = 'center';
            behindCtx.fillText(`F_d=${Fd.toFixed(2)}N`, 
                             centerX + (drag_len + 30) * Math.cos(drag_angle),
                             centerY + (drag_len + 30) * Math.sin(drag_angle));
        }
        
        // Draw Lift force (perpendicular to velocity, upward)
        if (vel_xz_mag > 0.1) {
            const lift_angle = Math.atan2(-vel[0], vel[2]);
            const lift_len = Math.min(Fl * forceScale, 80);
            
            behindCtx.strokeStyle = '#58d68d';
            behindCtx.lineWidth = 3;
            behindCtx.beginPath();
            behindCtx.moveTo(centerX, centerY);
            behindCtx.lineTo(centerX + lift_len * Math.cos(lift_angle),
                           centerY + lift_len * Math.sin(lift_angle));
            behindCtx.stroke();
            drawArrowHead(behindCtx,
                         centerX + lift_len * Math.cos(lift_angle),
                         centerY + lift_len * Math.sin(lift_angle),
                         lift_angle, 10, '#58d68d');
            
            behindCtx.fillStyle = '#58d68d';
            behindCtx.font = '12px JetBrains Mono';
            behindCtx.textAlign = 'center';
            behindCtx.fillText(`F_l=${Fl.toFixed(2)}N`,
                             centerX + (lift_len + 30) * Math.cos(lift_angle),
                             centerY + (lift_len + 30) * Math.sin(lift_angle));
        }
        
        // Draw Weight (downward)
        const weight_len = Math.min(W_force * forceScale / 3, 60);
        behindCtx.strokeStyle = '#f4d03f';
        behindCtx.lineWidth = 3;
        behindCtx.beginPath();
        behindCtx.moveTo(centerX, centerY);
        behindCtx.lineTo(centerX, centerY + weight_len);
        behindCtx.stroke();
        drawArrowHead(behindCtx, centerX, centerY + weight_len, Math.PI/2, 10, '#f4d03f');
        
        behindCtx.fillStyle = '#f4d03f';
        behindCtx.font = '12px JetBrains Mono';
        behindCtx.textAlign = 'center';
        behindCtx.fillText(`W=${W_force.toFixed(2)}N`, centerX - 40, centerY + weight_len);
        
        // Draw Magnus force (lateral)
        if (F_magnus > 0.01) {
            const magnus_len = Math.min(F_magnus * forceScale * 3, 60);
            const magnus_dir = spinDirection;
            
            behindCtx.strokeStyle = '#9b59b6';
            behindCtx.lineWidth = 3;
            behindCtx.beginPath();
            behindCtx.moveTo(centerX, centerY);
            behindCtx.lineTo(centerX - magnus_len * magnus_dir, centerY);
            behindCtx.stroke();
            drawArrowHead(behindCtx, centerX - magnus_len * magnus_dir, centerY, 
                         magnus_dir > 0 ? Math.PI : 0, 10, '#9b59b6');
            
            behindCtx.fillStyle = '#9b59b6';
            behindCtx.font = '12px JetBrains Mono';
            behindCtx.textAlign = 'center';
            behindCtx.fillText(`F_m=${F_magnus.toFixed(2)}N`,
                             centerX - (magnus_len + 35) * magnus_dir,
                             centerY - 15);
        }
        
        // Draw spin vector (rotation about X-axis)
        const spin_radius = discRadius + 15;
        behindCtx.strokeStyle = '#00d4ff';
        behindCtx.lineWidth = 2;
        behindCtx.setLineDash([5, 5]);
        behindCtx.beginPath();
        behindCtx.arc(centerX, centerY, spin_radius, -Math.PI/4, Math.PI * 5/4);
        behindCtx.stroke();
        behindCtx.setLineDash([]);
        
        // Arrow showing spin direction
        const spin_angle = time * 3; // Animated
        const arrow_x = centerX + spin_radius * Math.cos(spin_angle);
        const arrow_y = centerY + spin_radius * Math.sin(spin_angle);
        drawArrowHead(behindCtx, arrow_x, arrow_y, spin_angle + Math.PI/2, 8, '#00d4ff');
        
        behindCtx.fillStyle = '#00d4ff';
        behindCtx.font = '12px JetBrains Mono';
        behindCtx.textAlign = 'center';
        behindCtx.fillText(`ω=${(r * 60 / (2*Math.PI)).toFixed(0)} rpm`, centerX, centerY - spin_radius - 15);
        
        // Draw roll angle indicator
        const roll_indicator_radius = discRadius + 35;
        behindCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        behindCtx.lineWidth = 1;
        behindCtx.beginPath();
        behindCtx.arc(centerX, centerY, roll_indicator_radius, 0, Math.PI * 2);
        behindCtx.stroke();
        
        behindCtx.strokeStyle = '#ff6b35';
        behindCtx.lineWidth = 2;
        behindCtx.beginPath();
        behindCtx.moveTo(centerX, centerY);
        behindCtx.lineTo(centerX + roll_indicator_radius * Math.cos(roll * 0.3 - Math.PI/2),
                       centerY + roll_indicator_radius * Math.sin(roll * 0.3 - Math.PI/2));
        behindCtx.stroke();
        
        // Info panel
        behindCtx.fillStyle = '#e8edf5';
        behindCtx.font = '11px JetBrains Mono';
        behindCtx.textAlign = 'left';
        const infoX = 10;
        let infoY = H - 120;
        
        behindCtx.fillText(`Velocity: ${vMag.toFixed(2)} m/s`, infoX, infoY);
        infoY += 18;
        behindCtx.fillText(`Roll: ${(roll * 180 / Math.PI).toFixed(1)}°`, infoX, infoY);
        infoY += 18;
        behindCtx.fillText(`Height: ${pos[2].toFixed(2)} m`, infoX, infoY);
        infoY += 18;
        behindCtx.fillText(`Lateral: ${pos[1].toFixed(2)} m`, infoX, infoY);
        infoY += 18;
        behindCtx.fillText(`Distance: ${pos[0].toFixed(2)} m`, infoX, infoY);
        infoY += 18;
        behindCtx.fillText(`Time: ${time.toFixed(2)} s`, infoX, infoY);
        
        // Legend
        behindCtx.font = '10px JetBrains Mono';
        behindCtx.textAlign = 'right';
        let legendY = H - 100;
        const legendX = W - 10;
        
        behindCtx.fillStyle = '#e74c3c';
        behindCtx.fillText('● Drag', legendX, legendY);
        legendY += 15;
        
        behindCtx.fillStyle = '#58d68d';
        behindCtx.fillText('● Lift', legendX, legendY);
        legendY += 15;
        
        behindCtx.fillStyle = '#f4d03f';
        behindCtx.fillText('● Weight', legendX, legendY);
        legendY += 15;
        
        behindCtx.fillStyle = '#9b59b6';
        behindCtx.fillText('● Magnus', legendX, legendY);
        legendY += 15;
        
        behindCtx.fillStyle = '#00d4ff';
        behindCtx.fillText('● Spin', legendX, legendY);
    }
    
    function drawArrowHead(ctx, x, y, angle, size, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x - size * Math.cos(angle - Math.PI/6), y - size * Math.sin(angle - Math.PI/6));
        ctx.lineTo(x - size * Math.cos(angle + Math.PI/6), y - size * Math.sin(angle + Math.PI/6));
        ctx.closePath();
        ctx.fill();
    }
    
    function drawTrajectoryChart() {
        if (!history) return;
        
        const W = trajectoryCanvas.width / dpr;
        const H = trajectoryCanvas.height / dpr;
        
        trajCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        trajCtx.clearRect(0, 0, W, H);
        
        const padding = 30;
        const plotW = W - padding * 2;
        const plotH = H - padding * 2;
        
        let maxX = 0, maxY = 0;
        for (const p of history.pos) {
            maxX = Math.max(maxX, Math.abs(p[0]));
            maxY = Math.max(maxY, Math.abs(p[1]));
        }
        
        const scaleX = plotW / (maxX * 1.2);
        const scaleY = plotH / (maxY * 2.4);
        
        // Grid
        trajCtx.strokeStyle = '#2a3444';
        trajCtx.lineWidth = 1;
        trajCtx.beginPath();
        trajCtx.moveTo(padding, H/2);
        trajCtx.lineTo(W - padding, H/2);
        trajCtx.moveTo(padding, padding);
        trajCtx.lineTo(padding, H - padding);
        trajCtx.stroke();
        
        // Labels
        trajCtx.fillStyle = '#5a6a7a';
        trajCtx.font = '10px JetBrains Mono';
        trajCtx.textAlign = 'center';
        trajCtx.fillText('Distance (m)', W/2, H - 8);
        trajCtx.save();
        trajCtx.translate(12, H/2);
        trajCtx.rotate(-Math.PI/2);
        trajCtx.fillText('Lateral (m)', 0, 0);
        trajCtx.restore();
        
        // Path
        trajCtx.beginPath();
        trajCtx.strokeStyle = '#00d4ff';
        trajCtx.lineWidth = 2;
        
        for (let i = 0; i < history.pos.length; i++) {
            const p = history.pos[i];
            const x = padding + p[0] * scaleX;
            const y = H/2 - p[1] * scaleY;
            if (i === 0) trajCtx.moveTo(x, y);
            else trajCtx.lineTo(x, y);
        }
        trajCtx.stroke();
        
        // Landing
        const last = history.pos[history.pos.length - 1];
        trajCtx.fillStyle = '#ff6b35';
        trajCtx.beginPath();
        trajCtx.arc(padding + last[0] * scaleX, H/2 - last[1] * scaleY, 5, 0, Math.PI * 2);
        trajCtx.fill();
        
        trajectoryCanvas.chartData = { padding, scaleX, scaleY, H };
    }
    
    function drawRollChart() {
        if (!history) return;
        
        const W = rollCanvas.width / dpr;
        const H = rollCanvas.height / dpr;
        
        rollCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        rollCtx.clearRect(0, 0, W, H);
        
        const padding = 30;
        const plotW = W - padding * 2;
        const plotH = H - padding * 2;
        
        const maxT = history.time[history.time.length - 1];
        let maxRoll = 0;
        for (const r of history.roll) {
            maxRoll = Math.max(maxRoll, Math.abs(r));
        }
        maxRoll = Math.max(maxRoll * 180 / Math.PI, 30) * 1.2;
        
        const scaleX = plotW / maxT;
        const scaleY = plotH / (maxRoll * 2);
        
        // Grid
        rollCtx.strokeStyle = '#2a3444';
        rollCtx.lineWidth = 1;
        rollCtx.beginPath();
        rollCtx.moveTo(padding, H/2);
        rollCtx.lineTo(W - padding, H/2);
        rollCtx.stroke();
        
        // Labels
        rollCtx.fillStyle = '#5a6a7a';
        rollCtx.font = '10px JetBrains Mono';
        rollCtx.textAlign = 'center';
        rollCtx.fillText('Time (s)', W/2, H - 8);
        
        // Roll curve
        rollCtx.beginPath();
        rollCtx.strokeStyle = '#f4d03f';
        rollCtx.lineWidth = 2;
        
        for (let i = 0; i < history.time.length; i++) {
            const t = history.time[i];
            const rollDeg = history.roll[i] * 180 / Math.PI;
            const x = padding + t * scaleX;
            const y = H/2 - rollDeg * scaleY;
            if (i === 0) rollCtx.moveTo(x, y);
            else rollCtx.lineTo(x, y);
        }
        rollCtx.stroke();
        
        rollCanvas.chartData = { padding, scaleX, scaleY, H };
    }
    
    function highlightChartPosition(frameIdx) {
        drawTrajectoryChart();
        drawRollChart();
        
        if (!history) return;
        
        // Trajectory highlight
        const td = trajectoryCanvas.chartData;
        if (td) {
            const p = history.pos[frameIdx];
            const x = td.padding + p[0] * td.scaleX;
            const y = td.H/2 - p[1] * td.scaleY;
            trajCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            trajCtx.fillStyle = '#fff';
            trajCtx.beginPath();
            trajCtx.arc(x, y, 4, 0, Math.PI * 2);
            trajCtx.fill();
        }
        
        // Roll highlight
        const rd = rollCanvas.chartData;
        if (rd) {
            const t = history.time[frameIdx];
            const rollDeg = history.roll[frameIdx] * 180 / Math.PI;
            const x = rd.padding + t * rd.scaleX;
            const y = rd.H/2 - rollDeg * rd.scaleY;
            rollCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            rollCtx.fillStyle = '#fff';
            rollCtx.beginPath();
            rollCtx.arc(x, y, 4, 0, Math.PI * 2);
            rollCtx.fill();
        }
    }
    
    function updateStats() {
        if (!history) return;
        
        const lastPos = history.pos[history.pos.length - 1];
        const distance = Math.sqrt(lastPos[0]*lastPos[0] + lastPos[1]*lastPos[1]);
        let maxHeight = 0;
        for (const p of history.pos) {
            maxHeight = Math.max(maxHeight, p[2]);
        }
        const flightTime = history.time[history.time.length - 1];
        const finalRoll = history.roll[history.roll.length - 1] * 180 / Math.PI;
        
        document.getElementById('statDistance').innerHTML = distance.toFixed(1) + '<span class="stat-unit">m</span>';
        document.getElementById('statMaxHeight').innerHTML = maxHeight.toFixed(1) + '<span class="stat-unit">m</span>';
        document.getElementById('statFlightTime').innerHTML = flightTime.toFixed(2) + '<span class="stat-unit">s</span>';
        document.getElementById('statFinalRoll').innerHTML = finalRoll.toFixed(1) + '<span class="stat-unit">°</span>';
    }
    
    // Initial state
    ctx.fillStyle = '#1a2230';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#5a6a7a';
    ctx.font = '14px Outfit';
    ctx.textAlign = 'center';
    ctx.fillText('Click "Run Simulation" to begin', canvas.width / dpr / 2, canvas.height / dpr / 2);
    </script>
</body>
</html>
