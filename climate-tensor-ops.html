<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Climate Data Tensor Operations - FTA</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #0a1628 0%, #1a2842 100%);
            color: #e0f2ff;
            line-height: 1.6;
            padding: 2rem;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: rgba(10, 22, 40, 0.8);
            backdrop-filter: blur(10px);
            padding: 3rem;
            border-radius: 12px;
            border: 1px solid rgba(100, 200, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #64c8ff 0%, #a8e6ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #a8d5ff;
            margin-bottom: 2rem;
            font-weight: 300;
        }

        h2 {
            font-size: 1.8rem;
            color: #64c8ff;
            margin-top: 2rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid rgba(100, 200, 255, 0.3);
            padding-bottom: 0.5rem;
        }

        h3 {
            font-size: 1.3rem;
            color: #a8d5ff;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        p {
            margin-bottom: 1rem;
            color: #d0e7ff;
        }

        .tech-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .tech-card {
            background: rgba(100, 200, 255, 0.05);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 8px;
            padding: 1.5rem;
            transition: all 0.3s ease;
        }

        .tech-card:hover {
            background: rgba(100, 200, 255, 0.1);
            border-color: rgba(100, 200, 255, 0.4);
            transform: translateY(-2px);
        }

        .tech-card h3 {
            margin-top: 0;
            font-size: 1.2rem;
        }

        .code-block {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 6px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            overflow-x: auto;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .code-block code {
            color: #a8e6ff;
        }

        .highlight {
            color: #64c8ff;
            font-weight: 600;
        }

        .metric {
            display: inline-block;
            background: rgba(100, 200, 255, 0.1);
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            color: #64c8ff;
            font-weight: 600;
            margin: 0.25rem;
        }

        ul {
            margin: 1rem 0 1rem 2rem;
            color: #d0e7ff;
        }

        li {
            margin-bottom: 0.5rem;
        }

        .diagram {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            padding: 2rem;
            margin: 2rem 0;
            text-align: center;
            font-family: monospace;
            color: #a8d5ff;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 2rem;
            color: #64c8ff;
            text-decoration: none;
            font-size: 1rem;
            transition: color 0.3s ease;
        }

        .back-link:hover {
            color: #a8e6ff;
        }

        .back-link::before {
            content: '‚Üê ';
        }

        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }
            
            .container {
                padding: 1.5rem;
            }
            
            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="/" class="back-link">Back to Home</a>
        
        <h1>Climate Data Tensor Operations</h1>
        <p class="subtitle">GPU-Accelerated Multi-Dimensional Climate Analysis</p>

        <p>
            Climate data naturally exists as high-dimensional tensors: spatial grids (lat, lon), 
            temporal sequences, ensemble members, and variables. Traditional approaches process 
            these dimensions sequentially. By leveraging tensor operations on GPUs, we achieve 
            <span class="metric">25x speedup</span> on correlation analysis and enable 
            real-time ensemble forecasting.
        </p>

        <h2>The Challenge</h2>
        
        <p>
            Modern climate datasets like MERRA-2 contain terabytes of data across multiple dimensions:
        </p>
        
        <ul>
            <li><strong>Spatial:</strong> 576 √ó 361 grid points (0.625¬∞ √ó 0.5¬∞ resolution)</li>
            <li><strong>Temporal:</strong> Hourly data spanning decades (300,000+ timesteps)</li>
            <li><strong>Variables:</strong> 100+ atmospheric and surface variables</li>
            <li><strong>Ensembles:</strong> 10-50 members for uncertainty quantification</li>
        </ul>

        <p>
            Computing lagged correlations between predictors and streamflow across this 
            hyperspace would take <span class="highlight">weeks on CPUs</span>. 
            Tensor operations reduce this to <span class="highlight">hours</span>.
        </p>

        <h2>Tensor Operation Framework</h2>

        <div class="tech-grid">
            <div class="tech-card">
                <h3>üöÄ GPU Acceleration</h3>
                <p>CuPy arrays enable massive parallelization of correlation computations across spatial grids and lag windows simultaneously.</p>
            </div>

            <div class="tech-card">
                <h3>üìä Broadcasting</h3>
                <p>Automatic dimension expansion allows elegant operations on mismatched tensor shapes without explicit loops.</p>
            </div>

            <div class="tech-card">
                <h3>üéØ Einsum Notation</h3>
                <p>Einstein summation provides concise, readable expressions for complex multi-dimensional contractions.</p>
            </div>

            <div class="tech-card">
                <h3>‚ö° Memory Efficiency</h3>
                <p>Lazy evaluation and chunking prevent memory overflow when processing terabyte-scale datasets.</p>
            </div>
        </div>

        <h2>Interactive Climate Tensor Visualization</h2>
        
        <p>
            This 3D visualization shows a climate data tensor with spatial dimensions (lat, lon) 
            and a temporal dimension. Each layer represents a time step, with colors indicating 
            temperature anomalies. Rotate with mouse to explore the spatiotemporal structure.
        </p>

        <div id="climateViz" style="width: 100%; height: 600px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(100, 200, 255, 0.3); border-radius: 8px; margin: 2rem 0;"></div>

        <div style="text-align: center; margin-top: 1rem; color: #a8d5ff; font-size: 0.9rem;">
            <p>
                <strong>Dimensions:</strong> <span class="metric">25 √ó 25 √ó 48</span> 
                (lat √ó lon √ó time) | 
                <strong>Data:</strong> Temperature anomalies | 
                <strong>GPU Operations:</strong> Parallel slice extraction
            </p>
        </div>

        <h2>Technical Stack</h2>

        <div class="tech-grid">
            <div class="tech-card">
                <h3>CuPy</h3>
                <p>NumPy-compatible interface for GPU arrays, enabling drop-in acceleration</p>
            </div>

            <div class="tech-card">
                <h3>Xarray</h3>
                <p>Labeled multi-dimensional arrays with climate-aware operations</p>
            </div>

            <div class="tech-card">
                <h3>Zarr</h3>
                <p>Chunked, compressed array storage for cloud-native data access</p>
            </div>

            <div class="tech-card">
                <h3>Dask</h3>
                <p>Parallel computing with task scheduling for out-of-core operations</p>
            </div>
        </div>

        <h2>Future Directions</h2>

        <ul>
            <li><strong>Tensor Networks:</strong> Tucker and CP decomposition for ultra-compact 
                climate model emulators</li>
            <li><strong>Neural ODEs:</strong> Physics-informed learning with continuous time 
                representations</li>
            <li><strong>Multi-GPU:</strong> Scaling to continental domains with distributed arrays</li>
            <li><strong>Real-Time Inference:</strong> Sub-second ensemble forecasts for 
                operational decision support</li>
        </ul>

        <div style="margin-top: 3rem; padding-top: 2rem; border-top: 1px solid rgba(100, 200, 255, 0.2);">
            <p style="text-align: center; color: #a8d5ff;">
                <strong>Fluid Tensor Analytics</strong> | Boulder, Colorado<br>
                <a href="mailto:taylor@fluidta.com" style="color: #64c8ff;">taylor@fluidta.com</a>
            </p>
        </div>
    </div>

    <script>
        // Create 3D climate data tensor visualization
        const container = document.getElementById('climateViz');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a1628);
        
        const camera = new THREE.PerspectiveCamera(
            60,
            container.clientWidth / container.clientHeight,
            0.1,
            1000
        );
        camera.position.set(40, 40, 40);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);
        
        // Add lights
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0x64c8ff, 0.8);
        directionalLight.position.set(10, 10, 10);
        scene.add(directionalLight);
        
        // Generate 3D climate tensor data (25x25 spatial grid, 48 time steps)
        const nx = 25, ny = 25, nt = 48;
        const spacing = 1.2;
        const timeSpacing = 0.8;
        
        // Create group for all layers
        const tensorGroup = new THREE.Group();
        
        // Generate time slices
        for (let t = 0; t < nt; t++) {
            const layerGroup = new THREE.Group();
            
            // Create spatial grid for this time slice
            for (let i = 0; i < nx; i++) {
                for (let j = 0; j < ny; j++) {
                    // Generate synthetic temperature anomaly data
                    const x = (i - nx/2) * 0.3;
                    const y = (j - ny/2) * 0.3;
                    const temporal = Math.sin(t * Math.PI / 12) * 0.5;
                    const spatial = Math.exp(-((x)**2 + (y)**2) / 80) * 2;
                    const noise = (Math.random() - 0.5) * 0.3;
                    const value = temporal + spatial + noise;
                    
                    // Map value to color (blue = cold, red = hot)
                    const normalized = (value + 1.5) / 3; // Normalize to 0-1
                    const hue = (1 - normalized) * 0.6; // Blue to red
                    const color = new THREE.Color().setHSL(hue, 0.8, 0.5);
                    
                    // Create small cube for each grid point
                    const geometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                    const material = new THREE.MeshPhongMaterial({ 
                        color: color,
                        transparent: true,
                        opacity: 0.7
                    });
                    const cube = new THREE.Mesh(geometry, material);
                    
                    cube.position.set(
                        (i - nx/2) * spacing,
                        (j - ny/2) * spacing,
                        t * timeSpacing - (nt * timeSpacing / 2)
                    );
                    
                    layerGroup.add(cube);
                }
            }
            
            tensorGroup.add(layerGroup);
        }
        
        scene.add(tensorGroup);
        
        // Add coordinate axes
        const axesHelper = new THREE.AxesHelper(30);
        scene.add(axesHelper);
        
        // Add wireframe box around tensor
        const boxGeometry = new THREE.BoxGeometry(
            nx * spacing,
            ny * spacing,
            nt * timeSpacing
        );
        const boxEdges = new THREE.EdgesGeometry(boxGeometry);
        const boxLine = new THREE.LineSegments(
            boxEdges,
            new THREE.LineBasicMaterial({ color: 0x64c8ff, opacity: 0.3, transparent: true })
        );
        scene.add(boxLine);
        
        // Add dimension labels
        const loader = new THREE.FontLoader();
        
        // Mouse interaction
        let mouseDown = false;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let rotationX = 0, rotationY = 0;
        
        container.addEventListener('mousedown', (e) => {
            mouseDown = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        container.addEventListener('mouseup', () => {
            mouseDown = false;
        });
        
        container.addEventListener('mousemove', (e) => {
            if (mouseDown) {
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                
                targetRotationY += deltaX * 0.01;
                targetRotationX += deltaY * 0.01;
                
                mouseX = e.clientX;
                mouseY = e.clientY;
            }
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const width = container.clientWidth;
            const height = container.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Smooth rotation
            rotationX += (targetRotationX - rotationX) * 0.1;
            rotationY += (targetRotationY - rotationY) * 0.1;
            
            tensorGroup.rotation.x = rotationX;
            tensorGroup.rotation.y = rotationY;
            
            // Gentle auto-rotation when not interacting
            if (!mouseDown) {
                targetRotationY += 0.002;
            }
            
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>
